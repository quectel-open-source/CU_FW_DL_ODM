#include "StdAfx.h"
#include "ARM_OP_QCM.h"
#include "ts_lan.h"

#include "EnumSerial.h"
#include "quectel_devs.h"
#include "C:\\Program Files (x86)\\Qualcomm\\QDART\\QMSL\\QMSL_Core\\inc\\QMSL_EFS.h"

#include <locale>
#include <codecvt>
#include<string.h>
#include <regex>

using namespace std;

//为9x15平台下载中的“模式切换”时锁定代码用
CCriticalSection g_cla_Lock_DM_FB;//第二阶段：DM口下载 >>>> fastboot模式 >>>> 最后DM口下载
CCriticalSection g_cla_Lock_FB_DM;//fastboot模式 >>>> 最后DM口下载
CCriticalSection g_cla_Lock_Enter_EDL;//正常模式 >>>> EDL模式

CCriticalSection g_cla_Lock_QDLoader_Port;//注册表获取QDLOADER口
CCriticalSection g_cla_Lock_Port;
CCriticalSection g_cla_Lock_Port_MBIM;

//fastboot下载运行中
bool g_bFastboot_Runing = false;

//存放MSM8953的QLoader口 10个通道
int g_QDL_USE_Port_List[10]={0,0,0,0,0,0,0,0,0,0};
int g_QDL_USE_Port_num=0;

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <devguid.h>
#include <regstr.h>

/*************************************
* BOOL EnumAllDevice( )
* 功能	列举当前存在的设备
* 返回值	是否成功
**************************************/
BOOL CARM_OP_QCM::EnumAllDevice()
{
	HDEVINFO hDevInfo;
	SP_DEVINFO_DATA DeviceInfoData;
	DWORD i;

	printf("Displaying the Installed Devices\n\n");
	this->Show_Out(_T("Displaying the Installed Devices\r\n"));

	// 得到所有设备 HDEVINFO 
	hDevInfo = SetupDiGetClassDevs(NULL,
		0, // 无类型
		0, // 无回调函数
		DIGCF_PRESENT | DIGCF_ALLCLASSES);
	if (hDevInfo == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	// 循环列举
	DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
	for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i,
		&DeviceInfoData); i++)
	{
		DWORD DataT;
		LPTSTR buffer = NULL;
		DWORD buffersize = 0;

		// 获取详细信息
		while (!SetupDiGetDeviceRegistryProperty(
			hDevInfo,
			&DeviceInfoData,
			SPDRP_DEVICEDESC,
			&DataT,
			(PBYTE)buffer,
			buffersize,
			&buffersize))
		{
			if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			{
				// 内存不足
				if (buffer) HeapFree(GetProcessHeap(), 0, buffer);
				buffer = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, buffersize);
			}
			else
				break;
		}
		// 输出
		// 		printf("GUID:{%.8X-%.4X-%.4X--%.2X%.2X-%.2X%.2X%.2X%.2X%.2X%.2X} "
		// 			"Device: %s\n",
		// 			DeviceInfoData.ClassGuid.Data1,
		// 			DeviceInfoData.ClassGuid.Data2,
		// 			DeviceInfoData.ClassGuid.Data3,
		// 			DeviceInfoData.ClassGuid.Data4[0],
		// 			DeviceInfoData.ClassGuid.Data4[1],
		// 			DeviceInfoData.ClassGuid.Data4[2],
		// 			DeviceInfoData.ClassGuid.Data4[3],
		// 			DeviceInfoData.ClassGuid.Data4[4],
		// 			DeviceInfoData.ClassGuid.Data4[5],
		// 			DeviceInfoData.ClassGuid.Data4[6],
		// 			DeviceInfoData.ClassGuid.Data4[7],buffer);

		CString strSave;
		strSave.Format(_T("Device: %s\r\n"), buffer);
		//this->Show_Out(strSave);

		strSave.MakeUpper();

		if (NULL != wcsstr(strSave, _T("QUECTEL PCI EXPRESS")))
		{
			if (buffer) HeapFree(GetProcessHeap(), 0, buffer);
			//  释放
			SetupDiDestroyDeviceInfoList(hDevInfo);
			return TRUE;
		}
		else
		{
			if (buffer) HeapFree(GetProcessHeap(), 0, buffer);
		}
	}

	if (GetLastError() != NO_ERROR &&
		GetLastError() != ERROR_NO_MORE_ITEMS)
	{
		return FALSE;
	}
	//  释放
	SetupDiDestroyDeviceInfoList(hDevInfo);
	return FALSE;
}







CARM_OP_QCM::CARM_OP_QCM(void)
: m_iCom_Port(0)
, m_iCom_Old_Port(0)
, m_iBaud_Rate(0)
, m_bRuning(false)
, m_iStop_Flag(-1)
, m_csError_Code(_T(""))
, m_iClass_Idx(0)
, m_iDL_Emerg_Norm_TYPE(-1)
, m_ul_Transmit_Bytes(0)
, m_ul_DL_All_Bytes(0)
, m_iComm_Type(0)
, m_bCEFS_DL(false)
, m_iCTRL_DL_TYPE(0)
, m_iDelay_Time(0)
, m_bQCN_DL(false)
, m_bFW_DL(false)
, m_bQCN_BACKUP(false)
, m_bQCN_RESTORE(false)
, m_csNv_Definition_File(_T(""))
, m_iCTRL_DLOAD_PORT(0)
, m_iDLOAD_PORT(0)
, m_bLow_Speed_CPU(false)
, m_csCurr_Exe_Path(_T(""))
, m_bFastboot_DL(false)
, m_csPartition_XML_File(_T(""))
, m_csFW_File_Path(_T(""))
, m_Ts_Num(0)
, m_DM_Port(0)
, m_iFirhose_DB(0)
, m_iFirhose_DB_Path(0)
, m_iAutoDL_Flag(0)
, m_bEDL_Now(false)
, mQCM_SC662NCE_Flag(false)
, m_bDL_Provision(false)
, m_bPCIE_DL(false)
, m_bSaharaOnly(FALSE)
, m_iQDPort(0)
, m_iSdx55_Port(0)
, m_iProdu_Type(0)
, m_iATCom_Port(0)
, m_iCsrListNum(0)
, m_bAUTOSEL_MBN(FALSE)
, m_bHoneywell_A4_flag(false)
, m_bQDM002_flag(false)
, m_iAT_Port(0)
, m_bAT_UseFlag(false)
, m_bAT_UseFlag_QDM(false)
, m_strEID(_T(""))
, m_bOldFlag(false)
, m_iBG95_Ctrl_Port(0)
, m_bQDM01_Pow_Ctrl(false)
, m_bAG_Flag(false)
, m_iProvision_Type(0)
, m_bQDloader_Get_Success(false)
, m_strQW_MAC(_T(""))
, m_strESP32_Bootloader_Path(_T(""))
, m_strESP32_PartitionTable_Path(_T(""))
, m_strESP32_OtaDataInitial_Path(_T(""))
, m_strESP32_NetworkAdapter_Path(_T(""))
, m_strESP32_HaraldUpgrader_Path(_T(""))
, m_csScat_Cfg_File_Path(_T(""))
, str_ESP32_File_All(_T(""))
, iQDC519_Port1(0)
, iQDC519_Port2(0)
, iQDC519_Port3(0)
, iQDC519_Port4(0)
, m_iBBchip_Curr(0)
, m_str_QDE017_Binfile(_T(""))
, str_InputSN(_T(""))
{
	m_str_Pkt_Send.ucp_Buff = NULL;
	m_str_Pkt_Send.ul_Total_Size = 0;
	m_str_Pkt_Send.ul_Data_Length = 0;

	m_str_Pkt_Read.ucp_Buff = NULL;
	m_str_Pkt_Read.ul_Total_Size = 0;
	m_str_Pkt_Read.ul_Data_Length = 0;

	m_hQLib_Handle = NULL;

	m_iMDM9X07_NEW_FLAG =0;
	m_bFirehose_Reset_after_DL = false;

    for (int num=0;num<Firehose_File_NUM;num++)
    {
		Firehose_File[num].dis_flag =0;
    }
	Firehose_File[0].Firehose_File = _T("sbl1.mbn");
	Firehose_File[1].Firehose_File = _T("tz.mbn");// tz.mbn
	Firehose_File[2].Firehose_File = _T("rpm.mbn");// rpm.mbn
	Firehose_File[3].Firehose_File = _T("appsboot.mbn");// appsboot.mbn
	Firehose_File[4].Firehose_File = _T("mdm9607-perf-boot.img");// mdm9607-perf-boot.img
	Firehose_File[5].Firehose_File = _T("mdm-perf-recovery-image-mdm9607-perf.ubi");// mdm-perf-recovery-image-mdm9607-perf.ubi
	Firehose_File[6].Firehose_File = _T("NON-HLOS.ubi");// 
	Firehose_File[7].Firehose_File = _T("usrdata.ubi");// usrdata.ubi
	Firehose_File[8].Firehose_File = _T("mdm9607-perf-sysfs.ubi");// mdm9607-perf-sysfs.ubi
	Firehose_File[9].Firehose_File = _T("mdm9607-perf-sysfs-ocpu.ubi");// mdm9607-perf-sysfs-ocpu.ubi
	//Firehose_File[11].Firehose_File = _T("partition_complete_p4K_b256K.mbn");// partition_complete_p4K_b256K.mbn

	m_eu_Memory_Type = EMMC;


	mMbn_File_NUM=0;

	m_bSending_File =false;
	m_bSendFileRes =false;
	m_csMbnFilePath = _T("");

	m_csOC = _T("");
	this->m_rep_flag = false;
	m_csMCU_Name = _T("");
	

}

CARM_OP_QCM::~CARM_OP_QCM(void)
{
	for (int num=0;num<Firehose_File_NUM;num++)
	{
		Firehose_File[num].dis_flag =0;
		Firehose_File[num].Firehose_File = _T("");
	}

	//释放PKT_BUFF内存
	if(m_str_Pkt_Send.ucp_Buff != NULL)
	{
		free(m_str_Pkt_Send.ucp_Buff);

		m_str_Pkt_Send.ucp_Buff = NULL;
		m_str_Pkt_Send.ul_Total_Size = 0;
		m_str_Pkt_Send.ul_Data_Length = 0;
	}

	if(m_str_Pkt_Read.ucp_Buff != NULL)
	{
		free(m_str_Pkt_Read.ucp_Buff);

		m_str_Pkt_Read.ucp_Buff = NULL;
		m_str_Pkt_Read.ul_Total_Size = 0;
		m_str_Pkt_Read.ul_Data_Length = 0;
	}
}

bool CARM_OP_QCM::LOAD_FW_FILE(const wchar_t * wcp_FW_File_Path)
{
	bool bRtn;
	//依据不同BB平台，运行FW加载函数
	switch(this->m_eu_BB_Chip)
	{
	case MDM6X00:
	case QSC6270:
	case MDM9X15:
		bRtn = this->LOAD_FW_FILE_V1(wcp_FW_File_Path);
		break;
	case MDM9X07:
		{
			
			m_iMDM9X07_NEW_FLAG =0;
			bRtn = this->LOAD_FW_FILE_V2(wcp_FW_File_Path);
		}
		
		break;
	case MSM8909:
		//20201201 SC20-AX机型只能sahara下载
		{
			m_iMDM9X07_NEW_FLAG = 0;
			bRtn = this->LOAD_FW_FILE_V3_Ext(wcp_FW_File_Path);
		}

		//bRtn = this->LOAD_FW_FILE_V3(wcp_FW_File_Path);
		break;
	case MSM8917:
		bRtn = this->LOAD_FW_FILE_V7(wcp_FW_File_Path);
		break;
	case MSM8937:
		bRtn = this->LOAD_FW_FILE_V4(wcp_FW_File_Path);
		break;
	case MSM8953:
		bRtn = this->LOAD_FW_FILE_V5(wcp_FW_File_Path);
		break;

	case SM6115:
		bRtn = this->LOAD_FW_FILE_SM6115(wcp_FW_File_Path);
		break;

	case QCM6125:
		bRtn = this->LOAD_FW_FILE_QCM6125(wcp_FW_File_Path);
		break;

	case SM4350:
		bRtn = this->LOAD_FW_FILE_SM4350(wcp_FW_File_Path);
		break;
	
	case MDM9X40:
		{
			m_iMDM9X07_NEW_FLAG =0;
			bRtn = this->LOAD_FW_FILE_V2_EXT(wcp_FW_File_Path);
		}
		break;
	case MDM9X06:
		{
			m_iMDM9X07_NEW_FLAG =0;
			//bRtn = this->LOAD_FW_FILE_V6(wcp_FW_File_Path);
			bRtn = this->LOAD_FW_FILE_V2_MDM9X06(wcp_FW_File_Path);
		}		
		break;

		//20221210
	case Chip_MCU:
	{
		bRtn = this->Load_MCU_File();
	}
	break;

	case Chip_ESP32:
	{
		bRtn = ESP32_Setting();
	}
	break;

	case MDM9X05:
		{
			m_iMDM9X07_NEW_FLAG =0;
			if (NULL != wcsstr(m_csOC, _T("QDM041")))
			{
				bRtn = this->Load_MCU_File();
			} 
			else
			{
				bRtn = this->LOAD_FW_FILE_V6_EXT(wcp_FW_File_Path);
			}
			
		}		
		break;
	case SDX20:
	case SDX55:
	case AG215S:
		{
			m_iMDM9X07_NEW_FLAG =0;
			bRtn = this->LOAD_FW_FILE_V2(wcp_FW_File_Path);
		}

		break;

	case SDM660:
		bRtn = this->LOAD_FW_FILE_Sdm660(wcp_FW_File_Path);
		break;
	case MDM9X55:
		{
			m_iMDM9X07_NEW_FLAG =0;
			bRtn = this->LOAD_FW_FILE_9X55(wcp_FW_File_Path);
		}
		break;

	case SDM845:
		bRtn = this->LOAD_FW_FILE_Sdm845(wcp_FW_File_Path);
		break;

	case HONEYWELL:
		bRtn = this->LOAD_FW_FILE_HONEYWELL(wcp_FW_File_Path);
		break;

	//case QDM002:
	//	bRtn = this->LOAD_FW_FILE_QDM002(wcp_FW_File_Path);
	//	break;

	case SDX62:
		if (_T("QDM040NARN-M20-AAAAA") == m_csOC 
			|| _T("QDM040EURN-M20-AAAAA") == m_csOC
			|| _T("QDM059EARN-NA-AAAAA") == m_csOC
			|| _T("QDM059EARN-EU-AAAAA") == m_csOC
			)
		{
			this->Show_Out(_T("No files need to be loaded;"));
			bRtn = true;
		}
		break;
		

	default:
		bRtn = false;
		break;
	}
	

	//
	return bRtn;
}

void CARM_OP_QCM::Load_Com_Port_Params(void)
{
	//同步串口
	this->m_cla_Com_Port.m_iPort = this->m_iCom_Port;
	this->m_cla_Com_Port.m_iBaudRate = this->m_iBaud_Rate;
	//重叠串口
	this->m_cla_Com_Thr_Port.m_str_COM.dwCom = this->m_iCom_Port;
	this->m_cla_Com_Thr_Port.m_str_COM.dwBaudRate = this->m_iBaud_Rate;
	this->m_cla_Com_Thr_Port.m_str_COM.iStopBits = ONESTOPBIT;
	this->m_cla_Com_Thr_Port.m_str_COM.iParity = NOPARITY;
	this->m_cla_Com_Thr_Port.m_str_COM.iByteSize = 8;
	this->m_cla_Com_Thr_Port.m_str_COM.iFlowType = 0;

	this->m_cla_Com_Thr_Port.m_str_COM.iDtrControl = TRUE;
	this->m_cla_Com_Thr_Port.m_str_COM.iRtsControl = TRUE;
}

int CARM_OP_QCM::Do_Execute(void)
{
	int iRtn;

	CString strATCommand,strData,strInfo;
	unsigned long ulBytes=0;
	bool bRetFalg =false;


	//初始显示
	this->Show_Status(_T("Waiting......"));

	//初始化控制运行的相关参数
	this->m_iStop_Flag = -1;
	this->m_bRuning = true;
	this->m_csError_Code.Format(_T(""));
	this->m_iError_Code = 0;


#ifndef FW_MULTI
	if (MDM9X06 == this->m_eu_BB_Chip)//BG96
	{	
		//首先从DM口获取到AT端口

		//------------------------------------------------------
		CString strData;
		CString strAT_Port,strDM_Port;

		std::wstring wsAT_Port;
		std::wstring wsDM_Port;

		int i;
		int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
		bool bEDL_Now = false;//是否“已经是EDL模式”

		//------------------------------ 检查串口是否存在 ------------------------------ 
		if(this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port) == true)
		{
			//DM口已经存在，则说明模块已预先开机，无需特别延迟
		}
		else
		{
			//DM口还不存在，需要探测，并额外给开机延迟时间
			//探测DM口生成
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 25) == false)
			{
				this->Show_Status(_T("FAIL,PORT NOT FIND FAIL."));
				this->Show_Out(_T("FAIL,PORT NOT FIND FAIL."));
				this->Save_Trace_Log(_T("FAIL,PORT NOT FIND FAIL"));	

				//恢复初始值
				this->m_iStop_Flag = -1;
				this->m_bRuning = false;

				return RTN_FAIL;
			}
		}

		//------------------------------ 判断COM口是否是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“9x07的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“9x07的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++
		if (false == bEDL_Now)
		{
			try
			{
				strDM_Port.Format(_T("COM%d"),this->m_iCom_Port);
				wsDM_Port = strDM_Port.GetString();

				strData.Format(_T("DM Port:%d"),this->m_iCom_Port);
				this->Show_Out(strData);
				this->Save_Trace_Log(strData);

				if (false == ::get_ports_underlying_net_adpter_Ext(wsDM_Port,wsAT_Port))
				{
					this->Show_Out(_T("AT Port Get Fail\r\n"));
					this->Save_Trace_Log(_T("AT Port Get Fail"));
					throw(2);
				}

				strAT_Port.Format(_T("%s"),wsAT_Port.c_str());

				strAT_Port.Replace(_T("COM"),_T(""));

				m_iATCom_Port=_wtoi(strAT_Port);

				this->Show_Out(_T("AT Port:"));
				this->Show_Out(strAT_Port);
				this->Save_Trace_Log(strAT_Port);

				//先下载MBN************************************************
				int num=0;
				this->m_cla_AT_Com_Port.m_iBaudRate = 115200;
				this->m_cla_AT_Com_Port.m_iPort = m_iATCom_Port;
				this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
				this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;

				if(!this->m_cla_AT_Com_Port.Port_Open(500))
				{
					this->Show_Status(_T("FAIL,AT PORT OPEN FAIL."));
					this->Show_Out(_T("FAIL,AT PORT OPEN FAIL."));
					this->Save_Trace_Log(_T("FAIL,AT PORT OPEN FAIL."));
					throw(7);
				}

				//----20190109-----------------------------------------------------
				//AT+QMBNCFG="Deactivate"
				strATCommand.Format(_T("AT+QMBNCFG=\"Deactivate\""));
				//返回值：OK

				bRetFalg = Deactivate_MBN_In_AT(20, strATCommand);
				if (bRetFalg == false)
				{
					this->Show_Status(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));
					this->Show_Out(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));
					this->Save_Trace_Log(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));
					//继续

					throw(6);
				}
				else
				{
					this->Show_Out(_T("AT+QMBNCFG=\"Deactivate\" PASS"));
					this->Save_Trace_Log(_T("AT+QMBNCFG=\"Deactivate\" PASS"));
				}

				//  [2017-10-12_19:57:42]+QMBNCFG: "List",0,0,0,"ROW_Generic_3GPP",0x05010814,201704141
				//	[2017-10-12_19:57:42]+QMBNCFG: "List",1,1,1,"Telstra-Commercial_VoLTE",0x0580070D,201710111

				m_iCsrListNum =0;

				strATCommand.Format(_T("at+qmbncfg=\"list\""));
				bRetFalg = List_Op_In_AT_Ext(20, strATCommand);
				if (bRetFalg == false)
				{
					this->Show_Status(_T("at+qmbncfg=\"list\" FAIL"));

					this->Show_Out(_T("at+qmbncfg=\"list\" FAIL"));
					this->Save_Trace_Log(_T("at+qmbncfg=\"list\" FAIL"));

//				throw(4);
				}
				else
				{
					this->Show_Out(_T("at+qmbncfg=\"list\" PASS"));
					this->Save_Trace_Log(_T("at+qmbncfg=\"list\" PASS"));
				}
				//"AT+QMBNCFG=\"Delete\",\"Att_Non_Valte_Lab\""
				for (num=0;(num<m_iCsrListNum) && (num<16);num++)
				{
					strData.Format(_T("AT+QMBNCFG=\"Delete\",\"%s\""),m_csrPN[num]);

					bRetFalg = QMBN_Del_In_AT(20, strData);
					this->Show_Out(strData);
					this->Save_Trace_Log(strData);

				}

				//---------------------------------------------------------
				if (mMbn_File_NUM <= 0)
				{
					this->Show_Out(_T("Mbn_File_NUM=0,Please Check!"));
					this->Save_Trace_Log(_T("Mbn_File_NUM=0,Please Check!"));
				}
				else
				{
					strData.Format(_T("Mbn_File_NUM=%d"), mMbn_File_NUM);
					this->Save_Trace_Log(strData);
				}
				

				for (num=0;num<mMbn_File_NUM;num++)
				{
					this->Show_Out(m_strr_Mbn_File_List_Ext[num].cs_Path);
					this->Save_Trace_Log(m_strr_Mbn_File_List_Ext[num].cs_Path);

					//AT+QMBNCFG="Deactivate"
					strATCommand.Format(_T("AT+QMBNCFG=\"Deactivate\""));
					//返回值：OK

					bRetFalg = Deactivate_MBN_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						this->Show_Status(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));
						this->Show_Out(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));
						this->Save_Trace_Log(_T("AT+QMBNCFG=\"Deactivate\" FAIL"));

						//继续
						throw(6);
					}
					else
					{
						this->Show_Out(_T("AT+QMBNCFG=\"Deactivate\" PASS"));
						this->Save_Trace_Log(_T("AT+QMBNCFG=\"Deactivate\" PASS"));
					}
					//AT+QFDEL="mcfg_sw.mbn"`
					strATCommand.Format(_T("AT+QFDEL=\"%s\""),m_strr_Mbn_File_List_Ext[num].cs_Name);
					//返回值：OK

					bRetFalg = Qfdel_In_AT(20, strATCommand);
					this->Show_Out(strATCommand);
					this->Save_Trace_Log(strATCommand);

					//1;
					//AT+QFUPL="RAM:mcfg_sw.mbn",26280  26280 是文件大小
					strATCommand.Format(_T("AT+QFUPL=\"%s\",%lu"),m_strr_Mbn_File_List_Ext[num].cs_Name,m_strr_Mbn_File_List_Ext[num].ul_File_Size);
					//返回值：CONNECT

					bRetFalg = Set_MBN_Sent_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						strData.Format(_T("%s  FAIL"),strATCommand);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						throw(1);
					}
					else
					{
						strData.Format(_T("%s  PASS"),strATCommand);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}
					//2:
					//AT发送mcfg_sw.mbn文件到模块
					//返回值：OK
					// 		bRetFalg = DL_Mbn_File_Ext(strMbnPath, ulBytes);
					// 		if (bRetFalg == false)
					// 		{
					// 			this->Show_Status(_T("MBN DL FAIL"));
					// 			throw(2);
					// 		}
					m_bSending_File = true;
					m_csMbnFilePath.Format(_T("%s%s"),m_strr_Mbn_File_List_Ext[num].cs_Path,m_strr_Mbn_File_List_Ext[num].cs_Name);
					this->Save_Trace_Log(m_csMbnFilePath);

					OnSend_MBNFile();
					while (m_bSending_File == true)
					{
						//GetDlgItem(IDC_MBN_INFO)->SetWindowText(_T("Please Waiting......,MBN DownLoading......"));
						Sleep(200);
					}
					if (m_bSendFileRes == false)
					{
						strData.Format(_T("DownLoad MBN(%s) FAIL"),m_strr_Mbn_File_List_Ext[num].cs_Name);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						throw(2);
					}
					else
					{
						strData.Format(_T("DownLoad MBN(%s) PASS"),m_strr_Mbn_File_List_Ext[num].cs_Name);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}


					//3:
					//at+qmbncfg="add","mcfg_sw.mbn"
					strATCommand.Format(_T("at+qmbncfg=\"add\",\"%s\""),m_strr_Mbn_File_List_Ext[num].cs_Name);
					//返回值：OK

					bRetFalg = Add_MBN_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						strData.Format(_T("%s  FAIL"),strATCommand);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						//继续
						throw(3);
					}
					else
					{
						strData.Format(_T("%s  PASS"),strATCommand);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}

				}

				//
				//4-1:
				//at+qmbncfg="list" 

				//  [2017-10-12_19:57:42]+QMBNCFG: "List",0,0,0,"ROW_Generic_3GPP",0x05010814,201704141
				//	[2017-10-12_19:57:42]+QMBNCFG: "List",1,1,1,"Telstra-Commercial_VoLTE",0x0580070D,201710111
				strATCommand.Format(_T("at+qmbncfg=\"list\""));
				bRetFalg = List_Op_In_AT(20, strATCommand);
				if (bRetFalg == false)
				{
					this->Show_Status(_T("at+qmbncfg=\"list\" FAIL"));
					this->Show_Out(_T("at+qmbncfg=\"list\" FAIL"));
					this->Save_Trace_Log(_T("at+qmbncfg=\"list\" FAIL"));

					throw(4);
				}
				else
				{
					this->Show_Out(_T("at+qmbncfg=\"list\" PASS"));
					this->Save_Trace_Log(_T("at+qmbncfg=\"list\" PASS"));
				}

				if(TRUE == this->m_bAUTOSEL_MBN )
				{
					//打开MBN自动选择功能
					//---------------------------------------------------------
					// 如果客户选择 YES， 则执行指令AT+QMBNCFG="autosel",1
					strATCommand.Format(_T("AT+QMBNCFG=\"autosel\",1"));
					bRetFalg = Autosel_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						strData.Format(_T("%s FAIL"),strATCommand);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						throw(4);
					}
					else
					{
						strData.Format(_T("%s PASS"),strATCommand);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}
					//---------------------------------------------------------
				}
				else
				{
					//打开MBN自动选择功能
					//---------------------------------------------------------
					// 如果客户选择 YES， 则执行指令AT+QMBNCFG="autosel",0
					strATCommand.Format(_T("AT+QMBNCFG=\"autosel\",0"));
					bRetFalg = Autosel_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						strData.Format(_T("%s FAIL"),strATCommand);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						throw(4);
					}
					else
					{
						strData.Format(_T("%s PASS"),strATCommand);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}
					//---------------------------------------------------------
				}

				
#if 0


				if(m_strOpName.GetLength()>0) 
				{
					//20180920
					//4:at+qmbncfg="select","Telstra-Commercial_VoLTE"
					//OK
					strATCommand.Format(_T("at+qmbncfg=\"select\",\"%s\""),m_strOpName);
					bRetFalg = Select_Op_In_AT(20, strATCommand);
					if (bRetFalg == false)
					{
						strData.Format(_T("%s FAIL"),strATCommand);
						this->Show_Status(strData);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);

						throw(4);
					}
					else
					{
						strData.Format(_T("%s PASS"),strATCommand);
						this->Show_Out(strData);
						this->Save_Trace_Log(strData);
					}
				}
#endif

				this->m_cla_AT_Com_Port.Port_Close();
			} 
			catch(...)
			{
				this->m_cla_AT_Com_Port.Port_Close();
				//恢复初始值
				this->m_iStop_Flag = -1;
				this->m_bRuning = false;

				return RTN_FAIL;
			}
		}
		else //紧急模式下无法做升级MBN,仅能升固件版本
		{
			strData.Format(_T("EDL MODE-NOT UPGRADE MBN"));
			this->Save_Trace_Log(strData);
		}

		//再升级Firmware
		iRtn = this->Execute_MDM9X06();


		//恢复初始值
		this->m_iStop_Flag = -1;
		this->m_bRuning = false;
		return iRtn;
	}

#endif


	//下载的执行
	switch(this->m_eu_BB_Chip)
	{
	case MDM6X00:
	case QSC6270:
		iRtn = this->Execute_MDM6X00();
		break;

	case HONEYWELL:
		iRtn = this->Execute_HONEYWELL();
		break;

//	case QDM002:
//		iRtn = this->Execute_QDM002();
//		break;


	case MDM9X15:
		iRtn = this->Execute_MDM9X15_V2();
		break;
	case MDM9X07:
		//QDE006EUEF - N06 - AAAAA
		if (_T("QDE006EUEF-N06-AAAAA") == m_csOC)//QDE006 MCU2的固件版本
		{
			iRtn = this->Execute_QDE006_MCU2();
		}
		//20220223
		else if (NULL != wcsstr(m_csOC, _T("QDM002")))
		{
			iRtn = this->DL_FW_ESP32_MCU();
		}
		else
		{
			iRtn = this->Execute_MDM9X07();
		}

		break;
	case MDM9X40:
	case SDX20:
	case AG215S:
		iRtn = this->Execute_MDM9X07();
		break;

	case SDX55:

		//如果设置串口，先要拉低下DTR管脚
		if (m_iSdx55_Port>0)
		{
			this->m_cla_Sdx55_Com_Port.m_iPort = m_iSdx55_Port;
			this->m_cla_Sdx55_Com_Port.m_iBaudRate = 115200;
			this->m_cla_Sdx55_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
			this->m_cla_Sdx55_Com_Port.Port_Open(300);
		}
		
		iRtn = this->Execute_MDM9X07();

		if (m_iSdx55_Port>0)
		{
			this->m_cla_Sdx55_Com_Port.Port_Close();
		}
		//如果设置串口，关闭端口

		break;

	case MSM8909:
		iRtn = this->Execute_MSM8909();
		break;
	case MSM8917:
		iRtn = this->Execute_MSM8917();
		break;
	case MSM8937:
		iRtn = this->Execute_MSM8937();
		break;
	case MSM8953:
		iRtn = this->Execute_MSM8953();
		break;
	case MDM9X06:
		iRtn = this->Execute_MDM9X06();
		break;
	case SDM660:
		iRtn = this->Execute_SDM660();
		break;
	case MDM9X55://AG15
		iRtn = this->Execute_MDM9X55();
		break;

	case MDM9X05://BG95
	
		//如果设置串口，先要拉低下RTS管脚
//		if (m_iBG95_Ctrl_Port>0)
//		{
//			this->m_cla_BG95_Com_Port.m_iPort = m_iBG95_Ctrl_Port;
//			this->m_cla_BG95_Com_Port.m_iBaudRate = 115200;
//			this->m_cla_BG95_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
//			this->m_cla_BG95_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
//			this->m_cla_BG95_Com_Port.Port_Open(300);
//		}


			iRtn = this->Execute_MDM9X05();


		

//		if (m_iBG95_Ctrl_Port>0)
//		{
//			this->m_cla_BG95_Com_Port.Port_Close();
//			Sleep(500);
//			this->m_cla_BG95_Com_Port.m_iPort = m_iBG95_Ctrl_Port;
//			this->m_cla_BG95_Com_Port.m_iBaudRate = 115200;
//
//			this->m_cla_BG95_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
//			this->m_cla_BG95_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
//
//			this->m_cla_BG95_Com_Port.Port_Open(300);
//			Sleep(10000);
//			this->m_cla_BG95_Com_Port.Port_Close();
//			
//		}

		break;	

	case SDM845:
		iRtn = this->Execute_SDM845();
		break;

	case QCM6125:
		iRtn = this->Execute_QCM6125();
		break;		

	case SM6115:
		iRtn = this->Execute_SM6115();
		break;

	case SM4350:
		iRtn = this->Execute_SM4350();
		break;

	case  SDX62:
		if (NULL != wcsstr(m_csOC, _T("QDM040"))
			|| NULL != wcsstr(m_csOC, _T("QDM059"))
			)
		{
			iRtn = this->DL_FW_ESP32_MCU();
		}
		break;

	case Chip_MCU:
		iRtn = DL_FW_MCU_All();
		break;

	case Chip_ESP32:

		if (_T("QDM548EAEF-EU-AAASM") == m_csOC)
		{
			m_cla_GFC.Kill_Process(_T("adb.exe"));
			m_cla_GFC.Kill_Process(_T("fastboot.exe"));
			m_cla_GFC.Kill_Process(_T("cmd.exe"));
			this->Show_Status(_T("wait boot 25s..."));
			Sleep(25000);

			Only_Run_Cmd_NoReturnData_QDM548(GetExeFilePath() + _T("\\"), _T("QDM548_ESP32_download.bat"));
			this->Show_Status(_T("QDM548_ESP32_download.bat"));

			m_cla_GFC.Kill_Process(_T("adb.exe"));
			m_cla_GFC.Kill_Process(_T("fastboot.exe"));
			m_cla_GFC.Kill_Process(_T("cmd.exe"));
		}

		if (this->DL_FW_ESP32_MCU_Smart(&Mystruct_ESP32_FileAddress) != RTN_SUCCESS)
		{
			iRtn = RTN_FAIL;
			Save_Trace_Log(_T("ESP32 DL Fail"));
			this->Show_Out(_T("ESP32 DL Fail"));
		}
		else
		{
			iRtn = RTN_SUCCESS;
			Save_Trace_Log(_T("ESP32 DL Pass"));
			this->Show_Out(_T("ESP32 DL Pass"));
		}
		break;
		
	default:
		iRtn = RTN_FAIL;
		break;
	}

	//20210329 QDM002
	if (RTN_SUCCESS == iRtn)
	{	
		strData.Format(_T("=====OC:%s====="), m_csOC);
		Save_Trace_Log(strData);
		this->Show_Out(strData);	
	}
	else
	{
		strData.Format(_T("=====ERR-OC:%s====="), m_csOC);
		Save_Trace_Log(strData);
		this->Show_Out(strData);
	}





	//恢复初始值
	this->m_iStop_Flag = -1;
	this->m_bRuning = false;


	//返回
	return iRtn;
}

int CARM_OP_QCM::DL_FW_V1(void)
{
	CString csData;
	unsigned long ulMax_Block_Size = 0;

	CString strInfo;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//初始化PKT_BUFF内存
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);

		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			m_csError_Code = csData;
			throw(0);
		}

		//----------------------- 下载口和下载模式的初始值设置 ----------------------- 
		//“下载模式”初始值设置
		switch(this->m_iCTRL_DL_TYPE)
		{
		case QCMM_DL_TYPE_AUTO://“自动识别下载模式”
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;
			break;
		case QCMM_DL_TYPE_EMERG:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;
			break;
		case QCMM_DL_TYPE_NORM:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;
			break;
		default:
			this->Show_Status(_T("Error, Ctrl dl type is wrong!"));
			throw(0);
		}
		csData.Format(_T("CTRL_DL_TYPE=%d"),m_iCTRL_DL_TYPE);
		this->Show_Out(csData);

		//“下载口”初始值设置
		this->m_iDLOAD_PORT = QCMM_DL_PORT_NDF;



		//----------------------- 探测确定“下载口”----------------------- 
		switch(this->m_iCTRL_DLOAD_PORT)
		{
		case QCMM_DL_PORT_AUTO://自动识别下载口和模式
			{
				//探测、识别下载口（有可能会确认好“下载模式”）
				if(this->Ping_DLoad_Port(&this->m_iDLOAD_PORT, &this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);

					this->Show_Out(_T("Ping_DLoad_Port Fail"));
					this->Show_Out(this->m_csError_Code);

					throw(0);
				}
				else
				{
					csData.Format(_T("DLOAD_PORT=%d,DL_Emerg_Norm_TYPE=%d"),this->m_iDLOAD_PORT,this->m_iDL_Emerg_Norm_TYPE);
					this->Show_Out(csData);

				}
			}
			break;
		case QCMM_DL_PORT_DIAG://手动选择USB-Diag口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;
			}
			break;
		case QCMM_DL_PORT_UART://手动选择UART口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_UART;
			}
			break;
		default:
			this->Show_Status(_T("Error, Ctrl dload port is wrong!"));
			throw(0);
		}


		//----------------------- 如果已确认了“下载模式”，则不需要切换到“下载状态”，因为已经是下载状态了 ----------------------- 
		//----------------------- 如果还没有识别到“下载模式”，则需要依据“下载口”发送切换下载状态的指令 ----------------------- 
		if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF)
		{
			//依据“下载口”不同，切换下载模式的操作也是不同的
			switch(this->m_iDLOAD_PORT)
			{
			case QCMM_DL_PORT_DIAG://USB-Diag口，使用协议指令
				{
					//发3A A1 6E 7E
					if(this->Switch_To_DL_Mode(2) == true)
					{
						//重启串口
						if(this->COM_PORT_RE_DETECT(_T("DIAG Switching"), 4500, true) == false)
						{
							this->m_csError_Code += _T(" [Diag Open]");
							this->Show_Status(this->m_csError_Code);
							throw(0);
						}
					}
					else
					{
						this->Show_Status(this->m_csError_Code);
						throw(0);
					}
				}
				break;
			case QCMM_DL_PORT_UART://UART口，使用AT指令，并把波特率切换到115200
				{
					//需要临时切换波特率到115200
					this->COM_PORT_CHANGE_BAUDRATE(115200);
					//新波特率，重启串口
					this->COM_PORT_RE_DETECT(_T("Reopen com to change baudrate......"), 0, true);

					//发AT+QDL指令
					if(this->Switch_To_DL_Mode_In_AT(3) == true)
					{
						//AT发送结束后，把波特率切换回来
						//切换回下载波特率
						this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
						//重启串口
						if(this->COM_PORT_RE_DETECT(_T("UART Switching"), 4000, true) == false)
						{
							this->m_csError_Code += _T(" [Uart Open]");
							this->Show_Status(this->m_csError_Code);
							throw(0);
						}
					}
					else
					{
						this->Show_Status(this->m_csError_Code);
						throw(0);
					}
				}
				break;
			default:
				this->Show_Status(_T("Error, dload port is wrong!"));
				throw(0);
			}
		}//if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF


		//----------------------- 切换到下载模式（能下载hex和mbn文件），已经识别到下载模式的情况，则不用再切换了 ----------------------- 
		//----------------------- 未识别到下载模式时，在此步探测、确定下载模式 ----------------------- 
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_NDF:	//下载模式未知
		case QCMM_DL_TYPE_AUTO:	//“自动识别下载模式”
			{
				//PING 模块，切换下载模式，并且探测下载模式
				if(this->Ping_Downloader(&this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_EMERG:
		case QCMM_DL_TYPE_NORM:
			break;//已有确切的下载模式
		default:
			this->Show_Status(_T("Error, DL type is wrong!"));
			throw(0);
		}

		//把识别到的DL_TYPE显示到界面
		this->Show_DL_Info();

		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		for(int i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}

		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;

		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}


		//----------------------- 读flash的max write block size数据 ----------------------- 
		if(this->READ_DMSS_HW_INFO(&ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		else
		{
			
			strInfo.Format(_T("Max_Block_Size:0x%x"),ulMax_Block_Size);

			this->Show_Out(strInfo);
		}

		//判定CPU类型
		switch(ulMax_Block_Size)
		{
		case 0x0200:	//UC15紧急下载
			this->m_bLow_Speed_CPU = true;//低速
			break;
		case 0x1000:	//UC15正常下载
		case 0x0100:	//UC20紧急下载
		case 0x4000:	//UC20正常下载
			this->m_bLow_Speed_CPU = false;//高速
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, Flash block size [ 0x%X ] is wrong!"), ulMax_Block_Size);
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x3F9)
		{
			ulMax_Block_Size = 0x3F9;//高速
		}


		//----------------------- 下载HEX文件 ----------------------- 
		//按下载模式不同，下载不同的HEX文件
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_E.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_E, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_NORM:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_N.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_N, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}



		/*
		//======================= 探测模块重启 ======================= 
		int iNew_Port;

		this->COM_PORT_CLOSE();

		if(this->SCAN_NEW_COM_PORT(this->m_cla_Com_Port.m_iPort, &iNew_Port, 7) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		if(iNew_Port > 0)//下载mbn文件时，下载口号发生了改变，载入新COM口
		{
			this->m_cla_Com_Port.m_iPort = iNew_Port;
		}

//		this->m_iCom_Port = iNew_Port;//界面输入的COM口号，是起始操作COM口，（暂不更新）

		Sleep(500);

		//打开串口（第二次）
		if(this->COM_PORT_OPEN() == false)
		{
			this->m_csError_Code.Format(_T("%s"), this->GET_COM_PORT_ERROR_INFO());
			throw(0);
		}
		*/



		//======================= 重启串口，开始下载mbn文件 =======================
		//if(this->COM_PORT_RE_DETECT(_T("Detect"), 4500, true) == false)
		if(this->COM_PORT_RE_DETECT(_T("Detect"), 9000, true) == false)
		{
			this->m_csError_Code += _T(" [2nd Open]");
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("COM_PORT_RE_DETECT PASS"));



		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		//if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		if(this->Send_Stream_Cmd_Hello(20, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("Send_Stream_Cmd_Hello PASS"));


		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}


		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));

		//----------------------- 设置Security_Mode，我们用“0x00 – Nontrusted”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x00) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);

			throw(0);
		}
        this->Show_Out(_T("Send_Stream_Cmd_Security_Mode PASS"));

		//----------------------- 写标志位 ----------------------- 
		this->Send_Write_DLoad_Flag(0x01, 1);

		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("DL_Partition_Table_File PASS"));

		//----------------------- 下载其他mbn文件 ----------------------- 
		if(this->DL_Mbn_All_File(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("DL_Mbn_All_File PASS"));


		//----------------------- 下载cefs文件 ----------------------- 
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			if(this->DL_Cefs_File(ulMax_Block_Size) == false)
			{
				this->Show_Status(this->m_csError_Code);
				this->Show_Out(this->m_csError_Code);
				throw(0);
			}
			this->Show_Out(_T("DL_Cefs_File PASS"));
		}

		//----------------------- 清除标志位 ----------------------- 
		this->Send_Write_DLoad_Flag(0x00, 1);

		//****************************************************88
		//模块重启的延时，否则关闭端口会有问题
		if (QCMM_DL_PORT_UART  == this->m_iDLOAD_PORT)
		{		
			CString csA, csB;
			int s = 200;
			//模块重启时间，进度简易显示
			csA.Format(_T("%s"), _T("Waitting Module Normal"));
			csB.Format(_T(" ."));
			//循环进度条
			for(int j=0; j<30; j++)
			{
				csA += csB;
				this->Show_Status(csA);
				Sleep(s);
			}
		}
		//****************************************************88

		//----------------------- 重启模块 ----------------------- 
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("Send_Stream_Cmd_Reset PASS"));



		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type 2 is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

void CARM_OP_QCM::Show_Progress(double d_Pgr_Percent)
{
	//此函数中应该包含进度条百分比的计算，然后在消息响应函数中完成具体步进点数的计算
	//Progress总长度是1000
	::SendMessage(this->m_hWnd_View, WM_PROGRESS_ENTIRE_MSG, (WPARAM)(d_Pgr_Percent * 1000.0), (LPARAM)this->m_iClass_Idx);
}

void CARM_OP_QCM::Show_Status(const wchar_t * wcp_Status)
{
	::SendMessage(this->m_hWnd_View, WM_STATUS_MSG, (WPARAM)wcp_Status, (LPARAM)this->m_iClass_Idx);
}
void CARM_OP_QCM::Show_COMPORT(const wchar_t * wcp_Status)
{
	::SendMessage(this->m_hWnd_View, WM_COMPORT_MSG, (WPARAM)wcp_Status, (LPARAM)this->m_iClass_Idx);
}

void CARM_OP_QCM::Show_REdit_Info(const wchar_t * wcp_Msg, bool b_RN)
{
	::SendMessage(this->m_hWnd_View, WM_REDIT_INFO_MSG, (WPARAM)wcp_Msg, (LPARAM)b_RN);
}


void CARM_OP_QCM::Show_Status_In_Each(const wchar_t * wcp_Status, const wchar_t * wcp_Title_In_Each)
{
	CString csTemp;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpSrc = NULL;//“源数据”的buff，wcstok在提取数据时会改变源数据内容，所以先把源数据放入buff，解析buff数据，不伤害参数源。
	unsigned long ulBuff_Len = wcslen(wcp_Status) + 8;//用于存放“源数据”的buff长度


	//分配内存
	this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpSrc, ulBuff_Len);


	//载入“源数据”
	swprintf(wcpSrc, _T("%s"), wcp_Status);

	//提取第一个值(0)
	wcpEach = wcstok(wcpSrc, _T("\r\n"));
	//
	while(wcpEach != NULL)
	{
		//显示
		csTemp.Format(_T("%s%s"), wcp_Title_In_Each, wcpEach);
		this->Show_Status(csTemp);
		//this->Save_Trace_Log(csTemp);

		//无延迟，则看不出显示信息的变化
		Sleep(20);

		//提取下一个值
		wcpEach = wcstok(NULL, _T("\r\n"));
	}//while(wcpEach != NULL


	//释放内存
	this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpSrc);
}

bool CARM_OP_QCM::Send_Dmss_Cmd_No_OP(int i_TimeOut)
{
	PKT_BUFF_V2_S str_Pkt_Cmd;
	RSP_INFO_V2_S str_Rsp_Info;

	try
	{
		//打包命令
		//7E 06 4E 95 7E
		str_Pkt_Cmd.ucr_Buff[0] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[1] = 0x06;//CMD_NOP
		str_Pkt_Cmd.ucr_Buff[2] = 0x4E;
		str_Pkt_Cmd.ucr_Buff[3] = 0x95;
		str_Pkt_Cmd.ucr_Buff[4] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[5] = NULL;
		str_Pkt_Cmd.ul_Data_Length = 5;

		//设定预计回复
		//7E 02 6A D3 7E
		str_Rsp_Info.ucr_Expect_Rsp[0] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[1] = 0x02;
		str_Rsp_Info.ucr_Expect_Rsp[2] = 0x6A;
		str_Rsp_Info.ucr_Expect_Rsp[3] = 0xD3;
		str_Rsp_Info.ucr_Expect_Rsp[4] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[5] = NULL;
		str_Rsp_Info.ui_Rsp_Data_Length = 5;
		str_Rsp_Info.ui_Rsp_Pkt_Quan = 1;


		//发送
		if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, i_TimeOut) == false)
		{
			throw(0);
		}


		/*
		//OUT    7e 19 38 7d  5d 7e
		//IN     7e 03 00 06  9e 4c 7e
		str_Pkt_Cmd.ucr_Buff[0] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[1] = 0x19;
		str_Pkt_Cmd.ucr_Buff[2] = 0x38;
		str_Pkt_Cmd.ucr_Buff[3] = 0x7d;
		str_Pkt_Cmd.ucr_Buff[4] = 0x5d;
		str_Pkt_Cmd.ucr_Buff[5] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[6] = NULL;
		str_Pkt_Cmd.ul_Data_Length = 6;

		//设定预计回复
		//7E 02 6A D3 7E
		str_Rsp_Info.ucr_Expect_Rsp[0] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[1] = 0x03;CMD_NAK
		str_Rsp_Info.ucr_Expect_Rsp[2] = 0x00;
		str_Rsp_Info.ucr_Expect_Rsp[3] = 0x06;
		str_Rsp_Info.ucr_Expect_Rsp[4] = 0x9e;
		str_Rsp_Info.ucr_Expect_Rsp[5] = 0x4c;
		str_Rsp_Info.ucr_Expect_Rsp[6] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[7] = NULL;
		str_Rsp_Info.ui_Rsp_Data_Length = 7;
		str_Rsp_Info.ui_Rsp_Pkt_Quan = 1;

		//发送
		if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, i_TimeOut) == false)
		{
			throw(0);
		}
		*/
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Dmss_Cmd_No_OP]");

		return false;
	}

	return true;
}

void CARM_OP_QCM::PKT_DMSS_CMD_NO_OP(PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 10;//定义用于装此命令BUFF的尺寸
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_NOP, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

unsigned short CARM_OP_QCM::Get_CRC_16(const unsigned char * ucp_Data, const int i_Quan, bool b_Escape_Flag)
{
	if(i_Quan <= 0)
	{
		return 0;
	}

	const WORD crc_16_l_table[256] =	//#define CRC_TAB_SIZE    256;		2^CRC_TAB_BITS
	{
		0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
		0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
		0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
		0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
		0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
		0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
		0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
		0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
		0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
		0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
		0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
		0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
		0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
		0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
		0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
		0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
		0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
		0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
		0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
		0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
		0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
		0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
		0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
		0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
		0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
		0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
		0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
		0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
		0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
		0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
		0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
		0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
	};

	int i;
	WORD  w_CRC, w_Temp;

	w_CRC = CRC_16_L_SEED;

	for(i=0; i<i_Quan; i++)
    {
      /* According to the DMSS Download Protocol ICD, the CRC should only
       * be run over the raw data, not the escaped data, so since we
       * escaped the data as we built it, we have to back out any escapes
       * and uncomplement the escaped value back to its original value */
      if((b_Escape_Flag == true) && (*(ucp_Data + i) == ASYNC_HDLC_ESC))
      {
		  i++;//跳过转意字符的头字符（0x7D）

		  //进行“反转意”，对真实数据进行校验计算
		  w_Temp = (((w_CRC) >> 8) ^ crc_16_l_table[((w_CRC) ^ ((WORD)(*(ucp_Data + i) ^ (BYTE)ASYNC_HDLC_ESC_MASK_Q))) & 0x00FF]);
      }
      else
      {
		  w_Temp = (((w_CRC) >> 8) ^ crc_16_l_table[((w_CRC) ^ ((WORD)*(ucp_Data + i))) & 0x00FF]);
      }

	  w_CRC = w_Temp;
    }//for(i=0; i<i_Quan;

    w_CRC ^= CRC_16_L_SEED;

	return w_CRC;
}

void CARM_OP_QCM::Add_Byte_To_Packet(PKT_BUFF_S * strp_Pkt_Cmd, const unsigned char uc_Byte, bool b_Escape_Flag)
{
	if((b_Escape_Flag == true) && ((uc_Byte == ASYNC_HDLC_FLAG) || (uc_Byte == ASYNC_HDLC_ESC)))
	{
		//有Flag字符，需要“转意”操作
		*(strp_Pkt_Cmd->ucp_Buff + strp_Pkt_Cmd->ul_Data_Length) = ASYNC_HDLC_ESC & 0xFF;
		*(strp_Pkt_Cmd->ucp_Buff + strp_Pkt_Cmd->ul_Data_Length + 1) = (uc_Byte ^ (unsigned char)ASYNC_HDLC_ESC_MASK_Q) & 0xFF;

		strp_Pkt_Cmd->ul_Data_Length += 2;
	}
	else
	{
		//不进行“转意”操作
		*(strp_Pkt_Cmd->ucp_Buff + strp_Pkt_Cmd->ul_Data_Length) = uc_Byte & 0xFF;

		strp_Pkt_Cmd->ul_Data_Length++;
	}
}

void CARM_OP_QCM::Load_Packet_FCS_Data(unsigned char * ucp_Data, const int i_Byte_Quan, PKT_BUFF_S * strp_Pkt_Buff)
{
	//把一个Frame的数据中的Packet + FCS载入PKT_BUFF_S，并进行必要的“反转意”
	int i, iPacket_Index;

	if(*(ucp_Data + 0) == ASYNC_HDLC_FLAG)//第一个数据如果是“0x7E”，则是“Frame Header”，就不要载入了
	{
		iPacket_Index = 1;
	}
	else
	{
		iPacket_Index = 0;
	}

	for(i=iPacket_Index; i<i_Byte_Quan; i++)
	{
		if(*(ucp_Data + i) == ASYNC_HDLC_FLAG)//找到“结束Flag 0x7E”，不载入0x7E，载入结束
		{
			return;
		}

		if(*(ucp_Data + i) == ASYNC_HDLC_ESC)//找到“转意关键词 0x7D”，进行反转意
		{
			i++;//跳过转意关键词 0x7D
			//反转意，得到真实数据
			*(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length) = (*(ucp_Data + i) ^ (BYTE)ASYNC_HDLC_ESC_MASK_Q) & 0x00FF;
			strp_Pkt_Buff->ul_Data_Length++;

			continue;
		}

		//普通数据，直接载入
		*(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length) = *(ucp_Data + i) & 0xFF;
		strp_Pkt_Buff->ul_Data_Length++;
	}
}

unsigned short CARM_OP_QCM::Del_FCS_From_Packet(PKT_BUFF_S * strp_Pkt_Buff)
{
	unsigned short usi_CRC_16;

	//计算FCS位上16-bit CRC的值
	usi_CRC_16 = *(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length - 1);//最后一位BYTE是FCS的高8位
	usi_CRC_16 &= 0xFF;
	usi_CRC_16 = usi_CRC_16 << 8;
	usi_CRC_16 |= *(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length - 2) & 0xFF;//最后第二位BYTE是FCS的低8位
	usi_CRC_16 &= 0xFFFF;

	//去掉FCS
	*(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length - 1) = 0x00;
	*(strp_Pkt_Buff->ucp_Buff + strp_Pkt_Buff->ul_Data_Length - 2) = 0x00;
	strp_Pkt_Buff->ul_Data_Length -= 2;

	return usi_CRC_16;
}

void CARM_OP_QCM::PKT_CMD_SWITCH_TO_DLOAD(PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 8;//定义用于装此命令BUFF的尺寸
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_DLOAD_SWITCH, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16(strp_Pkt_Cmd->ucp_Buff, strp_Pkt_Cmd->ul_Data_Length, true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::Switch_To_DL_Mode(int i_TimeOut)
{
	PKT_BUFF_V2_S str_Pkt_Cmd;
	RSP_INFO_V2_S str_Rsp_Info;

	try
	{
		this->Show_Status(_T("Switch to dl mode usb......"));

		//打包命令
		str_Pkt_Cmd.ucr_Buff[0] = 0x3A;
		str_Pkt_Cmd.ucr_Buff[1] = 0xA1;
		str_Pkt_Cmd.ucr_Buff[2] = 0x6E;
		str_Pkt_Cmd.ucr_Buff[3] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[4] = NULL;

		str_Pkt_Cmd.ul_Data_Length = 4;

		//设定预计回复
		str_Rsp_Info.ucr_Expect_Rsp[0] = 0x3A;
		str_Rsp_Info.ucr_Expect_Rsp[1] = 0xA1;
		str_Rsp_Info.ucr_Expect_Rsp[2] = 0x6E;
		str_Rsp_Info.ucr_Expect_Rsp[3] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[4] = NULL;
		str_Rsp_Info.ui_Rsp_Data_Length = 4;
		str_Rsp_Info.ui_Rsp_Pkt_Quan = 1;

		//发送
		if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Switch_To_DL_Mode]");

		return false;
	}

	return true;
}


bool CARM_OP_QCM::DL_Hex_File(const HEX_FILE_S str_Hex_File, unsigned long ul_Pkt_Data_Len)
{
	CString csData;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;

	unsigned long ul_File_Size;				//HEX文件总byte数
	unsigned long ul_Read_Bytes_All = 0;	//该HEX文件已读到的byte数的统计

	DWORD dw_Pkt_Bytes = ul_Pkt_Data_Len;	//定义每次发送的PKT包中“有用数据（不包括地址信息）”的数量

	//每次读取文件的byte数
	DWORD dw_Read_Bytes_Every;

	if(this->m_bLow_Speed_CPU == true)
	{
		dw_Read_Bytes_Every = ul_Pkt_Data_Len * 5;
	}
	else
	{
		if(this->m_iDLOAD_PORT == QCMM_DL_PORT_UART)
		{
			dw_Read_Bytes_Every = ul_Pkt_Data_Len * 10;
		}
		else
		{
			dw_Read_Bytes_Every = ul_Pkt_Data_Len * 15;
		}
	}
	
	//PKT_BUFF_S数据结构BUFF
	PKT_BUFF_S str_Read_Buff;			//每次读取文件的BUFF
	PKT_BUFF_S str_Left_Buff;			//剩余数据的BUFF
	//初始化PKT_BUFF_S
	this->m_cla_GFC.PKT_BUFF_INIT(&str_Read_Buff);
	this->m_cla_GFC.PKT_BUFF_INIT(&str_Left_Buff);

	//HEX_REAL_DATA_S数据结构BUFF
	//用来存放解析后的，有用的HEX数据，便于直接发送
	//初始化HEX_REAL_DATA_S数据结构BUFF
	this->m_str_Real_Hex_Send.w_Base_Addr = 0;
	this->m_str_Real_Hex_Send.w_Offset_Addr = 0;
	this->m_str_Real_Hex_Send.w_Run_Segment_Addr = 0;
	this->m_str_Real_Hex_Send.w_Run_Offset_Addr = 0;
	this->m_str_Real_Hex_Send.b_Base_Addr = false;
	this->m_str_Real_Hex_Send.b_Offset_Addr = false;
	this->m_str_Real_Hex_Send.b_Run_Flag = false;
	this->m_str_Real_Hex_Send.b_End_Flag = false;
	this->m_str_Real_Hex_Send.str_Actual_Data.b_Read_Finish = false;
	this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Real_Hex_Send.str_Actual_Data.str_Data);
	this->m_str_Real_Hex_Send.str_Actual_Data.dw_Pkt_Addr = 0;
	
	try
	{
		this->Show_Out(str_Hex_File.cs_Path);

		//打开HEX文件
		hFile_Handle = ::CreateFile(str_Hex_File.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Open %s.hex file failed!"), str_Hex_File.cs_Name);
			throw(0);
		}

		//获取HEX文件的BYTE数（HEX文件Size）
		ul_File_Size = ::GetFileSize(hFile_Handle, NULL);

		//清空待分配的内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Read_Buff);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Real_Hex_Send.str_Actual_Data.str_Data);
		//分配内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&str_Read_Buff, (dw_Read_Bytes_Every + 8));
		this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Real_Hex_Send.str_Actual_Data.str_Data, (dw_Read_Bytes_Every + 8));

		//开始读、下载，HEX文件
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//清空每次使用的Read Buff
			memset(str_Read_Buff.ucp_Buff, 0, str_Read_Buff.ul_Total_Size);
			str_Read_Buff.ul_Data_Length = 0;

			//检查文件是否读完
			if(this->m_str_Real_Hex_Send.str_Actual_Data.b_Read_Finish == false)//文件未读完
			{
				//读文件
				if(::ReadFile(hFile_Handle, str_Read_Buff.ucp_Buff, dw_Read_Bytes_Every, &str_Read_Buff.ul_Data_Length, NULL) != TRUE)
				{
					this->m_csError_Code.Format(_T("FAIL, Read hex file failed!"));
					throw(0);
				}

				//统计已读到的数据
				ul_Read_Bytes_All += str_Read_Buff.ul_Data_Length;

				//界面显示下载百分比
				csData.Format(_T("Download %s ( %d / %d ) ...... %.1f%%"), str_Hex_File.cs_Name,
					ul_Read_Bytes_All, ul_File_Size, (100.0 * ul_Read_Bytes_All / ul_File_Size));
				this->Show_Status(csData);

				//显示进度条
				this->m_ul_Transmit_Bytes += str_Read_Buff.ul_Data_Length;
				this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));//DL_Hex

				//文件的最后是没有“:”的，此标识代表文件读取结束
				if(ul_Read_Bytes_All == ul_File_Size)//“已读出的总数”等于“文件实际大小”
				{
					this->m_str_Real_Hex_Send.str_Actual_Data.b_Read_Finish = true;
				}
			}//if(this->m_str_Real_Hex_Send.str_Actual_Data.b_Read_Finish == false

			//检查文件是否解析完
			if(this->m_str_Real_Hex_Send.b_End_Flag == false)//文件未解析结束
			{
				//解析、转换读取的数据，解析不完的，放入“剩余BUFF”（若文件读取结束，函数则解析完全部参数）
				if(this->Extract_Hex_Data(&str_Read_Buff, &str_Left_Buff, &this->m_str_Real_Hex_Send) != RTN_SUCCESS)
				{
					throw(0);
				}
			}


			//发送HEX_REAL_DATA_S中解析得的有用数据
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
				{
					if(this->Send_Hex_Pkt_Data_V1(&this->m_str_Real_Hex_Send, dw_Pkt_Bytes) == false)
					{
						throw(0);
					}
				}
				break;
			case MDM9X15:
				{
					if(this->Send_Hex_Pkt_Data_V2(&this->m_str_Real_Hex_Send, dw_Pkt_Bytes) == false)
					{
						throw(0);
					}
				}
				break;
			default:
				throw(0);
			}
		}
		while((this->m_str_Real_Hex_Send.str_Actual_Data.str_Data.ul_Data_Length > 0) ||
			(this->m_str_Real_Hex_Send.b_End_Flag == false) ||
			(this->m_str_Real_Hex_Send.str_Actual_Data.b_Read_Finish == false));//“待发送的数据”必须全部发完；同时程序已经读到了HEX文件的“结束符”；文件已读完；才会结束循环

		//关闭HEX文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}


		//
		Sleep(100);



		//发送运行HEX文件的指令
		if(this->m_str_Real_Hex_Send.b_Run_Flag == true)
		{
			if(this->Send_Dmss_Cmd_Go(this->m_str_Real_Hex_Send.w_Run_Segment_Addr, this->m_str_Real_Hex_Send.w_Run_Offset_Addr) == false)
			{
				throw(0);
			}
		}
		else
		{
			this->m_csError_Code.Format(_T("FAIL, Hex file does not have run address!"));
			throw(0);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Read_Buff);
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Left_Buff);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Real_Hex_Send.str_Actual_Data.str_Data);
	}
	catch(...)
	{
		//关闭HEX文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Read_Buff);
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Left_Buff);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Real_Hex_Send.str_Actual_Data.str_Data);

		return false;
	}

	return true;
}

int CARM_OP_QCM::Extract_Hex_Data(PKT_BUFF_S * strp_Input_Data, PKT_BUFF_S * strp_Left_Data, HEX_REAL_DATA_S * strp_Hex_Real_Data)
{
	//该函数解析HEX数据，指导下一步操作
	PKT_BUFF_S str_Temp_Buff;
	DWORD dwTemp;
	int i, iHead, iEnd, iRec_Quan, iRtn;

	//
	this->m_cla_GFC.PKT_BUFF_INIT(&str_Temp_Buff);

	try
	{
		//-------------------------------- 把“新入数据”和“剩余数据”合并载入“临时数据BUFF”来解析 -------------------------------- 
		//检查是否有剩余数据
		if(strp_Left_Data->ucp_Buff != NULL)//“剩余数据BUFF”中有数据，需要提取使用
		{
			dwTemp = strp_Left_Data->ul_Data_Length + strp_Input_Data->ul_Data_Length;

			//分配临时BUFF
			this->m_cla_GFC.PKT_BUFF_CALLOC(&str_Temp_Buff, (dwTemp + 8));

			//向Temp Buff赋值
			if(this->m_cla_GFC.PKT_BUFF_ADD_DATA(&str_Temp_Buff, strp_Left_Data->ucp_Buff, strp_Left_Data->ul_Data_Length) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Extract_Hex_Data, Add byte 1 error!"));
				throw(RTN_ERROR);
			}

			//释放“剩余数据BUFF”
			this->m_cla_GFC.PKT_BUFF_FREE(strp_Left_Data);
		}
		else//无剩余数据
		{
			//分配临时BUFF
			this->m_cla_GFC.PKT_BUFF_CALLOC(&str_Temp_Buff, (strp_Input_Data->ul_Data_Length + 8));
		}

		//把“新入数据”载入Temp Buff
		if(this->m_cla_GFC.PKT_BUFF_ADD_DATA(&str_Temp_Buff, strp_Input_Data->ucp_Buff, strp_Input_Data->ul_Data_Length) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Extract_Hex_Data, Add byte 2 error!"));
			throw(RTN_ERROR);
		}

		//-------------------------------- 解析临时BUFF数据 -------------------------------- 
		iHead = -1;
		iEnd = -1;

		for(i=0; i<str_Temp_Buff.ul_Data_Length; i++)
		{
			if((char)*(str_Temp_Buff.ucp_Buff + i) == ':')
			{
				if(iHead < 0)
				{
					iHead = i;//找到第一个“:”
				}
				else//已有第一个“:”
				{
					//找到了第二个“:”
					iEnd = i;

					//计算这段RECORD的BYTE长度
					iRec_Quan = iEnd - iHead;

					//解析、判定每个RECORD
					iRtn = this->Extract_Hex_Record_Data((str_Temp_Buff.ucp_Buff + iHead), iRec_Quan, strp_Hex_Real_Data);

					switch(iRtn)
					{
					case HEX_ETR_SUCCESS:
						{
							iHead = iEnd;//继续找下个“:”
							continue;
						}
					case HEX_ETR_DATA_WRONG://数据已经错误，退出此次下载，临时BUFF里的数据丢弃
						{
							throw(RTN_ERROR);
						}
					case HEX_ETR_BUFF_FULL://“有用数据BUFF”满了，暂不添加，临时BUFF里的数据放入“剩余BUFF”
						{
							//分配剩余BUFF的空间
							this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Left_Data, (str_Temp_Buff.ul_Data_Length - iHead + 8));

							//只放入此次循环找到的“:”开始以后的数据，之前的数据已解析，可丢弃
							if(this->m_cla_GFC.PKT_BUFF_ADD_DATA(strp_Left_Data, (str_Temp_Buff.ucp_Buff + iHead), (str_Temp_Buff.ul_Data_Length - iHead)) == false)
							{
								this->m_csError_Code.Format(_T("FAIL, Extract_Hex_Data, Add byte 3 error!"));
								throw(RTN_ERROR);
							}

							throw(RTN_SUCCESS);//返回成功
						}
					case HEX_ETR_CSUM_ERR://校验位数据已经错误，退出此次下载，临时BUFF里的数据丢弃
						{
							throw(RTN_FAIL);
						}
					case HEX_ETR_END_FLAG://文件数据结束，返回成功
						{
							throw(RTN_SUCCESS);
						}
					default:
						break;
					}
				}//else//已有第一个“:”
			}//if((char)*(str_Temp_Buff.ucp_Buff + i) == ':'
		}//for(i=0; i<str_Temp_Buff.ul_Data_Length;


		//检查最后的数据是否需要解析（若文件已读完，则必须解析最后的数据）
		if((strp_Hex_Real_Data->str_Actual_Data.b_Read_Finish == true) && (iHead >= 0))
		{
			//文件已读完
			//计算这段RECORD的BYTE长度
			iRec_Quan = str_Temp_Buff.ul_Data_Length - iHead;

			//解析、判定每个RECORD
			iRtn = this->Extract_Hex_Record_Data((str_Temp_Buff.ucp_Buff + iHead), iRec_Quan, strp_Hex_Real_Data);

			switch(iRtn)
			{
			case HEX_ETR_SUCCESS://成功解析
				{
					break;
				}
			case HEX_ETR_DATA_WRONG://数据已经错误，退出此次下载，临时BUFF里的数据丢弃
				{
					throw(RTN_ERROR);
				}
			case HEX_ETR_BUFF_FULL://“有用数据BUFF”满了，暂不添加，临时BUFF里的数据放入“剩余BUFF”
				{
					//分配剩余BUFF的空间
					this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Left_Data, (str_Temp_Buff.ul_Data_Length - iHead + 8));

					//只放入此次循环找到的“:”开始以后的数据，之前的数据已解析，可丢弃
					if(this->m_cla_GFC.PKT_BUFF_ADD_DATA(strp_Left_Data, (str_Temp_Buff.ucp_Buff + iHead), (str_Temp_Buff.ul_Data_Length - iHead)) == false)
					{
						this->m_csError_Code.Format(_T("FAIL, Extract_Hex_Data, Add byte 4 error!"));
						throw(RTN_ERROR);
					}

					break;//返回成功
				}
			case HEX_ETR_CSUM_ERR://校验位数据已经错误，退出此次下载，临时BUFF里的数据丢弃
				{
					throw(RTN_FAIL);
				}
			case HEX_ETR_END_FLAG://文件数据结束，返回成功
				{
					throw(RTN_SUCCESS);
				}
			default:
				break;
			}
		}
		else
		{
			//文件还没有读完
			//检查有多少“临时BUFF”里的数据放入“剩余BUFF”
			if(iHead >= 0)
			{
				//只要备份“iHead”以后的数据到“剩余BUFF”
			}
			else
			{
				//没有找到任何“:”，所以全部备份到“剩余BUFF”
				iHead = 0;
			}

			//分配剩余BUFF的空间
			this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Left_Data, (str_Temp_Buff.ul_Data_Length - iHead + 8));

			//只放入此次循环找到的“:”开始以后的数据，之前的数据已解析，可丢弃
			if(this->m_cla_GFC.PKT_BUFF_ADD_DATA(strp_Left_Data, (str_Temp_Buff.ucp_Buff + iHead), (str_Temp_Buff.ul_Data_Length - iHead)) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Extract_Hex_Data, Add byte 5 error!"));
				throw(RTN_ERROR);
			}
		}
	}
	catch(int iError)
	{
		//释放临时BUFF
		this->m_cla_GFC.PKT_BUFF_FREE(&str_Temp_Buff);

		return iError;
	}

	//释放临时BUFF
	this->m_cla_GFC.PKT_BUFF_FREE(&str_Temp_Buff);

	return RTN_SUCCESS;
}

DWORD CARM_OP_QCM::HexChar_To_Int(const unsigned char * ucp_Hex_Char, int i_Byte_Quan)
{
	char * cpData = NULL;
	char * d;
	int i, j;
	DWORD dwRtn;

	//分配内存
	j = i_Byte_Quan + 3;
	cpData = (char *)calloc(j, sizeof(char));

	*(cpData + 0) = '0';
	*(cpData + 1) = 'X';

	for(i=0; i<i_Byte_Quan; i++)
	{
		*(cpData + 2 + i) = (char)*(ucp_Hex_Char + i);
	}

	*(cpData + 2 + i) = '\0';

	dwRtn = strtoul(cpData, &d, 16);

	//释放内存
	free(cpData);

	return dwRtn;
}

int CARM_OP_QCM::Extract_Hex_Record_Data(const unsigned char * ucp_Hex_Record, int i_Rec_Byte_Quan, HEX_REAL_DATA_S * strp_Real_Data)
{
	int i;

	//获取“记录类型”
	int iRec_Type = this->HexChar_To_Int((ucp_Hex_Record + HEX_TYPE), 2);
	int iRec_Len = this->HexChar_To_Int((ucp_Hex_Record + HEX_LEN), 2);

	//检查其有效数据数目
	for(i=0; i<i_Rec_Byte_Quan; i++)
	{
		if(!
			((*(ucp_Hex_Record + i) == ':') ||
			((*(ucp_Hex_Record + i) >= '0') && (*(ucp_Hex_Record + i) <= '9')) ||
			((*(ucp_Hex_Record + i) >= 'A') && (*(ucp_Hex_Record + i) <= 'Z')) ||
			((*(ucp_Hex_Record + i) >= 'a') && (*(ucp_Hex_Record + i) <= 'z')))
			)
		{
			break;//找到无效字符就跳出，前面的数据全是有效HEX字符（后面的\r\n丢弃）
		}
	}//for(i=0; i<i_Rec_Byte_Quan;
	//计算有效字符数目
	if(i >= i_Rec_Byte_Quan)
	{
		i = i_Rec_Byte_Quan;
	}
	//判定有效字符数目是否正确
	if(i != (iRec_Len * 2 + 11))//有效字符数目最小是“11”
	{
		this->m_csError_Code.Format(_T("FAIL, The length of hex record is wrong! ( %d / %d / %d )"), i, (iRec_Len * 2 + 11), i_Rec_Byte_Quan);
		return HEX_ETR_DATA_WRONG;
	}

	//根据“记录类型”不同处理
	if(iRec_Type == 0)//00，数据记录
	{
		//偏移地址载入 
		if(strp_Real_Data->b_Offset_Addr == false)//如果还没有“偏移地址”，便载入
		{
			//偏移地址
			strp_Real_Data->w_Offset_Addr = this->HexChar_To_Int((ucp_Hex_Record + HEX_OFFSET), 4) & 0xFFFF;
			strp_Real_Data->b_Offset_Addr = true;

			//计算打包的起始地址（有了第一个偏移地址，就能打包下载包的起始地址了）
			strp_Real_Data->str_Actual_Data.dw_Pkt_Addr = strp_Real_Data->w_Base_Addr & 0xFFFF;//基地址是高16位
			strp_Real_Data->str_Actual_Data.dw_Pkt_Addr = strp_Real_Data->str_Actual_Data.dw_Pkt_Addr << 16;
			strp_Real_Data->str_Actual_Data.dw_Pkt_Addr |= strp_Real_Data->w_Offset_Addr & 0xFFFF;//偏移地址是低16位
			strp_Real_Data->str_Actual_Data.dw_Pkt_Addr &= 0xFFFFFFFF;
		}

		//数据载入
		if((strp_Real_Data->str_Actual_Data.str_Data.ul_Data_Length + iRec_Len) >= strp_Real_Data->str_Actual_Data.str_Data.ul_Total_Size)
		{
			//数据库快满了，不能装了
			this->m_csError_Code.Format(_T("WARNING, The buffer of real hex record is full!"));
			return HEX_ETR_BUFF_FULL;
		}
		else
		{
			//数据库能装的下，就载入数据
			for(i=0; i<iRec_Len; i++)
			{
				*(strp_Real_Data->str_Actual_Data.str_Data.ucp_Buff + strp_Real_Data->str_Actual_Data.str_Data.ul_Data_Length + i) =
					0xFF & this->HexChar_To_Int((ucp_Hex_Record + HEX_DATA + i * 2), 2);
			}

			strp_Real_Data->str_Actual_Data.str_Data.ul_Data_Length += iRec_Len;
		}
	}
	else if(iRec_Type == 4)//04，线性地址记录
	{
		if(strp_Real_Data->b_Base_Addr == false)//如果还没有“基地址”，便载入
		{
			strp_Real_Data->w_Base_Addr = this->HexChar_To_Int((ucp_Hex_Record + HEX_DATA), 4) & 0xFFFF;

			strp_Real_Data->b_Base_Addr = true;
		}
	}
	else if(iRec_Type == 5)//05，Start Linear Address Record
	{
		strp_Real_Data->b_Run_Flag = true;
		strp_Real_Data->w_Run_Segment_Addr = this->HexChar_To_Int((ucp_Hex_Record + HEX_DATA), 4) & 0xFFFF;
		strp_Real_Data->w_Run_Offset_Addr = this->HexChar_To_Int((ucp_Hex_Record + HEX_DATA + 4), 4) & 0xFFFF;
	}
	else if(iRec_Type == 1)//01，HEX文件结束
	{
		//解析HEX文件也就结束了
		strp_Real_Data->b_End_Flag = true;
		return HEX_ETR_END_FLAG;
	}

	return HEX_ETR_SUCCESS;
}

bool CARM_OP_QCM::Send_Hex_Pkt_Data_V1(HEX_REAL_DATA_S * strp_Hex_Real_Data, const int i_Pkt_Length)
{
	if(strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length <= 0)
	{
		this->m_csError_Code.Format(_T("FAIL, Hex buff is empty! [Send_Hex_Pkt_Data_V1]"));
		return false;
	}

	int iTimeOut = 3;//发射完全部数据后，读其数据包确认回复的总超时时间
	int iCnt = 2;//单句发送的循环超时次数
	RSP_INFO_V2_S str_Rsp_Info_V2;
	unsigned char * ucpRx_Buff= NULL;
	unsigned long ulRx_Quan = 0;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();

		//设定预计回复
		//设定预计回复，CMD_ACK
		//7E 02 6A D3 7E
		str_Rsp_Info_V2.ucr_Expect_Rsp[0] = 0x7E;
		str_Rsp_Info_V2.ucr_Expect_Rsp[1] = 0x02;
		str_Rsp_Info_V2.ucr_Expect_Rsp[2] = 0x6A;
		str_Rsp_Info_V2.ucr_Expect_Rsp[3] = 0xD3;
		str_Rsp_Info_V2.ucr_Expect_Rsp[4] = 0x7E;
		str_Rsp_Info_V2.ucr_Expect_Rsp[5] = NULL;
		str_Rsp_Info_V2.ui_Rsp_Data_Length = 5;
		str_Rsp_Info_V2.ui_Rsp_Pkt_Quan = 0;

		//循环打包发送，BUFF中待发数据循环
		while(
			(strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length >= i_Pkt_Length) ||
			((strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length > 0) && (strp_Hex_Real_Data->b_End_Flag == true))
			)
		{
			//HEX_REAL_DATA_S中有够一次“打包PKT量”数据时；或者已有“End_Flag”；便允许打包发送数据

			//打包一条命令
			if(this->PKT_DMSS_CMD_WRITE_32BIT(&this->m_str_Pkt_Send, strp_Hex_Real_Data, i_Pkt_Length) == false)
			{
				//打包数据出错，便终止此次下载
				throw(0);
			}

			//单句发送循环
			while(iCnt > 0)
			{
				if(this->m_iStop_Flag > 0)
				{
					this->m_csError_Code.Format(_T("Operation has been stopped!"));
					throw(0);
				}

				//发送指令
				if(this->WRITE_BYTE((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
				{
					if(this->m_bLow_Speed_CPU == true)
					{
						Sleep(50);
					}

					//检测一下，看是否会有回复值
					this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);

					str_Rsp_Info_V2.ui_Rsp_Pkt_Quan++;
					break;//单句发送成功
				}
				else
				{
					Sleep(500);
//					::AfxMessageBox(_T("FAIL, Write hex byte!"));
				}

				if((--iCnt) <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Read hex rsp timeout, %s"), this->GET_COM_PORT_ERROR_INFO());
					throw(0);
				}
			}//while(iCnt > 0

		}//while((strp_Hex_Real_Data->str_Actual_Data.ul_Data_Length >= i_Pkt_Length) || (strp_Hex_Real_Data->b_End_Flag)

		//等待、读取、提取、检查应答，返回Frame中Packet部分数据
		if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, iTimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Hex_Pkt_Data_V1]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::PKT_DMSS_CMD_WRITE_32BIT(PKT_BUFF_S * strp_Pkt_Cmd, HEX_REAL_DATA_S * strp_Hex_Real_Data, const int i_Pkt_Length)
{
	unsigned short usiCRC16;
	WORD w_Actual_Bytes;//实际会发送的“有用数据”数量
	int i;

	if(strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length >= i_Pkt_Length)
	{
		//BUFF中“有用数据”数量足够一次规定数量BYTE的打包
		w_Actual_Bytes = i_Pkt_Length;
	}
	else
	{
		//BUFF中“有用数据”数量不够一次规定数量BYTE的打包，就把剩余数据全部打包发送
		w_Actual_Bytes = strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length;
	}

	int iBuff_Size = (11 + w_Actual_Bytes) * 1.5;//根据打包数据的数量，计算需用BUFF的大小（中间可能有需要转意的数据，BUFF就多留些）

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配PKT_CMD内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_WRITE_32BIT, true);
	//Address（4 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Hex_Real_Data->str_Actual_Data.dw_Pkt_Addr >> 24) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Hex_Real_Data->str_Actual_Data.dw_Pkt_Addr >> 16) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Hex_Real_Data->str_Actual_Data.dw_Pkt_Addr >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (strp_Hex_Real_Data->str_Actual_Data.dw_Pkt_Addr & 0xFF), true);
	//Length（2 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((w_Actual_Bytes >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (w_Actual_Bytes & 0xFF), true);
	//Data（每个数据占一个Byte）
	for(i=0; i<w_Actual_Bytes; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, *(strp_Hex_Real_Data->str_Actual_Data.str_Data.ucp_Buff + i), true);
	}

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);

	//检查BUFF是否溢出
	if(strp_Pkt_Cmd->ul_Data_Length <= strp_Pkt_Cmd->ul_Total_Size)//无溢出
	{
		//删除BUFF中的已经打包掉的数据
		this->m_cla_GFC.PKT_BUFF_DEL_DATA(&strp_Hex_Real_Data->str_Actual_Data.str_Data, w_Actual_Bytes);
		//打包地址走张（刷新下个包的打包地址参数）
		strp_Hex_Real_Data->str_Actual_Data.dw_Pkt_Addr += w_Actual_Bytes;

		return true;
	}
	else//BUFF溢出
	{
		//释放掉出问题的内存
		this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

		this->m_csError_Code.Format(_T("FAIL, The length of dmss write 32bit pkt data is bigger than buff size!"));

		return false;
	}
}

void CARM_OP_QCM::PKT_DMSS_CMD_GO(PKT_BUFF_S * strp_Pkt_Cmd, const WORD w_Segment_Addr, const WORD w_Offset_Addr)
{
	int iBuff_Size = 18;//定义用于装此命令BUFF的尺寸
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_GO, true);
	//Code segment address（2 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((w_Segment_Addr >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (w_Segment_Addr & 0xFF), true);
	//Code offset address（2 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((w_Offset_Addr >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (w_Offset_Addr & 0xFF), true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::Send_Dmss_Cmd_Go(const WORD w_Segment_Addr, const WORD w_Offset_Addr)
{
	int iTimeOut = 2;
	int i, j;
	unsigned long ulIndex;
	bool bGet_Rsp_Pass = false;
	unsigned char ucrTgt_Key[] = {0x7e, 0x02};//7e 02 6a d3 7e


	try
	{
		//打包命令
		this->PKT_DMSS_CMD_GO(&this->m_str_Pkt_Send, w_Segment_Addr, w_Offset_Addr);//7e 05 00 80 00 00 cf e5 7e


		for(j=0; j<2; j++)
		{
			//清空接收BUFF
			this->Clear_Com_Rx_Buffer();


			//发送指令
			if(this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
			{
				for(i=0; i<2; i++)//多次读取是为了防止“回报数据的最初部分有无用数据”
				{
					//只需读2个byte，存入 rx buff 中
					if(this->m_cla_Com_Port.Read_Byte_Sync_V2(2, iTimeOut) == true)
					{
						//在 rx_buff 中核对（7e 02 6a d3 7e）
						if(this->m_cla_GFC.mem_uc_str(
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff,
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length,
							ucrTgt_Key, 2, &ulIndex) == true)
						{
							bGet_Rsp_Pass = true;
							break;//for
						}
					}
				}//for(i=0; i<3; i++
			}//write成功


			//判断提取数据的结果
			if(bGet_Rsp_Pass == true)
			{
				break;//for
			}
		}//for(j=0; j<2; j++
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Dmss_Cmd_Go]");

		return false;
	}

	return bGet_Rsp_Pass;


	/*
	int i_TimeOut = 4;//发射数据包的超时时间
	RSP_INFO_V2_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_DMSS_CMD_GO(&this->m_str_Pkt_Send, w_Segment_Addr, w_Offset_Addr);

		//设定预计回复，CMD_ACK
		//7E 02 6A D3 7E
		str_Rsp_Info.ucr_Expect_Rsp[0] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[1] = 0x02;
		str_Rsp_Info.ucr_Expect_Rsp[2] = 0x6A;
		str_Rsp_Info.ucr_Expect_Rsp[3] = 0xD3;
		str_Rsp_Info.ucr_Expect_Rsp[4] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[5] = NULL;
		str_Rsp_Info.ui_Rsp_Data_Length = 5;
		str_Rsp_Info.ui_Rsp_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V2(this->m_str_Pkt_Send, str_Rsp_Info, i_TimeOut) == false)
		{
			throw(0);
		}
		
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Dmss_Cmd_Go]");

		return false;
	}

	return true;
	*/
}

void CARM_OP_QCM::Debug_Show_Byte_Data(const unsigned char * ucp_Data, const int i_Quan)
{
	CString csData, csTemp;

	csData.Format(_T(""));

	for(int i=0; i<i_Quan; i++)
	{
		csTemp.Format(_T("%02X "), *(ucp_Data + i));

		if(((i + 1) % 16) == 0)
		{
			csTemp += _T("\r\n");
		}

		csData += csTemp;
	}

	::AfxMessageBox(csData);
}

void CARM_OP_QCM::Debug_Show_DWord_Data(DWORD dw_Data)
{
	CString csData;

	csData.Format(_T("0x: %02X %02X %02X %02X"),
		((dw_Data >> 24) & 0xFF), ((dw_Data >> 16) & 0xFF), ((dw_Data >> 8) & 0xFF), (dw_Data& 0xFF));

	::AfxMessageBox(csData);
}

void CARM_OP_QCM::PKT_STREAM_CMD_HELLO(PKT_BUFF_S * strp_Pkt_Cmd, unsigned int ui_Version)
{
	int iBuff_Size = 50;//定义用于装此命令BUFF的尺寸（正常为40个字符）
	unsigned short usiCRC16;
	char crProtocol_Magic[] = "QCOM fast download protocol host";//正好32个字符

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_HELLO_REQ, true);

	//数据部分载入
	//Magic number (“QCOM fast download protocol host”)
	for(int i=0; i<32; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((unsigned char)crProtocol_Magic[i] & 0xFF), true);
	}

	if(ui_Version == 0x02)
	{
		//Version number
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x02, true);
		//Compatible version
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x02, true);
		//Feature bits
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x01, true);
	}
	else if(ui_Version == 0x03)
	{
		//Version number
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x03, true);
		//Compatible version
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x03, true);
		//Feature bits
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x09, true);
	}

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

void CARM_OP_QCM::PKT_STREAM_CMD_CLOSE(PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 10;//定义用于装此命令BUFF的尺寸（正常为5个字符）
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_CLOSE, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

void CARM_OP_QCM::PKT_STREAM_CMD_SECURITY_MODE(PKT_BUFF_S * strp_Pkt_Cmd, const unsigned int ui_Security_Mode)
{
	int iBuff_Size = 10;//定义用于装此命令BUFF的尺寸（正常为6个字符）
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_SECURITY_MODE_REQ, true);

	//数据部分载入
	//Security mode(0x0 – Nontrusted; 0x1 – Trusted)
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (ui_Security_Mode & 0xFF), true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::PKT_STREAM_CMD_PARTITION_TABLE(PKT_BUFF_S * strp_Pkt_Cmd, const PKT_BUFF_S str_Partition_Table, unsigned int ui_Override)
{
	int iBuff_Size = (5 + str_Partition_Table.ul_Data_Length) * 1.5;//定义用于装此命令BUFF的尺寸
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_PARTITION_TABLE_REQ, true);

	//Override控制
	//当PARTITION结构不同，需要更新时，这个值就设定“0x1”擦除旧的；产品一般稳定后，无需擦除
	//Override existing table parameter ( 0x0 – No override; 0x1 – Override existing table )
//	this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x00, true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (ui_Override & 0xFF), true);

	//Partition table数据
	for(int i=0; i<str_Partition_Table.ul_Data_Length; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, *(str_Partition_Table.ucp_Buff + i), true);
	}

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);

	//检查BUFF是否溢出
	if(strp_Pkt_Cmd->ul_Data_Length <= strp_Pkt_Cmd->ul_Total_Size)//无溢出
	{
		return true;
	}
	else//BUFF溢出
	{
		//释放掉出问题的内存
		this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

		this->m_csError_Code.Format(_T("FAIL, The length of partition pkt data is bigger than buff size!"));

		return false;
	}
}

void CARM_OP_QCM::PKT_STREAM_CMD_OPEN_MULTI_IMAGE(PKT_BUFF_S * strp_Pkt_Cmd, const unsigned int ui_Open_Image_Type)
{
	int iBuff_Size = 12;//定义用于装此命令BUFF的尺寸（正常为6个字符）
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_OPEN_MULTI_IMAGE, true);

	//数据部分载入
	//Which Image mode to open in
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (ui_Open_Image_Type & 0xFF), true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::PKT_STREAM_CMD_STREAM_WRITE_V1(PKT_BUFF_S * strp_Pkt_Cmd, PKT_DATA_ADDR_BUFF_S * strp_Data_Addr, const int i_Pkt_Length)
{
	unsigned short usiCRC16;
	WORD w_Actual_Bytes;//实际会发送的“有用数据”数量
	int i;

	if(strp_Data_Addr->str_Data.ul_Data_Length >= i_Pkt_Length)
	{
		//BUFF中“有用数据”数量足够一次规定数量BYTE的打包
		w_Actual_Bytes = i_Pkt_Length;
	}
	else
	{
		//BUFF中“有用数据”数量不够一次规定数量BYTE的打包，就把剩余数据全部打包发送
		w_Actual_Bytes = strp_Data_Addr->str_Data.ul_Data_Length;
	}



	//计算所需的BUFF尺寸
	int iBuff_Size = (9 + w_Actual_Bytes) * 1.5;//根据打包数据的数量，计算需用BUFF的大小（中间可能有需要转意的数据，BUFF就多留些）


	//检测“内存空间BUFF”是否够大
	if( strp_Pkt_Cmd->ul_Total_Size >= iBuff_Size )
	{
		//本身内存空间足够大，就不重新分配，只需清空

		//清空旧数据
		strp_Pkt_Cmd->ul_Data_Length = 0;
	}
	else
	{
		//内存空间BUFF不足，需要重新分配内存

		//先释放内存
		this->m_cla_GFC.PKT_BUFF_FREE( strp_Pkt_Cmd );

	//分配PKT_CMD内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);
	}



	//组建命令部分
	//Frame头，不转意（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_STREAM_WRITE, true);
	//Address（4 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (strp_Data_Addr->dw_Pkt_Addr & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 16) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 24) & 0xFF), true);
	
	//Data（每个数据占一个Byte）
	for(i=0; i<w_Actual_Bytes; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, *(strp_Data_Addr->str_Data.ucp_Buff + i), true);
	}

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);

	//检查BUFF是否溢出
	if(strp_Pkt_Cmd->ul_Data_Length <= strp_Pkt_Cmd->ul_Total_Size)//无溢出
	{
		//删除BUFF中的已经打包掉的数据
		this->m_cla_GFC.PKT_BUFF_DEL_DATA(&strp_Data_Addr->str_Data, w_Actual_Bytes);
		//打包地址走张（刷新下个包的打包地址参数）
		strp_Data_Addr->dw_Pkt_Addr += w_Actual_Bytes;

		return true;
	}
	else//BUFF溢出
	{
		//释放出问题的内存
		this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

		this->m_csError_Code.Format(_T("FAIL, The length of stream write pkt data is bigger than buff size!"));

		return false;
	}
}

bool CARM_OP_QCM::PKT_STREAM_CMD_STREAM_WRITE_V2(PKT_BUFF_S * strp_Pkt_Cmd, PKT_DATA_ADDR_BUFF_S * strp_Data_Addr)
{
	//不“动态释放+分配指令buff内存”
	//单次打包、发送buff中全部数据

	unsigned short usiCRC16;
	int i;


	//清空旧数据
	strp_Pkt_Cmd->ul_Data_Length = 0;


	//组建命令部分
	//Frame头，不转意（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID（1 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_STREAM_WRITE, true);
	//Address（4 Bytes）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (strp_Data_Addr->dw_Pkt_Addr & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 8) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 16) & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((strp_Data_Addr->dw_Pkt_Addr >> 24) & 0xFF), true);
	
	//Data（每个数据占一个Byte）
	for(i=0; i<strp_Data_Addr->str_Data.ul_Data_Length; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, *(strp_Data_Addr->str_Data.ucp_Buff + i), true);
	}

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);


	//更新地址数据（刷新下个包的打包地址参数）
	strp_Data_Addr->dw_Pkt_Addr += strp_Data_Addr->str_Data.ul_Data_Length;


	return true;
}

void CARM_OP_QCM::PKT_STREAM_CMD_RESET(PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 10;//定义用于装此命令BUFF的尺寸（正常为5个字符）
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_RESET_REQ, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::Send_Stream_Cmd_Hello(int i_TimeOut, unsigned int ui_Version, unsigned long * ulp_Max_Block_Size)
{
	//发送Hello packet，读STREAM HW信息，Hello response packet

	RSP_INFO_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_HELLO(&this->m_str_Pkt_Send, ui_Version);

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_HELLO_ACK;
		str_Rsp_Info.ui_Pkt_Valid_Len = 52;//一般是575，但实际情况差异很大
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}

		//提取Hello返回的HW信息数据
		if(this->Get_Streaming_Info(this->m_str_Pkt_Read, ulp_Max_Block_Size) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Hello]");
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Close(int i_TimeOut)
{
	RSP_INFO_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_CLOSE(&this->m_str_Pkt_Send);//7E 15 54 B7 7E

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_CLOSED;//7E 16 CF 85 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 3;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Close]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Open_Multi_Image(unsigned int ui_Open_Image_Type)
{
	int i_TimeOut = 4;
	RSP_INFO_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_OPEN_MULTI_IMAGE(&this->m_str_Pkt_Send, ui_Open_Image_Type);//7E 1B 11 76 7F 7E

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_OPENED_MULTI_IMAGE;//7E 1C 00 76 33 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 4;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Open_Multi_Image]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Security_Mode(unsigned int ui_Security_Mode)
{
	int i_TimeOut = 4;
	RSP_INFO_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_SECURITY_MODE(&this->m_str_Pkt_Send, ui_Security_Mode);//7E 17 01 57 C6 7E

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_SECURITY_MODE_RSP;//7E 18 B1 6C 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 3;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Security_Mode]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Partition_Table(const PKT_BUFF_S str_Partition_Table, unsigned int ui_Override)
{
	//发送 partition 数据包
	//回复7E 1A 00 A6 67 7E
	//0x00 – Partition table accepted; 0x01 – Partition table differs, override is accepted;

	time_t t_Start, t_End;
	int iTimeOut = 10;//发射完全部数据后，读其数据包确认回复的总超时时间
	int i;
	bool bGet_Rsp_Pass = false;
	unsigned char ucrTgt_Key[] = {0x7E, 0x1A};//回复的指令头
	unsigned long ulIndex;


	try
	{
		//打包一条命令（固定内存）
		if(this->PKT_STREAM_CMD_PARTITION_TABLE(&this->m_str_Pkt_Send, str_Partition_Table, ui_Override) == false)
		{
			//打包数据出错，便终止此次下载
			throw(0);
		}


		//计时开始
		time(&t_Start);


		//循环打包发送
		do
		{
			//清空接收BUFF
			this->Clear_Com_Rx_Buffer();


			//发送指令
			if(this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
			{
				for(i=0; i<3; i++)//多次读取是为了防止“回报数据的最初部分有无用数据”
				{
					//只需读6个byte，存入 rx buff 中
					if(this->m_cla_Com_Port.Read_Byte_Sync_V2(6, 3) == true)
					{
						//在 rx_buff 中核对（7E 1A 00 A6 67 7E）
						if(this->m_cla_GFC.mem_uc_str(
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff,
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length,
							ucrTgt_Key, 2, &ulIndex) == true)
						{
							//发现“rsp关键词”，并检查“返回 Status”
							if(*(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff + ulIndex + 2) == 0x00)
							{
								//pass
								bGet_Rsp_Pass = true;
								break;//for
							}
							else if(*(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff + ulIndex + 2) == 0x01)
							{
								//Partition 分区变更
								//0x01 – Partition table differs, override is accepted

								//如果是9x07平台，如果会下载cefs文件就允许“Partition覆盖写入”
								if (((this->m_eu_BB_Chip == MDM9X07) || (this->m_eu_BB_Chip == MSM8909) || (this->m_eu_BB_Chip == MDM9X55) || (this->m_eu_BB_Chip == SDX20) || (this->m_eu_BB_Chip == SDX55) || (this->m_eu_BB_Chip == MDM9X40) || (this->m_eu_BB_Chip == MDM9X06)) && (ui_Override == 0x00) && (this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL))
								{
									//重发, 发送PT文件的有用数据（0x01 – Override existing table）
									if(this->Send_Stream_Cmd_Partition_Table(str_Partition_Table, 0x01) == false)
									{
										throw(0);
									}

									//pass
									bGet_Rsp_Pass = true;
									break;//for
								}
								else
								{
									AfxMessageBox(_T("Partition table differs, override is accepted"));
									//重发, 发送PT文件的有用数据（0x01 – Override existing table）
									if(this->Send_Stream_Cmd_Partition_Table(str_Partition_Table, 0x01) == false)
									{
										throw(0);
									}

									//pass
									bGet_Rsp_Pass = true;
									break;//for

									//this->m_csError_Code.Format(_T("FAIL, Partition status(0x%02X) is wrong!"), *(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff + ulIndex + 2));
									//throw(0);
								}
							}
							else
							{
								this->m_csError_Code.Format(_T("FAIL, Partition status(0x%02X) is wrong!"), *(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff + ulIndex + 2));
								throw(0);
							}
						}
					}
				}//for(i=0; i<3; i++


				//判断提取数据的结果
				if(bGet_Rsp_Pass == true)
				{
					break;//while
				}
			}//write成功



			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= iTimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Send partition table timeout"));
				throw(0);
			}


			//
			Sleep(500);
		}
		while(bGet_Rsp_Pass == false);
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Partition_Table]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Reset(void)
{
	int iTimeOut = 2;
	int i;
	unsigned long ulIndex;
	bool bGet_Rsp_Pass = false;
	unsigned char ucrTgt_Key[] = {0x7e, 0x0c};//7E 0C 14 3A 7E


	iTimeOut = 15;//统一增加15秒的延时


	try
	{
		//打包命令
		this->PKT_STREAM_CMD_RESET(&this->m_str_Pkt_Send);//7E 0B AB 4E 7E


		//发送指令
		if(this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
		{
			for(i=0; i<2; i++)//多次读取是为了防止“回报数据的最初部分有无用数据”
			{
				//只需读5个byte，存入 rx buff 中
				if(this->m_cla_Com_Port.Read_Byte_Sync_V2(5, iTimeOut) == true)
				{
					//在 rx_buff 中核对（7E 0C 14 3A 7E）
					if(this->m_cla_GFC.mem_uc_str(
						this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff,
						this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length,
						ucrTgt_Key, 2, &ulIndex) == true)
					{
						bGet_Rsp_Pass = true;
						break;//for
					}
				}
			}//for(i=0; i<3; i++
		}//write成功



		if(bGet_Rsp_Pass == true)
		{
			//模块重启的延时，否则关闭端口会有问题
			CString csA, csB;
			int s = 4000 / 10;
			//模块重启时间，进度简易显示
			csA.Format(_T("%s"), _T("Stream Reset Module"));
			csB.Format(_T(" ."));
			//循环进度条
			for(int j=0; j<30; j++)
			{
				csA += csB;
				this->Show_Status(csA);
				Sleep(s);
			}
		}
		else
		{
			//20200305-如果无reset响应返回，检查DM口有没有正常出现
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,40) == false)
			{
				throw(1);
			}
			else
			{
				bGet_Rsp_Pass = true;//20200602 
			}
			
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Reset]");

		return false;
	}

	return bGet_Rsp_Pass;
}

bool CARM_OP_QCM::DL_Partition_Table_File(const MBN_FILE_S str_Partition_Table_File)
{
	CString csData;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;

	unsigned long ul_File_Size;					//PT文件总byte数
	unsigned long ul_Read_Bytes_All = 0;		//该PT文件已读到的byte数的统计
	
	//PKT_BUFF_S数据结构BUFF
	PKT_BUFF_S str_PT_Buff;				//Partition_Table文件的BUFF
	//初始化PKT_BUFF_S
	this->m_cla_GFC.PKT_BUFF_INIT(&str_PT_Buff);


	try
	{
		//打开HEX文件
		hFile_Handle = ::CreateFile(str_Partition_Table_File.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);
		CString strlogInfo;
		strlogInfo.Format(_T("%s"),str_Partition_Table_File.cs_Path);
		Save_Trace_Log(strlogInfo);
		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Open partition table file failed!"));
			Save_Trace_Log(_T("FAIL, Open partition table file failed!"));
			throw(0);
		}

		//获取PT文件的BYTE数（PT文件Size）
		ul_File_Size = ::GetFileSize(hFile_Handle, NULL);

		//清空待分配的内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_PT_Buff);
		//分配内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&str_PT_Buff, (ul_File_Size + 8));

		//开始读、下载，PT文件
		//读文件（一次全部读出）
		if(::ReadFile(hFile_Handle, str_PT_Buff.ucp_Buff, ul_File_Size, &str_PT_Buff.ul_Data_Length, NULL) != TRUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Read pt file failed!"));
			throw(0);
		}

		//统计已读到的数据
		ul_Read_Bytes_All = str_PT_Buff.ul_Data_Length;

		//界面显示下载百分比
		csData.Format(_T("Download %s ( %d / %d ) ...... %.1f%%"), str_Partition_Table_File.cs_Name,
			ul_Read_Bytes_All, ul_File_Size, (100.0 * ul_Read_Bytes_All / ul_File_Size));
		this->Show_Status(csData);

		//显示进度条
		this->m_ul_Transmit_Bytes += str_PT_Buff.ul_Data_Length;
		this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));//DL_Partition


		//发送PT文件的有用数据
		if(this->Send_Stream_Cmd_Partition_Table(str_PT_Buff, 0x00) == false)
		//20170405
		//if(this->Send_Stream_Cmd_Partition_Table(str_PT_Buff, 0x01) == false)
		{
			throw(0);
		}


		//关闭PT文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_PT_Buff);

		//
		this->Show_Status(_T("Download partition table file finished"));
		Save_Trace_Log(_T("Download partition table file finished"));
	}
	catch(...)
	{
		//关闭PT文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&str_PT_Buff);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_Mbn_File_V1(const MBN_FILE_S str_Mbn_File, unsigned long ul_Pkt_Data_Len)
{
	//每次从mbn文件中读取“多个包的mbn数据”，然后发送。

	CString csData;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;

	unsigned long ul_File_Size;				//MBN文件总byte数
	unsigned long ul_Read_Bytes_All = 0;	//该MBN文件已读到的byte数的统计
	unsigned long ul_Actual_Read;			//每次实际读到值

	/*
	重要：每次读取文件的byte数，由于是集中发送数据，这个数量非常关键（1024 * 8）。
	读太多，模块反应不过来；读太少，速到超级慢。
	*/
	DWORD dw_Read_Bytes_Every;				//每次读取文件的byte数


	try
	{
		//
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			{
				if(this->m_bLow_Speed_CPU == true)
				{
					dw_Read_Bytes_Every = ul_Pkt_Data_Len * 5;
				}
				else
				{
					if(this->m_iDLOAD_PORT == QCMM_DL_PORT_UART)
					{
						dw_Read_Bytes_Every = ul_Pkt_Data_Len * 15;
					}
					else
					{
						dw_Read_Bytes_Every = ul_Pkt_Data_Len * 30;
					}
				}
			}
			break;
		case MDM9X15:
			{
				dw_Read_Bytes_Every = ul_Pkt_Data_Len * 10;//20;
			}
			break;
		default:
			throw(0);
		}


		//数据结构BUFF
		//每次读取文件的BUF + 待发送的文件数据的BUFF + 剩余数据的BUFF
		//初始化结构体
		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Mbn_Buff.str_Data);
		this->m_str_Mbn_Buff.dw_Pkt_Addr = 0x00;
		this->m_str_Mbn_Buff.b_Read_Finish = false;


		//打开mbn文件
		hFile_Handle = ::CreateFile(str_Mbn_File.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Open %s.mbn file failed!"), str_Mbn_File.cs_Name);
			throw(0);
		}

		//获取mbn文件的BYTE数（mbn文件Size）
		ul_File_Size = ::GetFileSize(hFile_Handle, NULL);



		//清空待分配的内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);
		//分配内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Mbn_Buff.str_Data, (dw_Read_Bytes_Every + 1024));



		//先释放“send指令buff”内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		//分配“send指令buff”内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Pkt_Send, ((9 + ul_Pkt_Data_Len) * 1.5));




		//开始读、下载，HEX文件
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//清空每次使用的Read Buff
			ul_Actual_Read = 0;

			//检查文件是否读完
			if(this->m_str_Mbn_Buff.b_Read_Finish == false)//文件未读完
			{
				//读文件
				if(::ReadFile(hFile_Handle, (this->m_str_Mbn_Buff.str_Data.ucp_Buff + this->m_str_Mbn_Buff.str_Data.ul_Data_Length),
					dw_Read_Bytes_Every, &ul_Actual_Read, NULL) != TRUE)
				{
					this->m_csError_Code.Format(_T("FAIL, Read mbn file failed!"));
					throw(0);
				}

				//
				this->m_str_Mbn_Buff.str_Data.ul_Data_Length += ul_Actual_Read;

				//统计已读到的数据
				ul_Read_Bytes_All += ul_Actual_Read;		

				//界面显示下载百分比
				csData.Format(_T("Download %s ( %d / %d ) ...... %.1f%%"), str_Mbn_File.cs_Name,
					ul_Read_Bytes_All, ul_File_Size, (100.0 * ul_Read_Bytes_All / ul_File_Size));
				this->Show_Status(csData);

				//显示进度条
				this->m_ul_Transmit_Bytes += ul_Actual_Read;
				this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));//DL_Mbn

				//“已读出的总数”等于“文件实际大小”
				if(ul_Read_Bytes_All == ul_File_Size)
				{
					this->m_str_Mbn_Buff.b_Read_Finish = true;
				}

			}//ifif(this->m_str_Mbn_Buff.b_Read_Finish == false


			//发送this->m_str_Mbn_Buff中的有用数据
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
				{
					if(this->Send_Mbn_Pkt_Data_V1(&this->m_str_Mbn_Buff, ul_Pkt_Data_Len) == false)
					{
						throw(0);
					}
				}
				break;
			case MDM9X15:
				{
					if(this->Send_Mbn_Pkt_Data_V2(&this->m_str_Mbn_Buff, ul_Pkt_Data_Len) == false)
					{
						throw(0);
					}
				}
				break;
			default:
				throw(0);
			}
		}
		while((this->m_str_Mbn_Buff.str_Data.ul_Data_Length > 0) || (this->m_str_Mbn_Buff.b_Read_Finish == false));//“待发送的数据”必须全部发完；文件已读完；才会结束循环

		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);
	}
	catch(...)
	{
		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Mbn_Pkt_Data_V1(PKT_DATA_ADDR_BUFF_S * strp_Mbn_Data_Addr, const int i_Pkt_Data_Len)
{
	//mbn文件数据，以“先发送全部mbn数据写指令，最后等待读取全部应答”方式处理

	if(strp_Mbn_Data_Addr->str_Data.ul_Data_Length <= 0)
	{
		this->m_csError_Code.Format(_T("FAIL, Pkt data addr buff is empty! [Send_Mbn_Pkt_Data_V1]"));
		return false;
	}

	int iTimeOut = 5;//发射完全部数据后，读其数据包确认回复的总超时时间
	int iCnt = 2;//单句发送的循环超时次数
	RSP_INFO_S str_Rsp_Info;
	unsigned char * ucpRx_Buff = NULL;
	unsigned long ulRx_Quan = 0;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_BLOCK_WRITTEN;//7E 08 00 00 00 00 57 95 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 7;
		str_Rsp_Info.ui_Pkt_Quan = 0;

		//循环打包发送
		while((strp_Mbn_Data_Addr->str_Data.ul_Data_Length >= i_Pkt_Data_Len) ||
			((strp_Mbn_Data_Addr->str_Data.ul_Data_Length > 0) && (strp_Mbn_Data_Addr->b_Read_Finish == true)))
		{
			//HEX_REAL_DATA_S中有够一次“打包PKT量”数据时；或者“b_Read_Finish”读文件结束；便允许打包发送数据

			//打包一条命令
			if(this->PKT_STREAM_CMD_STREAM_WRITE_V1(&this->m_str_Pkt_Send, strp_Mbn_Data_Addr, i_Pkt_Data_Len) == false)
			{
				//打包数据出错，便终止此次下载
				throw(0);
			}

			//单句发送循环
			while(iCnt > 0)
			{
				//发送指令
				if(this->WRITE_BYTE((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
				{
					//CPU速度不同，处理不同
					if(this->m_bLow_Speed_CPU == true)
					{
						Sleep(50);//夹具下载低速模块需要延迟
						this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);
						Sleep(50);
					}

					//UART口的处理不同
					if(this->m_iDLOAD_PORT == QCMM_DL_PORT_UART)
					{
						Sleep(20);//低速CPU的mbn文件的下载需要延迟
						this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);
						Sleep(20);
					}


					//检测一下，看是否会有回复值
					this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);


					//HEX_REAL_DATA_S中有够一次“打包PKT量”数据时；或者“b_Read_Finish”读文件结束；便允许打包发送数据
					str_Rsp_Info.ui_Pkt_Quan++;
					break;//单句发送成功，退出while单句发送循环
				}
				else
				{
					Sleep(500);
//					::AfxMessageBox(_T("FAIL, Write mbn byte!"));
				}

				if((--iCnt) <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Send mbn data timeout, %s"), this->GET_COM_PORT_ERROR_INFO());
					throw(0);
				}
			}//while(iCnt > 0
		}//while((strp_Hex_Real_Data->str_Actual_Data.ul_Data_Length >= i_Pkt_Length) || (strp_Hex_Real_Data->b_End_Flag)


		//等待、读取、提取、检查应答，返回Frame中Packet部分数据
		if(this->READ_PKT_RSP(str_Rsp_Info, &this->m_str_Pkt_Read, iTimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Mbn_Pkt_Data_V1]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_Mbn_All_File(unsigned long ul_Pkt_Data_Len)
{
	int i;
	unsigned int iOpen_Multi_Image_Type;

	CString strInfo;

	try
	{
		for(i=0; i<MAX_MBN_FILE; i++)
		{
			//判断是否要下载该mbn文件
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == false)
			{
				continue;
			}

			//不同BB芯片，下载的“Multi_Image_Type”不同
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
				{
					//读取Open_Multi_Image_Type
					//this->Show_Out(this->m_strr_Mbn_File_List[i].cs_Name);
					if(this->Get_Mbn_Open_Multi_Image_Type(this->m_strr_Mbn_File_List[i].cs_Name, &iOpen_Multi_Image_Type) == false)
					{
						throw(0);
					}

					//设置Open_Multi_Image_Type
					//strInfo.Format(_T("Image_Type:%d"),iOpen_Multi_Image_Type);
					if(this->Send_Stream_Cmd_Open_Multi_Image(iOpen_Multi_Image_Type) == false)
					{
						throw(0);
					}

					//开始下载mbn文件
					if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[i], ul_Pkt_Data_Len) == false)
					{
						throw(0);
					}
				}
				break;
			case MDM9X15:
				{
					//设置Open_Multi_Image_Type, （自定义 1）
					if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_strr_Mbn_File_List[i].cs_Name) == false)
					{
						throw(0);
					}

					//开始下载mbn文件
					if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[i], ul_Pkt_Data_Len) == false)
					{
						throw(0);
					}
				}
				break;
			case MDM9X07:
			case SDX20:
			case SDX55:
			case MDM9X40:
			case MDM9X06:
			case MDM9X55:
			case MSM8909:
				{
					//设置Open_Multi_Image_Type, （自定义 2）
					if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V2(this->m_strr_Mbn_File_List[i].cs_Name) == false)
					{
						throw(0);
					}

					//
					Sleep(500);

					//开始下载mbn文件
					if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[i], ul_Pkt_Data_Len) == false)
					{
						throw(0);
					}
				}
				break;
			default:
				throw(0);
			}


			//
			Sleep(50);


			//close
			if(this->Send_Stream_Cmd_Close(2) == false)
			{
				throw(0);
			}
		}//for(i=0; i<MAX_MBN_FILE; i++
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_Mbn_Open_Multi_Image_Type(const wchar_t * wcp_Mbn_Name, unsigned int * uip_Multi_Image_Type)
{
	if(wcscmp(wcp_Mbn_Name, _T("DBL")) == 0)
	{
		*uip_Multi_Image_Type = 0x0F;
	}
	else if(wcscmp(wcp_Mbn_Name, _T("FSBL")) == 0)
	{
		*uip_Multi_Image_Type = 0x11;
	}
	else if(wcscmp(wcp_Mbn_Name, _T("OSBL")) == 0)
	{
		*uip_Multi_Image_Type = 0x10;
	}
	else if(wcscmp(wcp_Mbn_Name, _T("AMSS")) == 0)
	{
		*uip_Multi_Image_Type = 0x05;
	}
	else if(wcsstr(wcp_Mbn_Name, _T("EFS")) != NULL)
	{
		*uip_Multi_Image_Type = 0x09;//Compact EFS2 image
	}
	else
	{
		this->m_csError_Code.Format(_T("FAIL, Get %s.mbn open multi image type failed!"), wcp_Mbn_Name);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::GET_FW_SIZE_QCM()
{
	int i;
	CString strData;
	
	try
	{
		//--------------------------------------- mbn文件 --------------------------------------- 
		for(i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				if(this->Get_File_Size(this->m_strr_Mbn_File_List[i].cs_Path, &this->m_strr_Mbn_File_List[i].ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load mbn file %s failed!"), this->m_strr_Mbn_File_List[i].cs_Name);
					this->m_csError_Code = strData;
					this->Show_Out(strData);
					throw(0);
				}
			}
		}


		//--------------------------------------- Partition文件 ---------------------------------------
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
		case MDM9X15:
		case MDM9X07:
		case MDM9X55:
		case MDM9X05:
		case MDM9X40:
		case MDM9X06:
		case SDX20:
		case SDX55:
			
			{
				if (((this->m_eu_BB_Chip == MDM9X07)||(this->m_eu_BB_Chip == MDM9X55)||(this->m_eu_BB_Chip == MDM9X05)||(this->m_eu_BB_Chip == MDM9X06)||(this->m_eu_BB_Chip == SDX20)||(this->m_eu_BB_Chip == SDX55)||(this->m_eu_BB_Chip == MDM9X40)) && (m_iMDM9X07_NEW_FLAG ==1))
				{
					break;				
				}
				//--------------------------------------- Partition-1文件 ---------------------------------------
				if(this->Get_File_Size(this->m_str_Mbn_Partition_Table.cs_Path, &this->m_str_Mbn_Partition_Table.ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load partition file %s failed!"), this->m_str_Mbn_Partition_Table.cs_Name);
					this->m_csError_Code = strData;
					this->Show_Out(strData);


					throw(0);
				}

				//--------------------------------------- Partition-2文件 ---------------------------------------
				if(this->m_str_Mbn_PT_2.b_Enable_DL == true)
				{
					if(this->Get_File_Size(this->m_str_Mbn_PT_2.cs_Path, &this->m_str_Mbn_PT_2.ul_File_Size) == false)
					{
						strData.Format(_T("FAIL, Load partition-2 file %s failed!"), this->m_str_Mbn_PT_2.cs_Name);
						this->m_csError_Code = strData;
						this->Show_Out(strData);
						throw(0);
					}
				}
			}
			break;
		default:
			break;
		}




		//--------------------------------------- 驱动文件 ---------------------------------------
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
		case MDM9X15:
			{
				//-------------------- Hex_E
				if(this->Get_File_Size(this->m_str_Hex_E.cs_Path, &this->m_str_Hex_E.ul_File_Size) == false)
				{
					this->m_csError_Code.Format(_T("FAIL, Load %s file failed!"), this->m_str_Hex_E.cs_Name);
					throw(0);
				}

				//-------------------- Hex_N
				if(this->Get_File_Size(this->m_str_Hex_N.cs_Path, &this->m_str_Hex_N.ul_File_Size) == false)
				{
					this->m_csError_Code.Format(_T("FAIL, Load %s file failed!"), this->m_str_Hex_N.cs_Name);
					throw(0);
				}
			}
			break;
		case MDM9X07:
		case MDM9X40:
		case MDM9X06:
		//case SDX20:	//20190430 EM20没有该类型的文件 20190430
			{
				//-------------------- Mbn_Emerg
				if(this->Get_File_Size(this->m_str_Mbn_Emerg.cs_Path, &this->m_str_Mbn_Emerg.ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load %s file failed!"), this->m_str_Mbn_Emerg.cs_Name);
					this->m_csError_Code=strData;
					this->Show_Out(strData);

					throw(0);
				}

				//-------------------- Mbn_Norm
				if(this->Get_File_Size(this->m_str_Mbn_Norm.cs_Path, &this->m_str_Mbn_Norm.ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load %s file failed!"), this->m_str_Mbn_Norm.cs_Name);
					this->m_csError_Code=strData;
					this->Show_Out(strData);
					throw(0);
				}
			}
			break;
		default:
			break;
		}


		//20210226 QDE007
		if ((_T("QDE007NAEF-M21-AAAAA") != m_csOC)
			&& (_T("QDE007NAEF-M21-BAAAA") != m_csOC))
		{
			//--------------------------------------- CEFS文件 ---------------------------------------
			if (this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
			{
				if (this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load cefs file %s failed!"), this->m_str_Mbn_CEFS.cs_Name);
					this->m_csError_Code = strData;
					this->Show_Out(strData);
					throw(0);
				}
			}
		}

		//--------------------------------------- 假SBL2.mbn文件 ---------------------------------------
		if(this->m_str_Mbn_SBL2_TMP.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_SBL2_TMP.cs_Path, &this->m_str_Mbn_SBL2_TMP.ul_File_Size) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Load %s_V2 file failed!"), this->m_str_Mbn_SBL2_TMP.cs_Name);
				throw(0);
			}
		}
		//--------------------------------------- 假APPSBL.mbn文件 ---------------------------------------
		if(this->m_str_Mbn_APPSBL_TMP.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_APPSBL_TMP.cs_Path, &this->m_str_Mbn_APPSBL_TMP.ul_File_Size) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Load %s_V2 file failed!"), this->m_str_Mbn_APPSBL_TMP.cs_Name);
				throw(0);
			}
		}

		//--------------------------------------- YAFFS2文件 --------------------------------------- 
		for(i=0; i<MAX_YAFFS2_FILE; i++)
		{
			if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
			{
				if(this->Get_File_Size(this->m_strr_Yaffs2_File_List[i].cs_Path, &this->m_strr_Yaffs2_File_List[i].ul_File_Size) == false)
				{
					this->m_csError_Code.Format(_T("FAIL, Load %s file failed!"), this->m_strr_Yaffs2_File_List[i].cs_Name);
					throw(0);
				}
			}
		}

		//--------------------------------------- IMG文件 --------------------------------------- 
		for(i=0; i<MAX_IMG_FILE; i++)
		{
			if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
			{
				if(this->Get_File_Size(this->m_strr_Img_File_List[i].cs_Path, &this->m_strr_Img_File_List[i].ul_File_Size) == false)
				{
					strData.Format(_T("FAIL, Load %s file failed!"), this->m_strr_Img_File_List[i].cs_Name);
					this->m_csError_Code=strData;
					this->Show_Out(strData);
					throw(0);
				}
			}
		}


		//--------------------------------------- yaffs_head.aa文件 --------------------------------------- 
		if(this->m_str_Yaffs_Head_aa.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Yaffs_Head_aa.cs_Path, &this->m_str_Yaffs_Head_aa.ul_File_Size) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Load %s file failed!"), this->m_str_Yaffs_Head_aa.cs_Name);
				throw(0);
			}
		}


		//--------------------------------------- yaffs_head.ab文件 --------------------------------------- 
		if(this->m_str_Yaffs_Head_ab.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Yaffs_Head_ab.cs_Path, &this->m_str_Yaffs_Head_ab.ul_File_Size) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Load %s file failed!"), this->m_str_Yaffs_Head_ab.cs_Name);
				throw(0);
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::COM_PORT_OPEN(void)
{
//	::AfxMessageBox(_T("COM_PORT_OPEN"));

	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->m_cla_Com_Port.Port_Open(500);
	case COMM_OVERLAPPED:
		return this->m_cla_Com_Thr_Port.Port_Open();
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [COM_PORT_OPEN]"));
		break;
	}

	return false;
}

void CARM_OP_QCM::COM_PORT_CLOSE(void)
{
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		this->m_cla_Com_Port.Port_Close();
		break;
	case COMM_OVERLAPPED:
		this->m_cla_Com_Thr_Port.Port_Close();
		break;
	default:
		break;
	}

	return;
}

CString CARM_OP_QCM::GET_COM_PORT_ERROR_INFO(void)
{
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->m_cla_Com_Port.m_csError_Info;
	case COMM_OVERLAPPED:
		return this->m_cla_Com_Thr_Port.m_csError_Code;
	default:
		return _T("FAIL, Comm type error!");
	}
}

bool CARM_OP_QCM::WRITE_BYTE(char * cp_Send_Data, unsigned long ul_Data_Quan)
{
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->m_cla_Com_Port.Write_Byte(cp_Send_Data, ul_Data_Quan);
	case COMM_OVERLAPPED:
		return this->m_cla_Com_Thr_Port.Write_Byte(cp_Send_Data, ul_Data_Quan);
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [WRITE_MULTI_BYTE]"));
		break;
	}

	return false;
}

bool CARM_OP_QCM::READ_PKT_RSP(RSP_INFO_S str_Rsp_Info, PKT_BUFF_S * strp_Pkt_Receive, int i_TimeOut)
{
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->READ_PKT_RSP_SYNC(str_Rsp_Info, strp_Pkt_Receive, i_TimeOut);
	case COMM_OVERLAPPED:
		return this->READ_PKT_RSP_OVERLAPPED(str_Rsp_Info, strp_Pkt_Receive, i_TimeOut);
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [READ_PKT_RSP]"));
		break;
	}

	return false;
}

bool CARM_OP_QCM::READ_PKT_RSP_OVERLAPPED(RSP_INFO_S str_Rsp_Info, PKT_BUFF_S * strp_Pkt_Receive, int i_TimeOut)
{
	//本函数读取高通协议Frame返回，去掉头尾标识，反转意，检查校验位，去掉校验位，再把完整“Packet”值返回
	time_t t_Start, t_End;
	unsigned short usi_FCS, usi_CRC_16;
	int i, iCount;
	bool bGet_Flag;
	int iRep_Byte = -1;				//“串口BUFF”中实际提取byte数量
	unsigned char * ucpData = NULL;	//把数据从“串口BUFF”提取后存放的“临时内存”
	int iValid_Len;
	unsigned int iFrame_Get_Quan = 0;//读到的合格Frame的数量
	bool bRtn = false;
	
	try
	{
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				if(iRep_Byte <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp reply nothing!"));
				}
				else
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp does not reply right data!"));
				}

				throw(0);
			}

			//串口BUFF中是否有数据
			iValid_Len = this->m_cla_Com_Thr_Port.Buffer_Get_Space_Valid(&this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer);

			if(iValid_Len <= str_Rsp_Info.ui_Pkt_Valid_Len)//没有达到至少的(有用数据 + 结束符)，等待
			{
				Sleep(15);//这个时间延迟设置对下载的总时间影响很大
				continue;
			}

			//检查“串口BUFF”中是否有Flag，“0x7E”（如果有可用的一个Frame数据就提取出来）
			bGet_Flag = false;	//找到一个Flag就跳出
			iCount = 0;			//非Flag计数（也就是Frame中的有用数据）
			//开始搜索
			for(i=0; i<iValid_Len; i++)
			{
				if(ASYNC_HDLC_FLAG == (unsigned char)this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer.szBuffer[i])
				{
					//找到可能的数据，Index是“i”，数量是“i + 1”
					i++;
					bGet_Flag = true;
					break;
				}
				else
				{
					iCount++;
				}
			}

			//有Flag，无论是否有用，提取出来，判定后处理货或丢弃
			if(bGet_Flag == true)
			{
				//如果前面已经计数到了“预计有用数据”以上的数量（CMD_ID + Checksum），则可能是个完整的数据包
				if(iCount >= str_Rsp_Info.ui_Pkt_Valid_Len)
				{
					//分配“待解析数据”的“临时内存”
					ucpData = (unsigned char *)calloc((i + 8), sizeof(unsigned char));
					memset(ucpData, 0, (i + 8));

					//从串口buff中提取数据
					iRep_Byte = this->m_cla_Com_Thr_Port.Read_Byte((char *)ucpData, i);

					if(iRep_Byte != i)
					{
						::AfxMessageBox(_T("FAIL, READ_PKT_RSP_OVERLAPPED, Read bytes error 1!"));
						throw(0);
					}

					//这个Flag可能是“结束”端的尾0x74，可能是有用的Frame
					//此时的Frame是不包含“头Flag”的，所以直接检查CMD ID
					if(*(ucpData + 0) == (str_Rsp_Info.ui_Rsp_ID & 0xFF))
					{
						//分配接收PKT_BUFF_S的内存
						this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Receive);
						this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Receive, (iRep_Byte + 8));

						//是期望的RSP，则可以解析
						//把一个Frame的数据中的Packet + FCS载入PKT_BUFF_S
						this->Load_Packet_FCS_Data(ucpData, iRep_Byte, strp_Pkt_Receive);

						//提取校验位后，去掉FCS位
						usi_FCS = this->Del_FCS_From_Packet(strp_Pkt_Receive);
						//计算校验位（无需转意检查）
						usi_CRC_16 = this->Get_CRC_16(strp_Pkt_Receive->ucp_Buff, strp_Pkt_Receive->ul_Data_Length, false);

						if(usi_FCS == usi_CRC_16)
						{
							//校验位验证合格，成功提取数据
							iFrame_Get_Quan++;//读到一个正确的“预计回复Frame”

							if(iFrame_Get_Quan >= str_Rsp_Info.ui_Pkt_Quan)
							{
								bRtn = true;
								break;//PASS
							}
						}
						else
						{
							this->m_csError_Code.Format(_T("FAIL, The checksum of rsp-data is wrong!"));
							throw(0);
						}
					}//if(*(ucpData + 0) == (str_Rsp_Info.ui_Rsp_ID & 0xFF)
				}//if(iCount >= str_Rsp_Info.ui_Pkt_Valid_Len
				else//有结束标识，但前面有用数据数量不够，丢弃
				{
					//从串口buff中提取数据，放临时区，不处理
					//分配“待解析数据”的“临时内存”
					ucpData = (unsigned char *)calloc((i + 1), sizeof(unsigned char));
					//从串口buff中提取数据
					iRep_Byte = this->m_cla_Com_Thr_Port.Read_Byte((char *)ucpData, i);

					if(iRep_Byte != i)
					{
						::AfxMessageBox(_T("FAIL, READ_PKT_RSP_OVERLAPPED, Read bytes error 2!"));
						throw(0);
					}
				}
			}//if(bGet_Flag == true

			//释放内存
			if(ucpData != NULL)
			{
				free(ucpData);
				ucpData = NULL;
			}
		}
		while(true);

		//读到的正确Frame数量不对
		if((bRtn == false) && (iFrame_Get_Quan > 0))
		{
			this->m_csError_Code.Format(_T("FAIL, The quantity of rsp-data is not enough! ( %d / %d )"), iFrame_Get_Quan, str_Rsp_Info.ui_Pkt_Quan);
			throw(0);
		}
	}
	catch(...)
	{
		//释放内存
		if(ucpData != NULL)
		{
			free(ucpData);
			ucpData = NULL;
		}
		return false;
	}

	//释放内存
	if(ucpData != NULL)
	{
		free(ucpData);
		ucpData = NULL;
	}
	return bRtn;
}

bool CARM_OP_QCM::READ_PKT_RSP_SYNC(RSP_INFO_S str_Rsp_Info, PKT_BUFF_S * strp_Pkt_Receive, int i_TimeOut)
{
	//本函数读取高通协议Frame返回，去掉头尾标识，反转意，检查校验位，去掉校验位，再把完整“Packet”值返回
	//用于数据包返回值不是固定数据的情况
	time_t t_Start, t_End;
	unsigned short usi_FCS, usi_CRC_16;
	int i, iCount;
	bool bGet_Flag;
	int iRep_Byte = -1;				//“串口BUFF”中实际提取byte数量
	unsigned int iFrame_Get_Quan = 0;//读到的合格Frame的数量
	bool bRtn = false;
	unsigned char * ucpData = NULL;
	unsigned char * ucpRx_Buff = NULL;
	unsigned long ulRx_Quan = 0;

	try
	{
		//计时开始
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				if(iRep_Byte <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp reply nothing!"));
				}
				else
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp does not reply right data!"));
				}

				throw(0);
			}


			//检查一次接收BUFF，有数据后读，并返回BUFF的地址和数据量
			this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);


			//根据COM_BUFF中有效数据的情况，判断是否要进行解析操作
			if(ulRx_Quan <= 0)
			{
				Sleep(1);//1毫秒足够了，每次检查串口内可读数据的操作所需时间不到1毫秒
				continue;
			}
			else if(ulRx_Quan < str_Rsp_Info.ui_Pkt_Valid_Len)//没有达到至少的(有用数据 + 结束符)，等待
			{
				Sleep(20);//这个时间很重要，影响程序的稳定
				continue;
			}

			//检查“串口BUFF”中是否有Flag，“0x7E”（如果有可用的一个Frame数据就提取出来）
			bGet_Flag = false;	//找到一个Flag就跳出
			iCount = 0;			//非Flag计数（也就是Frame中的有用数据）
			//开始搜索
			for(i=0; i<ulRx_Quan; i++)
			{
				if(ASYNC_HDLC_FLAG == *(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff + i))
				{
					//找到“可能的数据”，Index是“i”，数量是“i + 1”
					i++;
					bGet_Flag = true;
					break;
				}
				else
				{
					iCount++;//有用数据的数量
				}
			}

			//有Flag，无论是否有用，提取出来，判定后处理货或丢弃
			if(bGet_Flag == true)
			{
				//如果前面已经计数到了“预计有用数据”以上的数量（CMD_ID + Checksum），则可能是个完整的数据包
				if(iCount >= str_Rsp_Info.ui_Pkt_Valid_Len)
				{
					//分配“待解析数据”的“临时内存”
					ucpData = (unsigned char *)calloc((i + 8), sizeof(unsigned char));
					memset(ucpData, 0, (i + 8));

					//从串口buff中提取数据
					iRep_Byte = this->m_cla_GFC.PKT_BUFF_EXTRACT_DATA(&this->m_cla_Com_Port.m_str_Com_Rx_Buff, ucpData, i);

					if(iRep_Byte != i)
					{
						this->m_csError_Code.Format(_T("ERROR, READ_PKT_RSP_SYNC, PKT_BUFF_EXTRACT_DATA, Rep_Byte = %d, i = %d;"), iRep_Byte, i);
						::AfxMessageBox(this->m_csError_Code);
						throw(0);
					}

					//这个Flag可能是“结束”端的尾0x74，可能是有用的Frame
					//此时的Frame是不包含“头Flag”的，所以直接检查CMD ID
					if(*(ucpData + 0) == (str_Rsp_Info.ui_Rsp_ID & 0xFF))
					{
						//分配接收PKT_BUFF_S的内存
						this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Receive);
						this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Receive, (iRep_Byte + 8));

						//是期望的RSP，则可以解析
						//把一个Frame的数据中的Packet + FCS载入PKT_BUFF_S
						this->Load_Packet_FCS_Data(ucpData, iRep_Byte, strp_Pkt_Receive);

						//提取校验位后，去掉FCS位
						usi_FCS = this->Del_FCS_From_Packet(strp_Pkt_Receive);
						//计算校验位（无需转意检查）
						usi_CRC_16 = this->Get_CRC_16(strp_Pkt_Receive->ucp_Buff, strp_Pkt_Receive->ul_Data_Length, false);

						if(usi_FCS == usi_CRC_16)
						{
							//校验位验证合格，成功提取数据
							iFrame_Get_Quan++;//读到一个正确的“预计回复Frame”

							if(iFrame_Get_Quan >= str_Rsp_Info.ui_Pkt_Quan)
							{
								bRtn = true;

								break;//PASS
							}
						}
						else
						{
							this->m_csError_Code.Format(_T("FAIL, The checksum of rsp-data is wrong!"));
							throw(0);
						}
					}//if(*(ucpData + 0) == (str_Rsp_Info.ui_Rsp_ID & 0xFF)

					//释放内存
					if(ucpData != NULL)
					{
						free(ucpData);
						ucpData = NULL;
					}
				}//if(iCount >= str_Rsp_Info.ui_Pkt_Valid_Len
				else//有结束标识，但前面有用数据数量不够，丢弃
				{
					//从串口buff中提取数据，直接丢弃，不处理
					this->m_cla_GFC.PKT_BUFF_DEL_DATA(&this->m_cla_Com_Port.m_str_Com_Rx_Buff, i);//i是“可能的数据”的数量，包括有用数据和尾部关键词
				}
			}//if(bGet_Flag == true
		}
		while(true);

		//读到的正确Frame数量不对
		if((bRtn == false) && (iFrame_Get_Quan > 0))
		{
			this->m_csError_Code.Format(_T("FAIL, The quantity of rsp-data is not enough! ( %d / %d )"), iFrame_Get_Quan, str_Rsp_Info.ui_Pkt_Quan);
			throw(0);
		}
	}
	catch(...)
	{
		//释放内存
		if(ucpData != NULL)
		{
			free(ucpData);
			ucpData = NULL;
		}

		return false;
	}

	//释放内存
	if(ucpData != NULL)
	{
		free(ucpData);
		ucpData = NULL;
	}

	return bRtn;
}

bool CARM_OP_QCM::SEND_PKT_V1(PKT_BUFF_S str_Pkt_Write, RSP_INFO_S str_Rsp_Info, PKT_BUFF_S * strp_Pkt_Read, int i_TimeOut)
{
	//在超时内，不断发送“指令”，并核对“期望的返回”，函数本身会返回所有“读到的实际数据”。

	time_t t_Start, t_End;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();
		this->m_csError_Code.Format(_T(""));

		//循环
		time(&t_Start);
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}


			//发送指令
			this->WRITE_BYTE((char *)str_Pkt_Write.ucp_Buff, str_Pkt_Write.ul_Data_Length);


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				throw(1);
			}


			//等待、读取、提取、检查应答，返回Frame中Packet部分数据
			//1秒的超时是不够的，会造成已有回报，但程序却没有读到
			if(this->READ_PKT_RSP(str_Rsp_Info, strp_Pkt_Read, 1) == true)
			{
				//读到校验正确的应答
				break;//pass
			}


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				throw(2);
			}
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::Clear_Com_Rx_Buffer(void)
{
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();
		break;
	case COMM_OVERLAPPED:
		this->m_cla_Com_Thr_Port.Buffer_Clear_All(&this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer);
		break;
	default:
		::AfxMessageBox(_T("ERROR, Clear_Com_Rx_Buffer, Comm type error!"));
		break;
	}
}

bool CARM_OP_QCM::Get_File_Size(const wchar_t * wcp_Path, unsigned long * ulp_Size)
{
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;

	try
	{
		//打开
		hFile_Handle = ::CreateFile(wcp_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			throw(0);
		}

		//获取文件的BYTE数
		*ulp_Size = ::GetFileSize(hFile_Handle, NULL);

		//关闭
		::CloseHandle(hFile_Handle);
		hFile_Handle = INVALID_HANDLE_VALUE;
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Ping_Downloader(int * ip_DL_TYPE)
{
	//用指令“7E 0C 14 3A 7E”，识别下载模式
	//在进入“下载状态”后，确认“emerg”还是“norm”模式下载

	unsigned char * ucpRead_Data = NULL;
	unsigned long ulRead_Quan, ulTgt_Key_Quan, ulIndex;
	unsigned char ucrTgt_Key[16];
	int i;

	try
	{
		//打包命令，7E 0C 14 3A 7E
		this->PKT_DMSS_CMD_VER(&this->m_str_Pkt_Send);

		//循环发送
		for(i=0; i<4; i++)
		{
			//发送指令
			this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, 20);//2-->10

			//有数据则退出解析、判定
			if(ulRead_Quan >= 3)
			{
				break;
			}

			Sleep(2000);
		}

		//无数据，FAIL
		if(ulRead_Quan <= 0)
		{
			this->m_csError_Code.Format(_T("FAIL, Ping_Downloader, No rsp data!"));

			throw(0);
		}

		
		//有数据则核对目标数据
		//有数据则核对目标数据
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			{
				//预计回复 0D 0A, 51 36 32 78 78 2D 4F 53 42 4C, A9 1A 7E （Q62xx-OSBL?~，diag切换下载模式后）
				ucrTgt_Key[0] = 0x4F;
				ucrTgt_Key[1] = 0x53;
				ucrTgt_Key[2] = 0x42;
				ucrTgt_Key[3] = 0x4C;
				ulTgt_Key_Quan = 4;
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					/*
					CString csData;
					this->Get_Char_String(ucpRead_Data, ulRead_Quan, &csData);
					::AfxMessageBox(csData);
					*/

					*ip_DL_TYPE = QCMM_DL_TYPE_NORM;
					return true;
				}

				//预计回复 （PBL_Downloader，diag切换下载模式后）
				ucrTgt_Key[0] = 'P';
				ucrTgt_Key[1] = 'B';
				ucrTgt_Key[2] = 'L';
				ulTgt_Key_Quan = 3;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					/*
					this->Get_Char_String(ucpRead_Data, ulRead_Quan, &csData);
					::AfxMessageBox(csData);
					*/

					*ip_DL_TYPE = QCMM_DL_TYPE_EMERG;
					return true;
				}
			}
			break;
		case MDM9X15:
			{
				//预计回复 7e 0d 14 39 78 31 35 41 2d 41 43 45 54 52 4d 41 5a 41 2d 34 30 30 30 21 ab 7e
				//...9x15A-ACETRMAZA-4000!..(diag切换下载模式后）
				ucrTgt_Key[0] = '9';
				ucrTgt_Key[1] = 'x';
				ucrTgt_Key[2] = '1';
				ucrTgt_Key[3] = '5';
				ulTgt_Key_Quan = 4;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DL_TYPE = QCMM_DL_TYPE_NORM;
					return true;
				}


				//预计回复 7e 0d 0f 50 42 4c 5f 44 6c 6f 61 64 56 45 52 32 2e 30 53 ae 7e
				//...PBL_DloadVER2.0S..（diag切换下载模式后）
				ucrTgt_Key[0] = 'P';
				ucrTgt_Key[1] = 'B';
				ucrTgt_Key[2] = 'L';
				ulTgt_Key_Quan = 3;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DL_TYPE = QCMM_DL_TYPE_EMERG;
					return true;
				}

			}
			break;
		default:
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	this->m_csError_Code.Format(_T("FAIL, Ping_Downloader, No right rsp data!"));
	return false;
}

bool CARM_OP_QCM::DL_Cefs_File(int i_Pkt_Data_Len)
{
	try
	{
		//不同BB芯片，下载的“Multi_Image_Type”不同
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
		case MDM9X15:
			{
				unsigned int iOpen_Multi_Image_Type = 0x09;//Compact EFS2 image 

				//设置Open_Multi_Image_Type
				if(this->Send_Stream_Cmd_Open_Multi_Image(iOpen_Multi_Image_Type) == false)
				{
					throw(0);
				}

				//开始下载mbn文件
				if(this->DL_Mbn_File_V2(this->m_str_Mbn_CEFS, i_Pkt_Data_Len) == false)
				{
					throw(0);
				}
			}
			break;
		case MDM9X07:
		case MDM9X40:
		case MDM9X06:
		case SDX20:
		case SDX55:
		case MDM9X55:
		case MSM8909:
			{
				//设置Open_Multi_Image_Type, （自定义 2）
				if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V2(this->m_str_Mbn_CEFS.cs_Name) == false)
				{
					throw(0);
				}

				//开始下载mbn文件
				if(this->DL_Mbn_File_V2(this->m_str_Mbn_CEFS, i_Pkt_Data_Len) == false)
				{
					throw(0);
				}
			}
			break;
		default:
			throw(0);
		}


		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::Show_DL_Info(void)
{
	::SendMessage(this->m_hWnd_View, WM_DL_INFO_MSG, (WPARAM)this->m_iDL_Emerg_Norm_TYPE, (LPARAM)this->m_iClass_Idx);
}

bool CARM_OP_QCM::Confirm_Dynamic_Com_Port(const int i_Tgt_Com_Port, int i_TimeOut)
{
	time_t t_Start, t_End;
	CString csA, csB;
	int j = 0;

	try
	{
		if (true == m_bPCIE_DL)//PCIE场景下
		{
			i_TimeOut = i_TimeOut / 2;
		}

		csB.Format(_T(" ."));

		time(&t_Start);
		csA.Format(_T("Wait port(%d) is normal..."),i_Tgt_Com_Port);
		this->Show_Status(csA);
		this->Show_Out(csA);
		Save_Trace_Log(csA);

		do
		{
			//读出regedit中的COM列表
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Tgt_Com_Port) == true)
			{
				//找到串口了
			    //等待5秒后继续检查一遍
				Sleep(5000);
				if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Tgt_Com_Port) == false)
				{
					//继续					
				}
				else
				{
					this->Show_Status(_T("Get Port Pass"));
					this->Show_Out(_T("Get Port Pass"));
					Save_Trace_Log(_T("Get Port Pass"));
					return true;
				}
				
			}

			//系统暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//检查是否超时
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Confirm dynamic com port %d timeout!"), i_Tgt_Com_Port);
				this->m_iError_Code  = Confirm_Dynamic_Com_Port_fail1;
				throw(0);
			}

			//进度简易显示
			if((j % 10) == 0)
			{
				csA.Format(_T("Detect dynamic com port %d"), i_Tgt_Com_Port);
			}

			csA += csB;
			this->Show_Status(csA);
			j++;

			//每次读取注册表的延迟
			Sleep(800);
		}
		while(true);
	}
	catch(...)
	{
		this->Show_Status(m_csError_Code);
		this->Show_Out(m_csError_Code);
		Save_Trace_Log(m_csError_Code);
		return false;
	}

	return false;
}

//兼容有设置第二端口的功能
int CARM_OP_QCM::Confirm_Dynamic_Com_Port_Ext(const int i_Tgt_Com_Port,const int i_Second_Tgt_Com_Port, int i_TimeOut)
{
	time_t t_Start, t_End;
	CString csA, csB;
	int j = 0;

	try
	{
		if (true == m_bPCIE_DL)//PCIE场景下
		{
			i_TimeOut = i_TimeOut / 2;
		}


		csB.Format(_T(" ."));

		time(&t_Start);
		csA.Format(_T("Wait port(%d-%d) is normal..."),i_Tgt_Com_Port,i_Second_Tgt_Com_Port);
		this->Show_Status(csA);
		this->Show_Out(csA);
		Save_Trace_Log(csA);

		do
		{
			//读出regedit中的COM列表
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Tgt_Com_Port) == true)
			{
				//找到串口了
				//等待5秒后继续检查一遍
				Sleep(5000);
				if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Tgt_Com_Port) == false)
				{
					//继续					
				}
				else
				{
					this->Show_Status(_T("Get Port Pass"));
					this->Show_Out(_T("Get Port Pass"));
					Save_Trace_Log(_T("Get Port Pass"));
					return 1;
				}

			}
			//--------------------------------------------------------------------
			//读出regedit中的COM列表
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Second_Tgt_Com_Port) == true)
			{
				//找到串口了
				//等待5秒后继续检查一遍
				Sleep(5000);
				if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Second_Tgt_Com_Port) == false)
				{
					//继续					
				}
				else
				{
					this->Show_Status(_T("Get Second Port Pass"));
					this->Show_Out(_T("Get Second Port Pass"));
					Save_Trace_Log(_T("Get Second Port Pass"));
					return 2;
				}

			}
			//--------------------------------------------------------------------


			//系统暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//检查是否超时
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Confirm dynamic com  %d-%d  timeout!"), i_Tgt_Com_Port,i_Second_Tgt_Com_Port);
				this->m_iError_Code  = Confirm_Dynamic_Com_Port_fail2;
				throw(0);
			}

			//进度简易显示
			if((j % 10) == 0)
			{
				csA.Format(_T("Detect dynamic com %d-%d"), i_Tgt_Com_Port,i_Second_Tgt_Com_Port);
			}

			csA += csB;
			this->Show_Status(csA);
			j++;

			//每次读取注册表的延迟
			Sleep(800);
		}
		while(true);
	}
	catch(...)
	{
		this->Show_Status(m_csError_Code);
		this->Show_Out(m_csError_Code);
		Save_Trace_Log(m_csError_Code);
		return 0;
	}

	return 0;
}


bool CARM_OP_QCM::QUERY_PKT(PKT_BUFF_V2_S str_Pkt_V2_Write, RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	time_t t_Start, t_End;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();
		this->m_csError_Code.Format(_T(""));

		//循环
		time(&t_Start);
		//
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//发送指令
			this->WRITE_BYTE((char *)str_Pkt_V2_Write.ucr_Buff, str_Pkt_V2_Write.ul_Data_Length);

			//核对有没有期望数据
			if (m_eu_BB_Chip == MSM8953) 
			{
				if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, 3) == true)
				{
					//读到校验正确的应答
					break;//pass
				}

			}
			else
			{
				if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, 3) == true)
				{
					//读到校验正确的应答
					break;//pass
				}

			}
			

			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				throw(0);
			}
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::READ_PKT_RSP_V2(RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	//用“核对法”，检查是否有正确的RSP
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->READ_PKT_RSP_SYNC_V2(str_Rsp_Info_V2, i_TimeOut);
	case COMM_OVERLAPPED:
		return this->READ_PKT_RSP_OVERLAPPED_V2(str_Rsp_Info_V2, i_TimeOut);
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [READ_PKT_RSP_V2]"));
		break;
	}

	return false;
}

bool CARM_OP_QCM::READ_PKT_RSP_SYNC_V2(RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	//用“核对法”，检查是否有正确的RSP
	//用于数据包返回值是固定数据的情况
	time_t t_Start, t_End;
	int i, j;
	int iRsp_Pkt_Numb = 0;//读到的实际PKT包的数量统计
	int iData_Index = 0;//检查串口BUFF数据的当前Index值，（已核对无误的PKT包数据就不用再核对了）
	unsigned char * ucpRx_Buff = NULL;
	unsigned long ulRx_Quan = 0;

	try
	{
		//计时开始
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				if(this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp reply nothing!"));
				}
				else
				{
					this->m_csError_Code.Format(_T("FAIL, Rsp does not reply right data!"));
				}

				throw(0);
			}


			//检查一次接收BUFF，有数据后读，并返回BUFF的地址和数据量
			this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);


			//-------------------------------------- 有新数据，便判定是否要核对“期望值” -------------------------------------- 
			//根据COM_BUFF中有效数据的情况，判断是否要进行解析操作
			if(ulRx_Quan <= 0)
			{
				Sleep(1);//1毫秒足够了，每次检查串口内可读数据的操作所需时间不到1毫秒
				continue;
			}
			else if(ulRx_Quan < str_Rsp_Info_V2.ui_Rsp_Data_Length)//没有达到至少的数量，等待
			{
				Sleep(20);//这个时间很重要，影响程序的稳定
				continue;
			}
		
			//当前状态已有足够数据量的响应
			//已当前核对到的串口Index值作为起始值
			for(i=iData_Index; i<ulRx_Quan; i++)
			{
				//发现串口BUFF有个字符与“期望响应”的首字符一致
				if(*(ucpRx_Buff + i) == str_Rsp_Info_V2.ucr_Expect_Rsp[0])
				{
					//开始按“期望响应”的数据进行全面核对
					for(j=0; j<str_Rsp_Info_V2.ui_Rsp_Data_Length; j++)
					{
						//检查串口BUFF的Index号是否超越了串口BUFF中的数据
						if((i + j) < ulRx_Quan)
						{
							if(*(ucpRx_Buff + i + j) != str_Rsp_Info_V2.ucr_Expect_Rsp[j])
							{
								break;//发现任意数据不同，则退出，没找到期望数据
							}
						}
						else
						{
							break;//有用数据结束了，也退出循环
						}
					}//for(j=0; j<str_Rsp_Info_V2.ui_Rsp_Data_Length;

					//若期望值核对到了最后一位，便是找到一个匹配的响应
					if(j == str_Rsp_Info_V2.ui_Rsp_Data_Length)
					{
						//统计，找到了一个期望数据包
						iRsp_Pkt_Numb++;
						//在这个包之前的串口BUFF数据，算已检查过，后续便不再检查
						iData_Index = i + str_Rsp_Info_V2.ui_Rsp_Data_Length;
						//按iData_Index作为下次检查的起点，由于循环会“+1”，所以赋值是“-1”
						i = iData_Index - 1;
					}
					else if(j > str_Rsp_Info_V2.ui_Rsp_Data_Length)
					{
						this->m_csError_Code.Format(_T("ERROR, READ_PKT_RSP_SYNC_V2, j = %d, Rsp_Data_Length = %d;"), j, str_Rsp_Info_V2.ui_Rsp_Data_Length);
						::AfxMessageBox(this->m_csError_Code);
						throw(0);
					}
				}//发现串口BUFF有个字符与“期望响应”的首字符一致
			}//for(i=iData_Index; i<ulRx_Quan; i++

			//检查串口BUFF中的数据结束后
			//检查响应包的数量对不对
			if(iRsp_Pkt_Numb == str_Rsp_Info_V2.ui_Rsp_Pkt_Quan)
			{
				//期望数据包的数量正确，跳出while
				break;//pass
			}
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::SEND_PKT_V2(PKT_BUFF_S str_Pkt_Write, RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	//在超时内，不断发送“指令”，并核对“期望的返回”，函数本身不返回“读到的实际数据”。

	time_t t_Start, t_End;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();
		this->m_csError_Code.Format(_T(""));

		//循环
		time(&t_Start);
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//发送指令
			this->WRITE_BYTE((char *)str_Pkt_Write.ucp_Buff, str_Pkt_Write.ul_Data_Length);

			//等待、读取、提取、检查应答，返回Frame中Packet部分数据
			//1秒的超时是不够的，会造成已有回报，但程序却没有读到
			if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, 3) == true)
			{
				//读到校验正确的应答
				break;//pass
			}

			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				throw(0);
			}
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::COM_PORT_RE_DETECT(const wchar_t * wcp_Info, int i_Sleep_Time, bool b_Ctrl_Com_Port)
{
	//不改变 COM PORT 号，对COM口进行探测、识别、打开、关闭操作

	CString csA, csB;
	int s = i_Sleep_Time / 10;

	try
	{
		if(b_Ctrl_Com_Port)
		{
			//关闭串口(第一次)，因为模块会重启
			this->COM_PORT_CLOSE();
		}

		//模块重启时间，进度简易显示
		csA.Format(_T("%s"), wcp_Info);
		csB.Format(_T(" ."));

		for(int j=0; j<10; j++)
		{
			csA += csB;
			this->Show_Status(csA);
			Sleep(s);
		}

		//开始扫描“重启”的同号串口
		//检查串口是否存在（第二次）
		
		csB.Format(_T("Delay_Time:%d"),m_iDelay_Time);
		this->Show_Out(csB);

		if (m_iDelay_Time<=20)
		{
			m_iDelay_Time =20;
		}

		if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, m_iDelay_Time) == false)//9秒改到20秒 20190116
		{
			this->m_csError_Code.Format(_T("FAIL, Confirm dynamic com port:%d"), this->m_iCom_Port);
			throw(0);
		}

		if(b_Ctrl_Com_Port)
		{
//			::AfxMessageBox(_T("二次打开端口"));
			//打开串口（第二次）
			if(this->COM_PORT_OPEN() == false)
			{
				this->m_csError_Code.Format(_T("%s"), this->GET_COM_PORT_ERROR_INFO());
				throw(0);
			}
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::READ_PKT_RSP_OVERLAPPED_V2(RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	time_t t_Start, t_End;
	unsigned long ulValid_Quan;
	int i, j;
	int iRsp_Pkt_Numb = 0;//读到的实际PKT包的数量统计
	int iData_Index = 0;//检查串口BUFF数据的当前Index值，（已核对无误的PKT包数据就不用再核对了）
	
	try
	{
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				if(ulValid_Quan <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, READ_PKT_RSP_OVERLAPPED_V2, Rsp reply nothing!"));
				}
				else
				{
					this->m_csError_Code.Format(_T("FAIL, READ_PKT_RSP_OVERLAPPED_V2, Rsp does not reply right data!"));
				}

				throw(0);
			}

			//串口BUFF中是否有数据
			//读串口BUFF中的有用数据数量
			ulValid_Quan = this->m_cla_Com_Thr_Port.Buffer_Get_Space_Valid(&this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer);

			if(ulValid_Quan < str_Rsp_Info_V2.ui_Rsp_Data_Length)//没有达到至少一个期望数据包的数据量
			{
				Sleep(15);//这个时间延迟设置对下载的总时间影响很大
				continue;
			}
			else//当前状态已有足够数据量的响应
			{
				//已当前核对到的串口Index值作为起始值
				for(i=iData_Index; i<ulValid_Quan; i++)
				{
					//发现串口BUFF有个字符与“期望响应”的首字符一致
					if((unsigned char)this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer.szBuffer[i] == str_Rsp_Info_V2.ucr_Expect_Rsp[0])
					{
						//开始按“期望响应”的数据进行全面核对
						for(j=0; j<str_Rsp_Info_V2.ui_Rsp_Data_Length; j++)
						{
							//检查串口BUFF的Index号是否超越了串口BUFF中的数据
							if((i + j) < ulValid_Quan)
							{
								if((unsigned char)this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer.szBuffer[i + j] != str_Rsp_Info_V2.ucr_Expect_Rsp[j])
								{
									break;//发现任意数据不同，则退出，没找到期望数据
								}
							}
							else
							{
								break;//有用数据结束了，也退出循环
							}
						}//for(j=0; j<str_Rsp_Info_V2.ui_Rsp_Data_Length;

						//若期望值核对到了最后一位，便是找到一个匹配的响应
						if(j == str_Rsp_Info_V2.ui_Rsp_Data_Length)
						{
							//统计，找到了一个期望数据包
							iRsp_Pkt_Numb++;
							//在这个包之前的串口BUFF数据，算已检查过，后续便不再检查
							iData_Index = i + str_Rsp_Info_V2.ui_Rsp_Data_Length;
							//按iData_Index作为下次检查的起点，由于循环会“+1”，所以赋值是“-1”
							i = iData_Index - 1;
						}
						else if(j > str_Rsp_Info_V2.ui_Rsp_Data_Length)
						{
							this->m_csError_Code.Format(_T("ERROR, READ_PKT_RSP_SYNC_V2, j = %d, Rsp_Data_Length = %d;"), j, str_Rsp_Info_V2.ui_Rsp_Data_Length);
							::AfxMessageBox(this->m_csError_Code);
							throw(0);
						}
					}//发现串口BUFF有个字符与“期望响应”的首字符一致
				}//for(i=iData_Index; i<ulValid_Quan; i++

				//检查串口BUFF中的数据结束后
				//检查响应包的数量对不对
				if(iRsp_Pkt_Numb == str_Rsp_Info_V2.ui_Rsp_Pkt_Quan)
				{
					//期望数据包的数量正确，跳出while
					break;//pass
				}
			}//当前状态已有足够数据量的响应
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_Mbn_File_Index(CString cs_Mbn_Name, int * ip_Index)
{
	//依据“文件名”或“image名”确认文件的index

	switch(this->m_eu_BB_Chip)
	{	
	case QSC6270: //UC15 
	case MDM6X00:
	case MDM9X15:
		{
			if(wcscmp(cs_Mbn_Name, _T("DBL")) == 0)
			{
				*ip_Index = DBL_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("FSBL")) == 0)
			{
				*ip_Index = FSBL_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("OSBL")) == 0)
			{
				*ip_Index = OSBL_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("AMSS")) == 0)
			{
				*ip_Index = AMSS_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("SBL1")) == 0)
			{
				*ip_Index = SBL1_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("SBL2")) == 0)
			{
				*ip_Index = SBL2_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("RPM")) == 0)
			{
				*ip_Index = RPM_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("APPSBL")) == 0)
			{
				*ip_Index = APPSBL_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("APPSBOOT")) == 0)
			{
				*ip_Index = APPSBL_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("DSP1")) == 0)
			{
				*ip_Index = DSP1_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("DSP2")) == 0)
			{
				*ip_Index = DSP2_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("DSP3")) == 0)
			{
				*ip_Index = DSP3_MBN_FILE_I;
			}
			else
			{
				this->m_csError_Code.Format(_T("FAIL, Get %s.mbn file index error!"), cs_Mbn_Name);
				return false;
			}
		}
		break;
	case MDM9X07:
	case MDM9X40:
	case MDM9X06:
	case SDX20:
	case SDX55:
	case MDM9X55:
	case MSM8909:

		{
			//9x07平台用 image 名确定文件的index

			if(wcscmp(cs_Mbn_Name, _T("0:SBL")) == 0)
			{
				*ip_Index = SBL_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:TZ")) == 0)
			{
				*ip_Index = TZ_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:MIBIB")) == 0)
			{
				*ip_Index = MIBIB_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:TZ_B")) == 0)
			{
				*ip_Index = TZ_B_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RPM")) == 0)
			{
				*ip_Index = RPM_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RPM_B")) == 0)
			{
				*ip_Index = RPM_B_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:ABOOT")) == 0)
			{
				*ip_Index = ABOOT_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:ABOOT_B")) == 0)
			{
				*ip_Index = ABOOT_B_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:BOOT")) == 0)
			{
				*ip_Index = BOOT_9X07_IMG_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:BOOT_B")) == 0)
			{
				*ip_Index = BOOT_B_9X07_IMG_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:MODEM")) == 0)
			{
				*ip_Index = MODEM_9X07_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:MODEM_B")) == 0)
			{
				*ip_Index = MODEM_B_9X07_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RECOVERY")) == 0)
			{
				*ip_Index = REC_9X07_IMG_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RECOVERYFS")) == 0)
			{
				*ip_Index = RECFS_9X07_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:SYS_BACK")) == 0)
			{
				*ip_Index = SYS_BACK_9X07_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:SYSTEM")) == 0)
			{
				*ip_Index = SYS_9X07_UBI_FILE_I;
			}
			//BG96 MSM9206 ADD 
			else if(wcscmp(cs_Mbn_Name, _T("0:MBA")) == 0)
			{
				*ip_Index = MBA_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:QDSP")) == 0)
			{
				*ip_Index = QDSP_9X07_MBN_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:APPS")) == 0)
			{
				*ip_Index = APPS_9X07_MBN_FILE_I;
			}			
			else if(wcscmp(cs_Mbn_Name, _T("0:ACDB")) == 0)
			{
				*ip_Index = ACDB_9X07_MBN_FILE_I;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:SCRUB")) == 0)
			{
				*ip_Index = SCRUB_9X07_MBN_FILE_I;
			}	
			//-------------------------------------
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_MBA")) == 0)
			{
				*ip_Index = MBA_9X07_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_TZ")) == 0)
			{
				*ip_Index = TZ_9X07_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_RPM")) == 0)
			{
				*ip_Index = RPM_9X07_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_APPS")) == 0)
			{
				*ip_Index = APPS_9X07_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_ACDB")) == 0)
			{
				*ip_Index = ACDB_9X07_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE_DEVCFG")) == 0)//0:Cache_DEVCFG
			{
				*ip_Index = DEVCFG_9X07_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:QDSP_RECOVERY")) == 0)
			{
				*ip_Index = QDSP_REC_9X07_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:APPS_RECOVERY")) == 0)
			{
				*ip_Index = APPS_REC_9X07_MBN_FILE_I_EXT;
			}	
			//MDM9640
			
			else if(wcscmp(cs_Mbn_Name, _T("0:TZ_BAK")) == 0)
			{
				*ip_Index = TZ_BAK_9X40_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:RPM_BAK")) == 0)
			{
				*ip_Index = RPM_BAK_9X40_MBN_FILE_I_EXT;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:ABOOT_BAK")) == 0)
			{
				*ip_Index = ABOOT_BAK_9X40_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:BOOT_BAK")) == 0)
			{
				*ip_Index = BOOT_BAK_9X40_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:SYS_BAK")) == 0)
			{
				*ip_Index = SYS_BAK_9X40_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:MOD_BAK")) == 0)
			{
				*ip_Index = MOD_BAK_9X40_MBN_FILE_I_EXT;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:SEC")) == 0)
			{
				*ip_Index = SYS_BAK_9X06_SEC_DAT;
			}
			//临时增加 BG96
			else if(wcscmp(cs_Mbn_Name, _T("0:EFS2APPS")) == 0)
			{
				*ip_Index = EFS2APPS_MBN_FILE_I;
			}
			//AG35 MSM9628 0:
			else if(wcscmp(cs_Mbn_Name, _T("0:RECOVERYFS_B")) == 0)
			{
				*ip_Index = RECOVERYFS_B_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:QDSP6SW_B")) == 0)
			{
				*ip_Index = QDSP6SW_B_UBI_FILE_I;
			}	
			else if(wcscmp(cs_Mbn_Name, _T("0:USR_DATA")) == 0)
			{
				*ip_Index = USR_DATA_UBI_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:DEVCFG")) == 0)
			{
				*ip_Index = DEVCFG_UBI_FILE_I;
			}
			//9x55--AG15
			else if(wcscmp(cs_Mbn_Name, _T("0:EFS2")) == 0)
			{
				*ip_Index = EFS2_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:APDP")) == 0)
			{
				*ip_Index = APDP_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RAWDATA")) == 0)
			{
				*ip_Index = RAWDATA_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:CUST_INFO")) == 0)
			{
				*ip_Index = CUST_INFO_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:FOTA")) == 0)
			{
				*ip_Index = FOTA_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:RECOVERYFS")) == 0)
			{
				*ip_Index = RECOVERYFS_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:CACHE")) == 0)
			{
				*ip_Index = CACHE_FILE_I;
			}
			else if(wcscmp(cs_Mbn_Name, _T("0:USRFS")) == 0)
			{
				*ip_Index = USRFS_FILE_I;
			}
			else
			{
				this->m_csError_Code.Format(_T("FAIL, Get image %s index error!"), cs_Mbn_Name);
				return false;
			}
		}
		break;
	default:
		this->m_csError_Code.Format(_T("FAIL, Get image index bb(%d) error!"), this->m_eu_BB_Chip);
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::Judge_Ctrl_OP_Option(void)
{
	try
	{
		//Partition文件
		if(this->m_bFW_DL == true)
		{
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
			case MDM9X15:
			case MDM9X07:
			case MDM9X55:
			case MDM9X40:
			case MDM9X06:
			case MDM9X05:
			case SDX20:
			case SDX55:
			//case SDM660:
				{
					//Partition文件是必须的
					//9X07 特殊情况 20170711
					if (((this->m_eu_BB_Chip == MDM9X07)||(this->m_eu_BB_Chip == MDM9X06)||(this->m_eu_BB_Chip == MDM9X05)||(this->m_eu_BB_Chip == MDM9X55)||(this->m_eu_BB_Chip == SDX20)||(this->m_eu_BB_Chip == SDX55)||(this->m_eu_BB_Chip == MDM9X40)) &&(1 == m_iMDM9X07_NEW_FLAG))
					{
						break;
					}

					//20200114-如果是Firehose方式的话，不需要判断此字段
					if(this->m_str_Mbn_Partition_Table.b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain partition file!"));
						this->Show_Out(_T("ERROR, FW does not contain partition file!"));
						throw(0);
					}
				}
				break;
			default:
				break;
			}
		}


		//判定该操作下，是否有与之匹配的FW文件载入
		//是否格式化
		if(this->m_bCEFS_DL == true)
		{
			//需要“格式化”
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
			case MDM9X15:
			case MDM9X07:
			case MDM9X55:
			case MDM9X40:
			case MDM9X06:
			case MDM9X05:
			case SDX20:
			case SDX55:
				{
					//20210226 QDE007
					if ((_T("QDE007NAEF-M21-AAAAA") != m_csOC)
						&& (_T("QDE007NAEF-M21-BAAAA") != m_csOC))
					{
						if (this->m_str_Mbn_CEFS.b_Enable_DL == false)
						{
							this->m_csError_Code.Format(_T("ERROR, FW does not contain efs file!"));
							this->Show_Out(_T("ERROR, FW does not contain efs file!"));
							throw(0);
						}
					}
				}
				break;
			case MSM8909:
				{
					//firehose下才需要
					if (1 == m_iMDM9X07_NEW_FLAG)
					{
						if (this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].b_Enable_DL == false)
						{
							this->m_csError_Code.Format(_T("ERROR, FW does not contain fs_image file!"));
							throw(0);
						}
						//
						if (this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].b_Enable_DL == false)
						{
							this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
							throw(0);
						}
					}

				}
				break;
			case MSM8917:
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8917_IMG_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain fs_image file!"));
						throw(0);
					}
					//
					if(this->m_strr_Mbn_File_List[ZERO_8917_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;
			case MSM8937:
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8937_IMG_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain fs_image file!"));
						throw(0);
					}
					//
					if(this->m_strr_Mbn_File_List[ZERO_8937_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;
			case SDM660:
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_SDM660_IMG_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain fs_image file!"));
						throw(0);
					}
					//
					if(this->m_strr_Mbn_File_List[ZERO_SDM660_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;
			case SDM845:
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_SDM845_IMG_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain fs_image file!"));
						throw(0);
					}
					//
					if(this->m_strr_Mbn_File_List[ZERO_SDM845_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;
			case MSM8953:
				{					
					//
					if(this->m_strr_Mbn_File_List[ZERO_8953_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;

			case SM6115:
				{					
					//
					if(this->m_strr_Mbn_File_List[ZERO_SM6115_BIN_FILE_I].b_Enable_DL == false)
					{
						this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
						throw(0);
					}
				}
				break;
			case QCM6125:
			{
				//
				if (this->m_strr_Mbn_File_List[ZERO_QCM6125_BIN_FILE_I].b_Enable_DL == false)
				{
					this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
					throw(0);
				}
			}
			break;
			case SM4350:
			{
				//
				if (this->m_strr_Mbn_File_List[ZERO_SM4350_BIN_FILE_I].b_Enable_DL == false)
				{
					this->m_csError_Code.Format(_T("ERROR, FW does not contain zero file!"));
					throw(0);
				}
			}
			break;
			
				
			default:
				break;
			}
		}
		else
		{
			//不“格式化”
			switch(this->m_eu_BB_Chip)
			{
			case MSM8909://8909由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;
			case MSM8917://8917由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8917_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_8917_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;
			case MSM8937://8937由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8937_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_8937_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;
			case SM4350://SM4350由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
			{
				if (this->m_strr_Mbn_File_List[FS_IMAGE_SM4350_IMG_FILE_I].b_Enable_DL == true)
				{
					this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
					throw(0);
				}

				if (this->m_strr_Mbn_File_List[ZERO_SM4350_BIN_FILE_I].b_Enable_DL == true)
				{
					this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
					throw(0);
				}
			}
			break;
				
			case MSM8953://8953由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_8953_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_8953_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;

			case SM6115://SM6115由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_SM6115_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_SM6115_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;
			case QCM6125://QCM6125由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
			{
				if (this->m_strr_Mbn_File_List[FS_IMAGE_QCM6125_IMG_FILE_I].b_Enable_DL == true)
				{
					this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
					throw(0);
				}

				if (this->m_strr_Mbn_File_List[ZERO_QCM6125_BIN_FILE_I].b_Enable_DL == true)
				{
					this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
					throw(0);
				}
			}
			break;
				
			case SDM660://SDM660由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_SDM660_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_SDM660_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;
			case SDM845://SDM845由于无法控制下载的具体文件，所以此处要对加载的FW文件包做判定
				{
					if(this->m_strr_Mbn_File_List[FS_IMAGE_SDM845_IMG_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain fs_image format file!"));
						throw(0);
					}

					if(this->m_strr_Mbn_File_List[ZERO_SDM845_BIN_FILE_I].b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, FW contain zero format file!"));
						throw(0);
					}
				}
				break;

			default:
				break;
			}
		}



		//
		//20210226 QDE007
		if ((_T("QDE007NAEF-M21-AAAAA") != m_csOC)
			&& (_T("QDE007NAEF-M21-BAAAA") != m_csOC))
		{
			if (this->m_bQCN_DL == true)
			{
				if (this->m_str_Mbn_QCN_DL.b_Enable_DL == false)
				{
					this->m_csError_Code.Format(_T("ERROR, FW does not contain qcn-a file!"));
					this->Show_Out(_T("ERROR, FW does not contain qcn-a file!"));

					throw(0);
				}
			}
		}


		//
		if(this->m_bQCN_BACKUP || this->m_bQCN_RESTORE)
		{
			if(this->m_str_Mbn_QCN_BU_RS.b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("ERROR, FW does not contain qcn-b file!"));
				this->Show_Out(_T("ERROR, FW does not contain qcn-b file!"));
				throw(0);
			}
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::QLIB_INIT(int i_Com_Port)
{
	int i = 0;
	
	try
	{
		//初始显示
		this->Show_Status(_T("Init qlib ......"));

		// Set the library mode--QPST or QPHONEMS
		QLIB_SetLibraryMode(QLIB_LIB_MODE_QPHONEMS);

		// Set TargetType
		QLIB_SetTargetType((unsigned char)QLIB_TARGET_TYPE_MSM_MDM);

		// Connect to the desired COM port
		this->m_hQLib_Handle = QLIB_ConnectServer(i_Com_Port);

		if(this->m_hQLib_Handle)
		{
			// Clear the serial Rx buffer-- don't check return value because it is not enabled for QPST version
			QLIB_FlushRxBuffer(this->m_hQLib_Handle);

			// Check online status
			for(i=0; i<5; i++)
			{
				if(this->IS_PHONE_CONNECTED() == true)
				{
					break;
				}
			}
			if(i >= 5)
			{
				this->m_csError_Code.Format(_T("FAIL, INIT_LIB_%d, IS_PHONE_CONNECTED is timeout!"), i_Com_Port);
				throw(0);
			}

			//关闭高通自己的LOG
			QLIB_SetLogFlags(this->m_hQLib_Handle, LOG_NOTHING);

			/*
			//设置timeout时间
			if(this->CONFIG_TIME_OUT(QMSL_Timeout_Runtime_Mode_Switching, 5000) == false)
			{
				throw(0);
			}
			*/

			//关闭回调函数
//			QLIB_ConfigureCallBacks(this->m_hQLib_Handle, NULL, NULL, asyncMessageCallBack);
		}
		else
		{
			this->m_csError_Code.Format(_T("FAIL, INIT_LIB_%d, ConnectServer is fail!"), i_Com_Port);
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::QLIB_FREE(void)
{
	if(this->m_hQLib_Handle == NULL)
	{
		return;
	}

	// This should be done before the application completes
	QLIB_DisconnectServer(this->m_hQLib_Handle);
	this->m_hQLib_Handle = NULL;
	// This forces all connections to be closed, in the event that autodetections
	// were done during the course of the application.
	QLIB_DisconnectAllServers();
}

bool CARM_OP_QCM::IS_PHONE_CONNECTED(void)
{
	//检查模块是否还连接着
	unsigned char ucRsp;

	ucRsp = QLIB_IsPhoneConnected(this->m_hQLib_Handle);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_IsPhoneConnected, Rtn = %d;"), ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::CONFIG_TIME_OUT(unsigned long ul_TimeOut_ID, unsigned long ul_New_Value_mS)
{
	unsigned char ucRsp;

	ucRsp = QLIB_ConfigureTimeOut(this->m_hQLib_Handle, ul_TimeOut_ID, ul_New_Value_mS);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_ConfigureTimeOut, TimeOut_ID = %d, Rtn = %d!"), ul_TimeOut_ID, ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::GET_PHONE_OP_MODE(unsigned long * ulp_Phone_Mode)
{
	unsigned char ucRsp;

	ucRsp = QLIB_GetPhoneOperatingMode(this->m_hQLib_Handle, ulp_Phone_Mode);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_GetPhoneOperatingMode, Rtn = %d!"), ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::IS_FTM_MODE(unsigned char * ucp_Is_FTM_Mode)
{
	//检查模块是否是FTM模式
	/*
	param pbIsFTMMode = output, true(1) if the phone is in FTM mode,
                            false(0) if the phone is not in FTM mode
	*/
	unsigned char ucRsp;

	ucRsp = QLIB_IsFTM_Mode(this->m_hQLib_Handle, ucp_Is_FTM_Mode);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_IsFTM_Mode, Mode = %d, Rtn = %d!"), ucp_Is_FTM_Mode, ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DIAG_CONTROL_F(int i_Mode)
{
	unsigned char ucRsp;

	ucRsp = QLIB_DIAG_CONTROL_F(this->m_hQLib_Handle, i_Mode);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_DIAG_CONTROL_F, Mode = %d, Rtn = %d!"), i_Mode, ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::FTM_SET_COMMAND_CODE(short s_Command_Code)
{
	unsigned char ucRsp;

	ucRsp = QLIB_FTM_SET_COMMAND_CODE(this->m_hQLib_Handle, s_Command_Code);

	if(ucRsp == FALSE)
	{
		this->m_csError_Code.Format(_T("FAIL, QLIB_FTM_SET_COMMAND_CODE, Rtn = %d!"), ucRsp);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Enter_FTM_Mode(void)
{
	unsigned char ucRsp;
	short iCommand_Code = 0;
	unsigned long iPhone_Operating_Mode = 0;
	int i;
	unsigned char ucIsFTMMode;

	try
	{
		//读command code的当前值
		ucRsp = QLIB_FTM_GET_COMMAND_CODE(this->m_hQLib_Handle, &iCommand_Code);
		if(ucRsp == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_FTM_GET_COMMAND_CODE, Rtn = %d!"), ucRsp);
			throw(0);
		}

		// This command only works for command mode 75
		if(iCommand_Code == FTM_COMMAND_75)
		{
			this->GET_PHONE_OP_MODE(&iPhone_Operating_Mode);
		}
		else
		{
			this->m_csError_Code.Format(_T("ERROR, QLIB_FTM_GET_COMMAND_CODE, Command code = %d!"), iCommand_Code);
			throw(0);
		}

		/*
		//读“IsFTM_Mode”
		ucIsFTMMode = 2;
		this->IS_FTM_MODE(&ucIsFTMMode);
		*/

		//开始进入FTM模式
		i = 1;
		do
		{
			//设置COMMAND_CODE
			if(this->FTM_SET_COMMAND_CODE(FTM_COMMAND_75) == false)
			{
				throw(3);
			}

			//切换模式
			if(this->DIAG_CONTROL_F(MODE_FTM_F) == false)
			{
				throw(4);
			}

			Sleep(400);
			
			//检查是否FTM模式
			ucIsFTMMode = 2;
			if(this->IS_FTM_MODE(&ucIsFTMMode) == false)
			{
				throw(5);
			}

			//判定是否是FTM模式，“1”代表当前是FTM模式
			if(ucIsFTMMode == 1)
			{
				break;//PASS
			}

			if(i >= 5)
			{
				throw(6);
			}

			i++;
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Enter_Online_Mode(void)
{
	int i;
	unsigned long ulPhone_Mode;

	try
	{
		//开始进入FTM模式
		i = 1;
		do
		{
			//设置COMMAND_CODE
			if(this->FTM_SET_COMMAND_CODE(FTM_COMMAND_75) == false)
			{
				throw(0);
			}

			Sleep(100);

			//切换模式
			if(this->DIAG_CONTROL_F(MODE_ONLINE_F) == false)
			{
				throw(0);
			}

			Sleep(400);

			//检测当前OP模式
			ulPhone_Mode = 999;
			if(this->GET_PHONE_OP_MODE(&ulPhone_Mode) == false)
			{
				throw(0);
			}
		
			//判定是否是Online模式
			if(ulPhone_Mode == SYS_OPRT_MODE_ONLINE)
			{
				break;//PASS
			}

			if(i >= 5)
			{
				throw(0);
			}

			i++;
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::BACKUP_QCN_QLIB(MBN_FILE_S str_QCN_FILE)
{
	/*
	In QPHONE mode, you can use 
	QLIB_NV_LoadNVDefinitionFile 
	QLIB_NV_LoadNVsFromSource 
	QLIB_NV_WriteNVsToMobile 

	But it will change Item File Format to Regular File Format for some EFS Item Files (no NV ID EFS Files) 
	*/
	unsigned char ucRsp;
	char * cpData = NULL;
	int iTemp;
	int iResultCode = 0;
	int iNumOfNVItemValuesLoaded = 0;
	CString csData;
	wchar_t wcrData[8];

	try
	{
		this->Show_Status(_T("Waiting......"));

		//------------------------------ 初始化QLIB ------------------------------ 
		if(this->QLIB_INIT(this->m_iCom_Port) == false)
		{
			throw(0);
		}
		//------------------------------ 


		//进FTM模式
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			if(this->Enter_FTM_Mode() == false)
			{
				throw(1);
			}
			break;
		case MDM9X15:
			break;
		default:
			throw(0);
		}


		//------------------------------ 载入NvDefinition文件 ------------------------------ 
		if(this->Load_Nv_Definition(this->m_csNv_Definition_File) == false)
		{
			throw(2);
		}
		//------------------------------ 


		//------------------------------ 检查扩展名（若无扩展名，便添加）------------------------------ 
		str_QCN_FILE.cs_Path.MakeLower();
		iTemp = str_QCN_FILE.cs_Path.GetLength();
		//
		if(iTemp < 4)
		{
			this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_QLIB, QCN file path is wrong!"));
			throw(0);
		}
		//提取文件扩展名
		memset(wcrData, 0, sizeof(wcrData));
		wcrData[0] = str_QCN_FILE.cs_Path.GetAt(iTemp - 4);
		wcrData[1] = str_QCN_FILE.cs_Path.GetAt(iTemp - 3);
		wcrData[2] = str_QCN_FILE.cs_Path.GetAt(iTemp - 2);
		wcrData[3] = str_QCN_FILE.cs_Path.GetAt(iTemp - 1);
		//核对文件扩展名
		if(wcscmp(wcrData, _T(".qcn")) != 0)
		{
			//添加“.qcn”扩展名
			str_QCN_FILE.cs_Path += _T(".qcn");
		}
		//------------------------------ 


		//------------------------------ 从模块中读出NV ------------------------------ 
		this->Show_Status(_T("Read nv data from module"));
		//
		ucRsp = QLIB_NV_LoadNVsFromMobile(this->m_hQLib_Handle, &iNumOfNVItemValuesLoaded, &iResultCode);
		if((ucRsp == FALSE) || (iResultCode != 0))
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_LoadNVsFromMobile, Rtn = %d, ResultCode = %d;"), ucRsp, iResultCode);
			throw(3);
		}
		//------------------------------ 

		
		//分配内存
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpData, 512);
		//把要保存文件路径转换为单char
		this->m_cla_GFC.WideChar_To_MultiByte(str_QCN_FILE.cs_Path, cpData, &iTemp);


		//------------------------------ 把NV保存为QCN文件 ------------------------------ 
		this->Show_Status(_T("Write nv data to qcn file"));
		//
		ucRsp = QLIB_NV_WriteNVsToQCN(this->m_hQLib_Handle, cpData, &iResultCode);
		if((ucRsp == FALSE) || (iResultCode != 0))
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_WriteNVsToQCN, Rtn = %d, ResultCode = %d;"), ucRsp, iResultCode);
			throw(4);
		}
		//------------------------------ 


		//恢复Online模式
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			if(this->Enter_Online_Mode() == false)
			{
				throw(5);
			}
			break;
		case MDM9X15:
			break;
		default:
			throw(0);
		}


		//释放QLIB资源
		this->QLIB_FREE();
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);

		//显示成功信息
		csData.Format(_T("Save nv data as %s successfully. %s"), str_QCN_FILE.cs_Name, str_QCN_FILE.cs_Path);
		this->Show_Status(csData);
	}
	catch(int iErr)
	{
		//恢复Online模式
		if(iErr > 0)
		{
			switch(this->m_eu_BB_Chip)
			{
			case MDM6X00:
			case QSC6270:
				this->Enter_Online_Mode();
				break;
			default:
				break;
			}
		}

		//释放QLIB资源
		this->QLIB_FREE();
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);

		this->Show_Status(this->m_csError_Code);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::RESTORE_QCN_QLIB(MBN_FILE_S str_QCN_B_FILE, MBN_FILE_S str_QCN_A_FILE)
{
	/*
	In QPHONE mode, you can use 
	QLIB_NV_LoadNVDefinitionFile 
	QLIB_NV_LoadNVsFromSource 
	QLIB_NV_WriteNVsToMobile 

	But it will change Item File Format to Regular File Format for some EFS Item Files (no NV ID EFS Files) 
	*/

	CString csData;
	
	try
	{
		//初始化QLIB
		if(this->QLIB_INIT(this->m_iCom_Port) == false)
		{
			throw(0);
		}


		//进FTM模式
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			if(this->Enter_FTM_Mode() == false)
			{
				throw(0);
			}
			break;
		case MDM9X15:
			break;
		default:
			throw(0);
		}


		//载入NvDefinition文件
		if(this->Load_Nv_Definition(this->m_csNv_Definition_File) == false)
		{
			throw(0);
		}
		
		//导入备份出的QCN文件（或者是单独导入QCN文件），Restore QCN-B，不是FW中的QCN
		if(this->m_bQCN_RESTORE)
		{
			if(this->WRITE_QCN_TO_MODULE(str_QCN_B_FILE) == false)
			{
				throw(0);
			}
		}

		//导入FW中QCN文件，Restore QCN-A
		if(this->m_bQCN_DL)
		{
			if(this->WRITE_QCN_TO_MODULE(str_QCN_A_FILE) == false)
			{
				throw(0);
			}
		}


		//恢复Online模式
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			if(this->Enter_Online_Mode() == false)
			{
				throw(0);
			}
			break;
		case MDM9X15:
			break;
		default:
			throw(0);
		}


		//释放QLIB资源
		this->QLIB_FREE();

		//显示成功信息
		this->Show_Status(_T("Restore nv data to module successfully"));
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		//恢复Online模式
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			this->Enter_Online_Mode();
			break;
		default:
			break;
		}

		//释放QLIB资源
		this->QLIB_FREE();

		return false;
	}

	return true;
}

bool CARM_OP_QCM::WRITE_QCN_TO_MODULE(MBN_FILE_S str_QCN_FILE)
{
	unsigned char ucRsp;
	CString csData;
	char * cpData = NULL;
	int iTemp;
	int iNumOfNVItemValuesLoaded = 0;
	int iResultCode = 0;
	wchar_t wcrData[8];

	try
	{
		//从QCN中读出NV
		csData.Format(_T("Load nv data from %s"), str_QCN_FILE.cs_Name);
		this->Show_Status(csData);


		//------------------------------ 检查扩展名（若无扩展名，便添加）------------------------------ 
		str_QCN_FILE.cs_Path.MakeLower();
		iTemp = str_QCN_FILE.cs_Path.GetLength();
		//
		if(iTemp < 4)
		{
			this->m_csError_Code.Format(_T("ERROR, WRITE_QCN_TO_MODULE, QCN file path is wrong!"));
			throw(0);
		}
		//提取文件扩展名
		memset(wcrData, 0, sizeof(wcrData));
		wcrData[0] = str_QCN_FILE.cs_Path.GetAt(iTemp - 4);
		wcrData[1] = str_QCN_FILE.cs_Path.GetAt(iTemp - 3);
		wcrData[2] = str_QCN_FILE.cs_Path.GetAt(iTemp - 2);
		wcrData[3] = str_QCN_FILE.cs_Path.GetAt(iTemp - 1);
		//核对文件扩展名
		if(wcscmp(wcrData, _T(".qcn")) != 0)
		{
			//添加“.qcn”扩展名
			str_QCN_FILE.cs_Path += _T(".qcn");
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpData, 512);
		this->m_cla_GFC.WideChar_To_MultiByte(str_QCN_FILE.cs_Path, cpData, &iTemp);


		//------------------------------ 从qcn文件中读出数据 ------------------------------ 
		ucRsp = QLIB_NV_LoadNVsFromQCN(this->m_hQLib_Handle, cpData, &iNumOfNVItemValuesLoaded, &iResultCode);
		if((ucRsp == FALSE) || (iResultCode != 0))
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_LoadNVsFromQCN, Rtn = %d, ResultCode = %d;"), ucRsp, iResultCode);
			throw(0);
		}
		//------------------------------ 

		//------------------------------ 把qcn数据写入模块 ------------------------------ 
		csData.Format(_T("Write %s nv data to module"), str_QCN_FILE.cs_Name);
		this->Show_Status(csData);
		//
		ucRsp = QLIB_NV_WriteNVsToMobile(this->m_hQLib_Handle, &iResultCode);
		if((ucRsp == FALSE) || (iResultCode != 0))
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_WriteNVsToMobile, Rtn = %d, ResultCode = %d;"), ucRsp, iResultCode);
			throw(0);
		}
		//------------------------------ 

		//释放内存
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		//释放内存
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Load_Nv_Definition(const wchar_t * wcp_Nv_Definition_File)
{
	unsigned char ucRsp;
	char * cpData = NULL;
	int iTemp, i;
	int iNumNVDefLoaded = 0;
	int iResultCode = 0;

	try
	{
		//清除NV值
		this->Show_Status(_T("Clear nv values ......"));

		ucRsp = QLIB_NV_ClearNVValues(this->m_hQLib_Handle);
		if(ucRsp == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_ClearNVValues, COM%d, Rtn = %d;"), this->m_iCom_Port, ucRsp);
			throw(0);
		}

		//分配内存
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpData, 512);
		
		//载入NvDefinition
		this->Show_Status(_T("Load nv definition file ......"));
		//把NvDefinition文件路径转换为单char
		this->m_cla_GFC.WideChar_To_MultiByte(wcp_Nv_Definition_File, cpData, &iTemp);


		//
		for(i=0; i<5; i++)
		{
			Sleep(500);

			ucRsp = QLIB_NV_LoadNVDefinitionFile(this->m_hQLib_Handle, cpData, &iNumNVDefLoaded, &iResultCode);

			if((ucRsp != FALSE) && (iResultCode == ERROR_FREE))
			{
				break;
			}

			/*
			if((_iResultCode == MSXML_FAILED_TO_LOAD_DEF) || (_iResultCode == MSXML_FAILED_TO_INSTANTIATE) )
			{
			bResult = false;
			}
			*/
		}
		if(i >= 5)
		{
			this->m_csError_Code.Format(_T("FAIL, QLIB_NV_LoadNVDefinitionFile, COM%d, Rtn = %d, ResultCode = %d;"), this->m_iCom_Port, ucRsp, iResultCode);
			throw(0);
		}


		//释放内存
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		//释放内存
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpData);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Ping_DLoad_Port(int * ip_DLoad_Port, int * ip_DL_TYPE)
{
	//用指令“7E 0C 14 3A 7E”，识别下载端口类型，甚至识别到需用的下载模式

	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulTgt_Key_Quan, ulIndex;
	unsigned char ucrTgt_Key[16];
	int i;

	try
	{
		this->Show_Status(_T("Ping dload port......"));

		//打包命令，7E 0C 14 3A 7E
		this->PKT_DMSS_CMD_VER(&this->m_str_Pkt_Send);

		//发送指令
		for(i=0; i<4; i++)
		{
			this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, 20);//1-->20 20190117

			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				break;
			}
		}

		//无数据，则是UART口
		if(ulRead_Quan <= 0)
		{
			*ip_DLoad_Port = QCMM_DL_PORT_UART;
			return true;
		}


		//有数据则核对目标数据
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
		case QSC6270:
			{
				//预计回复 13 0C D2 7A 7E（diag口切换下载模式前）
				ucrTgt_Key[0] = 0x13;
				ucrTgt_Key[1] = 0x0C;
				ucrTgt_Key[2] = 0xD2;
				ucrTgt_Key[3] = 0x7A;
				ucrTgt_Key[4] = 0x7E;
				ulTgt_Key_Quan = 5;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					return true;
				}

				//预计回复 0D 0A, 51 36 32 78 78 2D 4F 53 42 4C, A9 1A 7E （Q62xx-OSBL?~，diag切换下载模式后）
				ucrTgt_Key[0] = 0x4F;
				ucrTgt_Key[1] = 0x53;
				ucrTgt_Key[2] = 0x42;
				ucrTgt_Key[3] = 0x4C;
				ulTgt_Key_Quan = 4;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					*ip_DL_TYPE = QCMM_DL_TYPE_NORM;
					return true;
				}

				//预计回复 （PBL_Downloader，diag切换下载模式后，Length 24: ~..PBL_DownloaderVER1.0~）
				ucrTgt_Key[0] = 'P';
				ucrTgt_Key[1] = 'B';
				ucrTgt_Key[2] = 'L';
				ulTgt_Key_Quan = 3;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					*ip_DL_TYPE = QCMM_DL_TYPE_EMERG;
					return true;
				}
			}
			break;
		case MDM9X15:
			{
				//预计回复 
				//0c e1 00 e1 00 00 00 00 01 00 00 00 00 00 00 00（diag口切换下载模式前）
				//0C E1 00 E1 22 08 12 20 01 00 00 00 00 00 00 00 00 00 00 00 00 
				ucrTgt_Key[0] = 0x0c;
				ucrTgt_Key[1] = 0xe1;
				ucrTgt_Key[2] = 0x00;
				ucrTgt_Key[3] = 0xe1;
				ucrTgt_Key[4] = 0x00;
				ulTgt_Key_Quan = 4;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					return true;
				}

				//预计回复 7e 0d 14 39 78 31 35 41 2d 41 43 45 54 52 4d 41 5a 41 2d 34 30 30 30 21 ab 7e
				//...9x15A-ACETRMAZA-4000!..(diag切换下载模式后）
				ucrTgt_Key[0] = '9';
				ucrTgt_Key[1] = 'x';
				ucrTgt_Key[2] = '1';
				ucrTgt_Key[3] = '5';
				ulTgt_Key_Quan = 4;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					*ip_DL_TYPE = QCMM_DL_TYPE_NORM;
					return true;
				}

				//预计回复 7e 0d 0f 50 42 4c 5f 44 6c 6f 61 64 56 45 52 32 2e 30 53 ae 7e
				//...PBL_DloadVER2.0S..（diag切换下载模式后）
				ucrTgt_Key[0] = 'P';
				ucrTgt_Key[1] = 'B';
				ucrTgt_Key[2] = 'L';
				ulTgt_Key_Quan = 3;

				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTgt_Key_Quan, &ulIndex) == true)
				{
					*ip_DLoad_Port = QCMM_DL_PORT_DIAG;
					*ip_DL_TYPE = QCMM_DL_TYPE_EMERG;
					return true;
				}
			}
			break;
		default:
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Ping_DLoad_Port]");

		return false;
	}

	//返回的数据都不是“期望值”
	this->m_csError_Code.Format(_T("FAIL, Ping dload port has no right data!"));
	this->m_iError_Code = Ping_DLoad_Port_Fail;

	return false;
}

void CARM_OP_QCM::PKT_DMSS_CMD_VER(PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 8;//定义用于装此命令BUFF的尺寸

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_VERREQ, true);

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x14, true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x3A, true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::READ_BYTE(unsigned char ** ucp2_Buff_Pointer, unsigned long * ulp_Data_Length)
{
	//读串口，返回串口实际接收到数据的BUFF的地址和BUFF中的byte数据量
	bool bRtn = false;

	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		{
			bRtn = this->m_cla_Com_Port.Read_Byte_Sync_V1();
			*ucp2_Buff_Pointer = this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff;
			*ulp_Data_Length = this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length;
		}
		break;
	case COMM_OVERLAPPED:
		{
			bRtn = true;
			//返回串口BUFF的地址
			*ucp2_Buff_Pointer = (unsigned char *)this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer.szBuffer;
			//读串口BUFF中的有用数据数量
			*ulp_Data_Length = this->m_cla_Com_Thr_Port.Buffer_Get_Space_Valid(&this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer);			
		}
		break;
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [READ_BYTE]"));
		break;
	}

	return bRtn;
}

bool CARM_OP_QCM::QUERY_BYTE(unsigned char * ucp_Send_Data, unsigned long ul_Send_Quan, unsigned char ** ucp2_Read_Data, unsigned long * ulp_Read_Quan, int i_TimeOut)
{
	time_t t_Start, t_End;
	unsigned long ulLast_Read = 0;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();
		this->m_csError_Code.Format(_T(""));

		//发送指令
		this->WRITE_BYTE((char *)ucp_Send_Data, ul_Send_Quan);

		//计时开始
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//检查串口BUFF中有多少数据可以读
			this->READ_BYTE(ucp2_Read_Data, ulp_Read_Quan);

			//检查数据情况
			if(*ulp_Read_Quan > 0)//读到数据了
			{
				if(*ulp_Read_Quan == ulLast_Read)//新状态数据量没有增加，就可以返回了
				{
					return true;
				}
				else//为防止后续还有数据，防止数据断裂，再搜索一次数据量后再确定是否读串口
				{
					ulLast_Read = *ulp_Read_Quan;
				}
			}
			
			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Query byte timeout"));
				throw(0);
			}

			//下次读取的间隔时间
			Sleep(50);
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Switch_To_DL_Mode_In_AT(int i_TimeOut)
{
	//用AT指令通过UART口把模块切换到下载模式
	char crAt_Cmd[32];
	unsigned long ulTemp, ulRead_Quan, ulIndex;
	unsigned char * ucpRead_Data = NULL;
	unsigned char ucrTgt_Key[16];

	try
	{
		this->Show_Status(_T("Switch to dl mode uart......"));

		//打包AT切换指令
		sprintf_s(crAt_Cmd, "AT+QDL=%d\r\n", this->m_iBaud_Rate);
		ulTemp = strlen(crAt_Cmd);

		//发送指令
		this->QUERY_BYTE((unsigned char *)crAt_Cmd, ulTemp, &ucpRead_Data, &ulRead_Quan, i_TimeOut);

		//无数据
		if(ulRead_Quan <= 0)//无应答
		{
			this->m_csError_Code.Format(_T("FAIL, Switch to dl mode uart no data!"));
			this->m_iError_Code = Switch_To_DL_Mode_In_AT_Fail1;
			throw(0);
		}

		//有数据则核对目标数据

		//预计回复 OK
		ucrTgt_Key[0] = 'O';
		ucrTgt_Key[1] = 'K';
		ulTemp = 2;

		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTemp, &ulIndex) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Switch to dl mode uart no right data!"));
			this->m_iError_Code = Switch_To_DL_Mode_In_AT_Fail2;
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::Get_Char_String(unsigned char * ucp_Buff_Data, unsigned long ul_Data_Quan, CString * csp_String_Data)
{
	//从unsigned char数据中提取能显示的字符数据载入CString
	csp_String_Data->Format(_T(""));

	for(int i=0; i<ul_Data_Quan; i++)
	{
		if((*(ucp_Buff_Data + i) >= 32) && (*(ucp_Buff_Data + i) < 0x7E))
		{
			*csp_String_Data += *(ucp_Buff_Data + i);
		}
	}
}

void CARM_OP_QCM::PKT_WRITE_DLOAD_FLAG_CMD(unsigned char uc_Flag, PKT_BUFF_S * strp_Pkt_Cmd)
{
	int iBuff_Size = 10;//定义用于装此命令BUFF的尺寸
	unsigned short usiCRC16;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, DLOAD_FLAG_REQ, true);
	//标志位数据
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, uc_Flag, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

bool CARM_OP_QCM::Send_Write_DLoad_Flag(unsigned char uc_Flag, int i_TimeOut)
{
	//移远自定义下载过程中写入、清除标志位的指令，指令返回超时1秒足够了
	unsigned long ulRead_Quan;
	unsigned char * ucpRead_Data = NULL;

	try
	{
		//打包命令
		this->PKT_WRITE_DLOAD_FLAG_CMD(uc_Flag, &this->m_str_Pkt_Send);
		
		//7E 60 01 9B 7B 7E
		//7E 60 00 12 6A 7E
		//正确回复：7E 61 00 CA 73 7E
		//若终端不支持该指令，则回复7E 0E 49 6E 76.....61 6E 64 BF C3 7E，字符是“Invalid CommandXInvalid Command”

		//发送指令（读一次就可以了）
		this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, i_TimeOut);

		/*
		if(ulRead_Quan > 0)
		{
			CString a, b;

			a.Format(_T("发送 "));
			for(int i=0; i<this->m_str_Pkt_Send.ul_Data_Length; i++)
			{
				b.Format(_T("%02X "), *(this->m_str_Pkt_Send.ucp_Buff + i));
				a+=b;
			}

			::AfxMessageBox(a);

			a.Format(_T("回复 "));
			for(int i=0; i<ulRead_Quan; i++)
			{
				b.Format(_T("%02X "), *(ucpRead_Data + i));
				a+=b;
			}

			::AfxMessageBox(a);

			this->Get_Char_String(ucpRead_Data, ulRead_Quan, &b);

			::AfxMessageBox(b);
		}
		*/

	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Write_DLoad_Flag]");
		this->m_iError_Code = Send_Write_DLoad_Flag_Fail1;

		return false;
	}

	return true;
}

void CARM_OP_QCM::COM_PORT_CHANGE_BAUDRATE(int i_Baud_Rate)
{
	//同步串口
	this->m_cla_Com_Port.m_iBaudRate = i_Baud_Rate;
	//重叠串口
	this->m_cla_Com_Thr_Port.m_str_COM.dwBaudRate = i_Baud_Rate;
}

bool CARM_OP_QCM::READ_DMSS_HW_INFO(unsigned long * ulp_Max_Write_Size)
{
	//用指令“7E 07 C7 84 7E”，读HW信息，Parameters request command packet
	//UC15紧急下载，08 06 01 02 00 90 00 00 D8 6D 7E
	//UC15正常下载，08 06 01 10 00 00 00 00 69 46 7E
	//UC20紧急下载，08 06 01 01 00 90 00 00 14 70 7E
	//UC20正常下载，08 07 01 40 00 00 00 00 DE AC 7E
	//EC20正常下载，08 08 01 20 00 90 00 00 E0 9D 7E
	//EC20紧急下载，08 08 01 06 00 90 00 00 e9 c6 7e

	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulTemp;
	unsigned char ucrCmd[8];
	int i;
	unsigned short usi_FCS, usi_CRC_16;
	bool bRtn = false;

	try
	{
		this->Show_Status(_T("Read dmss hw info......"));

		//打包命令，7E 07 C7 84 7E
		ucrCmd[0] = 0x7E;
		ucrCmd[1] = 0x07;//CMD_PREQ
		ucrCmd[2] = 0xC7;
		ucrCmd[3] = 0x84;
		ucrCmd[4] = 0x7E;
		ucrCmd[5] = 0x00;

		//发送指令
		for(i=0; i<2; i++)
		{
			//收发数据
			this->QUERY_BYTE(ucrCmd, 5, &ucpRead_Data, &ulRead_Quan, 2);

			if(ulRead_Quan >= 11)//读到足够的数据，开始解析
			{
				//分配接收PKT_BUFF_S的内存
				this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);
				this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Pkt_Read, (ulRead_Quan + 8));

				//可以解析
				//把一个Frame的数据中的Packet + FCS载入PKT_BUFF_S
				this->Load_Packet_FCS_Data(ucpRead_Data, ulRead_Quan, &this->m_str_Pkt_Read);

				//提取校验位后，去掉FCS位
				usi_FCS = this->Del_FCS_From_Packet(&this->m_str_Pkt_Read);
				//计算校验位（无需转意检查）
				usi_CRC_16 = this->Get_CRC_16(this->m_str_Pkt_Read.ucp_Buff, this->m_str_Pkt_Read.ul_Data_Length, false);

				if(usi_FCS == usi_CRC_16)
				{
					//校验位验证合格，数据无失真
					//判定数据是不是返回的params信息数据
					if((this->m_str_Pkt_Read.ul_Data_Length == 8) && (*(this->m_str_Pkt_Read.ucp_Buff + 0) == CMD_PARAMS))
					{
						bRtn = true;
						break;//PASS
					}
				}
			}//读到足够的数据
		}//for(i=0; i<2; i++

		if(bRtn == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Read dmss hw info, no right data!"));
			this->m_iError_Code = READ_DMSS_HW_INFO_Fail1;
			throw(0);
		}
		
		//有数据则提取params信息数据
		ulTemp = *(this->m_str_Pkt_Read.ucp_Buff + 3);
		ulTemp &= 0xFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(this->m_str_Pkt_Read.ucp_Buff + 4);
		ulTemp &= 0xFFFF;

		*ulp_Max_Write_Size = ulTemp;
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [READ_DMSS_HW_INFO]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_Streaming_Info(PKT_BUFF_S str_Pkt_Rec_Data, unsigned long * ulp_Max_Block_Size)
{
	/*
	7E 02
	51 43 4F 4D 20 66 61 73 74 20 64 6F 77 6E 6C 6F
	61 64 20 70 72 6F 74 6F 63 6F 6C 20 74 61 72 67
	03
	02
	00 04 00 00
	00 00 00 00
	0A
	46 4D 36 34 44 31 47 35 36 41
	64 00 80 00 
	00 00 10 00 00 00 10
	*/
	/*
	7E 02 //Command (0x02)
	51 43 4F 4D 20 66 61 73 74 20 64 6F 77 6E 6C 6F //Magic number (“QCOM fast download protocol targ”)
	61 64 20 70 72 6F 74 6F 63 6F 6C 20 74 61 72 67
	03 //Version number
	02 //Compatible version
	00 04 00 00 //Maximum (preferred) block size（低位在前，高位在后）
	00 00 00 00 //Base address of Flash
	0C //Flash ID length
	48 38 42 43 53 30 51 47 30 4D 4D 52
	64 00 //Window size
	80 00 //Number of sectors, 32 * 16 = 512
	00 00 10 00 00 00 10 00 00 00 10 00 00 00 10 00 //Sector sizes, 4* number of sectors
	00 00 10 00 00 00 10 00 00 00 10 00 00 00 10 00
	......
	00 00 10 00 00 00 10 00 00 00 10 00 00 00 10 00
	00 00 10 00 00 00 10 00 00 00 10 00 00 00 10 00
	01
	AD AB 
	7E
	*/
	unsigned long ulTemp;
	wchar_t wcrData[128];
	char crData[128];
	int i;
	CString csData;
	
	try
	{
		this->Show_Status(_T("Get streaming info......"));

		//Maximum (preferred) block size（低位在前，高位在后）
		ulTemp = *(str_Pkt_Rec_Data.ucp_Buff + 38) & 0xFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 37);
		ulTemp &= 0xFFFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 36);
		ulTemp &= 0xFFFFFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 35);
		ulTemp &= 0xFFFFFFFF;

		*ulp_Max_Block_Size = ulTemp;


		//
		memset(wcrData, 0, sizeof(wcrData));
		memset(crData, 0, sizeof(crData));
		for(i=0; i<32; i++)
		{
			crData[i] = *(str_Pkt_Rec_Data.ucp_Buff + 1 + i) & 0xFF;
		}
		this->m_cla_GFC.MultiByte_To_WideChar(crData, wcrData, &i);
		csData.Format(_T("%s "), wcrData);


		//Flash型号信息
		ulTemp = *(str_Pkt_Rec_Data.ucp_Buff + 43) & 0xFF;
		memset(wcrData, 0, sizeof(wcrData));
		memset(crData, 0, sizeof(crData));
		for(i=0; i<ulTemp; i++)
		{
			crData[i] = *(str_Pkt_Rec_Data.ucp_Buff + 44 + i) & 0xFF;
		}
		this->m_cla_GFC.MultiByte_To_WideChar(crData, wcrData, &i);
		csData += wcrData;
		this->Show_Status(csData);


		//Base address of Flash
		ulTemp = *(str_Pkt_Rec_Data.ucp_Buff + 42) & 0xFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 41);
		ulTemp &= 0xFFFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 40);
		ulTemp &= 0xFFFFFF;
		ulTemp = ulTemp << 8;
		ulTemp |= *(str_Pkt_Rec_Data.ucp_Buff + 39);
		ulTemp &= 0xFFFFFFFF;

		if(ulTemp != 0x00)
		{
			this->m_csError_Code.Format(_T("FAIL, Base address 0x%08X is wrong!"), ulTemp);
			this->m_iError_Code = Get_Streaming_Info_Fail1;
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Read_Nv_Max_Item_Max_Len_In_AT(int * ip_Max_Item, int * ip_Max_Len)
{
	//用AT指令通过UART口读模块最大NV item数量和最大
	char crAt_Cmd[32];
	unsigned long ulTemp, ulRead_Quan, i, j, ulIndex;
	unsigned char * ucpRead_Data = NULL;
	char * cpTemp_Data = NULL;
	unsigned char ucrTgt_Key[] = {"OK"};
	unsigned char ucrData_Key[] = {"+QNVR: ("};
	int iTimeOut = 3;
	int irNv_Item[2], iNv_Len, iCollect;

	/*
	[2013-12-25_17:17:49]AT+QNVR=?
	[2013-12-25_17:17:49]+QNVR: (0-7250),256

	[2013-12-25_17:17:49]OK
	*/

	try
	{
		this->Show_Status(_T("Read Nv max item and len......"));

		//打包AT切换指令
		sprintf_s(crAt_Cmd, "AT+QNVR=?\r\n");
		ulTemp = strlen(crAt_Cmd);

		//发送指令
		this->QUERY_BYTE((unsigned char *)crAt_Cmd, ulTemp, &ucpRead_Data, &ulRead_Quan, iTimeOut);

		//无数据
		if(ulRead_Quan <= 0)//无应答
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Max_Item_Max_Len_In_AT, No data!"));
			this->m_iError_Code = Read_Nv_Max_Item_Max_Len_In_AT_Fail11;
			throw(0);
		}

		//有数据则核对目标数据

		//预计回复 OK
		ulTemp = 2;
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, ulTemp, &ulIndex) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Max_Item_Max_Len_In_AT, No right data!"));
			this->m_iError_Code = Read_Nv_Max_Item_Max_Len_In_AT_Fail12;
			throw(0);
		}

		//预计回复 +QNVR: (0-7250),256
		ulTemp = 8;
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrData_Key, ulTemp, &ulIndex) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Max_Item_Max_Len_In_AT, No right data!"));
			this->m_iError_Code = Read_Nv_Max_Item_Max_Len_In_AT_Fail13;
			throw(0);
		}

		//分配临时内存
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpTemp_Data, ulRead_Quan);

		//提取数据
		j = 0;
		iCollect = 0;

		for(i=(ulIndex + ulTemp); i<ulRead_Quan; i++)
		{
			if((*(ucpRead_Data + i) >= '0') && (*(ucpRead_Data + i) <= '9'))
			{
				*(cpTemp_Data + j) = *(ucpRead_Data + i);
				j++;
			}
			else if(*(ucpRead_Data + i) == '-')
			{
				*(cpTemp_Data + j) = '\0';
				irNv_Item[0] = atoi(cpTemp_Data);
				j = 0;
				iCollect++;
			}
			else if(*(ucpRead_Data + i) == ')')
			{
				*(cpTemp_Data + j) = '\0';
				irNv_Item[1] = atoi(cpTemp_Data);
				j = 0;
				iCollect++;
			}
			else if((*(ucpRead_Data + i) == '\r') || (*(ucpRead_Data + i) == '\n'))
			{
				*(cpTemp_Data + j) = '\0';
				iNv_Len = atoi(cpTemp_Data);
				j = 0;
				iCollect++;

				//有换行符标识
				break;
			}
		}//for(i=(ulIndex + ulTemp); i<ulRead_Quan; i++

		//释放临时内存
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpTemp_Data);

		if(iCollect == 3)
		{
			*ip_Max_Item = irNv_Item[1];
			*ip_Max_Len = iNv_Len;

			return true;
		}
		else
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Max_Item_Max_Len_In_AT, Data count (%d) is wrong!"), iCollect);
			this->m_iError_Code = Read_Nv_Max_Item_Max_Len_In_AT_Fail14;
			throw(0);
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return false;
}

bool CARM_OP_QCM::BACKUP_QCN(MBN_FILE_S str_QCN_FILE)
{
	//探测当前通信口类型，确定是以哪种方式来导出QCN文件
	CString csData;
	bool bRtn;
	MBN_FILE_S str_Curr_File;
	int iTemp;
	wchar_t wcrData[8];

	try
	{
		//
		str_QCN_FILE.cs_Path.MakeLower();
		iTemp = str_QCN_FILE.cs_Path.GetLength();

		if(iTemp < 4)
		{
			this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN, QCN file path is wrong!"));
			this->m_iError_Code = BACKUP_QCN_Fail11;
			
			throw(0);
		}

		//提取文件扩展名
		memset(wcrData, 0, sizeof(wcrData));
		wcrData[0] = str_QCN_FILE.cs_Path.GetAt(iTemp - 4);
		wcrData[1] = str_QCN_FILE.cs_Path.GetAt(iTemp - 3);
		wcrData[2] = str_QCN_FILE.cs_Path.GetAt(iTemp - 2);
		wcrData[3] = str_QCN_FILE.cs_Path.GetAt(iTemp - 1);

		//比对文件扩展名
		if(wcscmp(wcrData, _T(".qcn")) == 0)
		{
			iTemp = 1;//QLIB
			str_Curr_File.cs_Path.Format(_T("%s"), str_QCN_FILE.cs_Path);
		}
		else if(wcscmp(wcrData, _T(".qqb")) == 0)
		{
			iTemp = 2;//AT
			str_Curr_File.cs_Path.Format(_T("%s"), str_QCN_FILE.cs_Path);
		}
		else
		{
			iTemp = 0;
			//需要临时切换波特率到115200
			this->COM_PORT_CHANGE_BAUDRATE(115200);

			//打开串口
			if(this->COM_PORT_OPEN() == false)
			{
				csData.Format(_T("%s, BACKUP_QCN, Detect port open!"), this->GET_COM_PORT_ERROR_INFO());
				this->Show_Status(csData);
				this->m_iError_Code = BACKUP_QCN_Fail12;
				m_csError_Code = csData;
				throw(0);
			}

			//往通信口发AT看是否有OK返回，若是UART AT口，则有返回，否则便是QLIB
			bRtn = this->Send_AT_In_AT(2);

			//关闭串口
			this->COM_PORT_CLOSE();

			//
			if(bRtn == true)
			{
				//AT口操作
				iTemp = 2;//AT
				str_Curr_File.cs_Path.Format(_T("%s.qqb"), str_QCN_FILE.cs_Path);

			}
			else
			{
				//QLIB操作
				iTemp = 1;//QLIB
				str_Curr_File.cs_Path.Format(_T("%s.qcn"), str_QCN_FILE.cs_Path);
			}
		}

		//
		str_Curr_File.cs_Name.Format(_T("%s"), str_QCN_FILE.cs_Name);
		str_Curr_File.ul_File_Size = str_QCN_FILE.ul_File_Size;
		str_Curr_File.b_Enable_DL = str_QCN_FILE.b_Enable_DL;

		switch(iTemp)
		{
		case 1://QLIB
			{
				if(this->BACKUP_QCN_QLIB(str_Curr_File) == false)
				{
					throw(0);
				}
			}
			break;
		case 2://AT口导出.qqb文件
			{
				if(this->BACKUP_QCN_IN_AT(str_Curr_File) == false)
				{
					throw(0);
				}
			}
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN, Port type(%d) is wrong!"), iTemp);
			this->m_iError_Code = BACKUP_QCN_Fail13;
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::BACKUP_QCN_IN_AT(MBN_FILE_S str_QCN_FILE)
{
	CString csData;
	int iMax_Item, iMax_Len, i, j, n, iItem, iIndex, iCnt, iP3, iP4;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;
	BYTE ucrHead_Block[3], ucrData_Block[130];
	time_t t_Start, t_End;
	bool bSend_AT, bGet_All_Rsp;
	unsigned char * ucpRx_Buff = NULL;
	unsigned long dwNumb;

	int iQuan_Expected = 20;//每次计划循环发送的item数量
	int iQuan_Item_Send;//每批实际发送的读item数据指令的写数量统计
	int iQuan_Params_Send;//每批实际发送的读item参数指令的写数量统计
	char crTemp_Data[512];//临时存放+QNVR: <data>
	int irN[25], irM[25];//AT+QNVR=<item>[,<index>]
	char * cprItem_Data[25];//+QNVR: <data>
	int irData_Cnt[25];//+QNVR: <data>中data的字符数量
	int irP3[25], irP4[25];//+QNVR: <item>,<presence>,<arraysize>,<itemsize> 

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//需要临时切换波特率到115200
		this->COM_PORT_CHANGE_BAUDRATE(115200);

		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			this->m_csError_Code.Format(_T("%s [Backup qcn in at port open]"), this->GET_COM_PORT_ERROR_INFO());
			this->m_iError_Code = BACKUP_QCN_IN_AT_Fail11;
			throw(0);
		}

		//
		for(i=0; i<iQuan_Expected; i++)
		{
			cprItem_Data[i] = NULL;
		}

		//读NV相关数据
		if(this->Read_Nv_Max_Item_Max_Len_In_AT(&iMax_Item, &iMax_Len) == false)
		{
			throw(0);
		}
		if(iMax_Item <= 0)
		{
			this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Max item (%d) is wrong!"), iMax_Item);
			this->m_iError_Code = BACKUP_QCN_IN_AT_Fail12;
			throw(0);
		}
		if(iMax_Len <= 0)
		{
			this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Max len (%d) is wrong!"), iMax_Len);
			this->m_iError_Code = BACKUP_QCN_IN_AT_Fail13;
			throw(0);
		}


		//打开.qqb文件
		hFile_Handle = ::CreateFile(str_QCN_FILE.cs_Path,
			GENERIC_WRITE,				//文件的操作属性 Read only required
			FILE_SHARE_WRITE,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			CREATE_ALWAYS,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Create %s.qqb file failed!"), str_QCN_FILE.cs_Name);
			this->m_iError_Code = BACKUP_QCN_IN_AT_Fail14;
			throw(0);
		}


		//循环读取item
		n = 0;//item号清零，总循环控制用

		while(n <= iMax_Item)//n是总item号，总循环控制用
		{
			//每批相关参数恢复
			iQuan_Item_Send = 0;
			memset(irN, 0, sizeof(irN));
			memset(irM, 0, sizeof(irM));//所有index从0开始
			memset(irData_Cnt, 0, sizeof(irData_Cnt));

			//-------------------------- 发送“一批”一定数量的读item数据的AT指令 -------------------------- 
			//计算实际发送AT的数量
			for(i=0; i<iQuan_Expected; i++)
			{
				irN[i] = n + i;//每批的item的实际数值，n是起始item号

				if(irN[i] <= iMax_Item)//item实际数据没超标
				{
					iQuan_Item_Send++;//正确的item值，统计实际发送读item data的AT
				}
				else
				{
					break;//item值超标了，退出for
				}
			}//for(i=0; i<iQuan_Expected; i++

			if(iQuan_Item_Send <= 0)//无item指令发出
			{
				break;//退出while
			}

			//清空接收BUFF
			this->Clear_Com_Rx_Buffer();

			//
			bSend_AT = true;//控制是否发送AT
			bGet_All_Rsp = false;//收全rsp响应的标记
			time(&t_Start);
			//
			do
			{
				//检查是否超时
				time(&t_End);
				if((int)difftime(t_End, t_Start) >= 5)
				{
					this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Item send(%d), Read item data timeout!"), iQuan_Item_Send);
					this->m_iError_Code = BACKUP_QCN_IN_AT_Fail15;
					throw(0);
				}

				//发送“读item data”AT，读rsp响应
				for(i=0; i<iQuan_Item_Send; i++)
				{
					//发AT指令
					if((bSend_AT == true) && (irData_Cnt[i] == 0))//Cnt为0代表还没收到读item data的应答（包括重发）
					{
						sprintf_s(crTemp_Data, "AT+QNVR=%d,%d\r", irN[i], irM[i]);
						//发送指令
						this->WRITE_BYTE(crTemp_Data, strlen(crTemp_Data));

						Sleep(10);
					}


					//循环读、解析buff响应
					do
					{
						memset(crTemp_Data, 0, sizeof(crTemp_Data));

						if(this->Get_AT_Nv_Item_Data(&iItem, &iIndex, crTemp_Data, &iCnt) == true)
						{
							//解析到一个数据
							j = iItem - n;//计算该item存储的index号

							if(iCnt <= -1)//该item无数据
							{
								irData_Cnt[j] = iCnt;
							}
							else if(iCnt >= 2)//有数据，至少2位字符
							{
								irData_Cnt[j] = iCnt;

								this->m_cla_GFC.BUFF_CHAR_CALLOC(&cprItem_Data[j], (iCnt + 8));

								sprintf(cprItem_Data[j], "%s", crTemp_Data);
							}
							else
							{
								this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Item(%d, %d) data count(%d) is wrong!"), iItem, iIndex, iCnt);
								this->m_iError_Code = BACKUP_QCN_IN_AT_Fail16;
								throw(0);
							}


							//判断“读item data”的rsp应答是否齐全
							for(j=0; j<iQuan_Item_Send; j++)
							{
								if(irData_Cnt[j] == 0)//Cnt为0代表还没收到读item data的应答，所以继续while循环
								{
									break;//退出for
								}
							}//for(j=0; j<iQuan_Item_Send; j++
							if(j >= iQuan_Item_Send)
							{
								bGet_All_Rsp = true;//收全了rsp
								break;//退出解析while循环
							}
						}
						else
						{
							//没有解析到一个合格的rsp数据，等待一下
							Sleep(5);
							break;//退出解析while循环
						}
					}//循环读、解析buff响应
					while(true);

					//判断是否退出for循环
					if(bGet_All_Rsp == true)
					{
						break;//退出for
					}
				}//for(i=0; i<iQuan_Item_Send; i++


				//检查rsp，判断是继续“读item data”循环，还是退出“读item data”循环
				if(bGet_All_Rsp == true)
				{
					//已收全读item data指令的rsp
					break;//退出while
				}
				else
				{
					time(&t_End);
					if((int)difftime(t_End, t_Start) >= 1)//2秒中后还没收全应答，便要重发AT，difftime是“秒”级的
					{
						//重发未收到应答的AT
						bSend_AT = true;
					}
					else
					{
						//第一次发送后，可停止发AT
						bSend_AT = false;
					}

					continue;//循环while
				}
			}
			while(true);
			//--------------------------


			//-------------------------- 发送需要读item params的AT指令 -------------------------- 
			iQuan_Params_Send = 0;
			memset(irP3, -1, sizeof(irP3));//-1代表“无需”读item params参数
			memset(irP4, -1, sizeof(irP4));

			//计算实际发送AT读item params的数量
			for(i=0; i<iQuan_Item_Send; i++)//发读item参数指令
			{
				if(irData_Cnt[i] >= 2)//有数据，需要读参数
				{
					irP3[i] = -2;//-2代表必须读item params参数，但还没有读到
					irP4[i] = -2;
					iQuan_Params_Send++;
				}
			}

			if(iQuan_Params_Send > 0)//有item params需要读
			{
				//清空接收BUFF
				this->Clear_Com_Rx_Buffer();

				//
				bSend_AT = true;//控制是否发送AT
				bGet_All_Rsp = false;//收全rsp响应的标记
				time(&t_Start);
				//
				do
				{
					//检查是否超时
					time(&t_End);
					if((int)difftime(t_End, t_Start) >= 5)
					{
						this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Read params send(%d) timeout!"), iQuan_Params_Send);
						this->m_iError_Code = BACKUP_QCN_IN_AT_Fail17;
						throw(0);
					}

					//发送AT，读item params rsp响应
					for(i=0; i<iQuan_Item_Send; i++)
					{
						if(irP3[i] == -2)//P3为-2代表需要读item params，但还没应答（包括重发）
						{
							//发“读item params”AT指令
							if(bSend_AT == true)
							{
								sprintf_s(crTemp_Data, "AT+QNVR=%d\r", irN[i]);
								//发送指令
								this->WRITE_BYTE(crTemp_Data, strlen(crTemp_Data));

								Sleep(10);
							}


							//读、解析一次item params rsp响应
							if(this->Get_AT_Nv_Item_Params(&iItem, &iP3, &iP4) == true)
							{
								j = iItem - n;//计算该item存储的index号

								irP3[j] = iP3;
								irP4[j] = iP4;

								//判断rsp应答是否齐全，并检查params值
								for(j=0; j<iQuan_Item_Send; j++)
								{
									if(irP3[j] == -2)//P3为-2代表需要读item params，但还没应答，所以继续while循环
									{
										break;//退出for
									}
									else if(irP3[j] >= 0)//读到params，检查params值
									{
										if(((irP4[j] * 2) != irData_Cnt[j]) || (irP4[j] > 128) || (irData_Cnt[j] > 256))
										{
											this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Item(%d), index(%d), P4(%d), HexCnt(%d), Error 1!"),
												irN[j], irM[j], irP4[j], irData_Cnt[j]);

											this->m_iError_Code = BACKUP_QCN_IN_AT_Fail18;
											throw(0);
										}
									}
								}//for(j=0; j<iQuan_Item_Send; j++
								if(j >= iQuan_Item_Send)
								{
									bGet_All_Rsp = true;//收全了rsp
									break;//退出for
								}
							}
							else
							{
								Sleep(5);
							}
						}//if(irP3[i] == -2，有读params需求的item
					}//for(i=0; i<iQuan_Item_Send; i++


					//检查rsp，判断是继续“读item params”循环，还是退出“读item params”循环
					if(bGet_All_Rsp == true)
					{
						//已收全读item params指令的rsp
						break;//退出while
					}
					else
					{
						time(&t_End);
						if((int)difftime(t_End, t_Start) >= 1)//2秒中后还没收全应答，便要重发AT
						{
							//重发未收到应答的AT
							bSend_AT = true;
						}
						else
						{
							//第一次发送后，可停止发AT
							bSend_AT = false;
						}

						continue;//循环while
					}					
				}
				while(true);

				//data和params收齐了，可以开始保存到文件了
				for(i=0; i<iQuan_Item_Send; i++)
				{
					switch(irP3[i])
					{
					case -1://读item data返回的是ERROR，无需读item params，没有item data数据需要保存到文件
						break;
					case 0://直接保存item data数据到文件
						{
							//打包头数据，ID数据
							ucrHead_Block[0] = 0x26;
							ucrHead_Block[1] = BYTE(irN[i]);
							ucrHead_Block[2] = BYTE(irN[i] >> 8);//((usiCRC16 >> 8) & 0xFF)

							//写头数据，3byte
							if(::WriteFile(hFile_Handle, ucrHead_Block, 3, &dwNumb, NULL) != TRUE)
							{
								this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Write head data fail!"));
								this->m_iError_Code = BACKUP_QCN_IN_AT_Fail19;
								throw(0);
							}

							//载入data数据BUFF
							memset(ucrData_Block, 0, sizeof(ucrData_Block));
							for(j=0; j<irP4[i]; j++)
							{
								ucrData_Block[j] = this->m_cla_GFC.HEX_BYTE_TO_DWORD((unsigned char *)(cprItem_Data[i] + j * 2), 2) & 0xFF;
							}

							//写data数据
							if(::WriteFile(hFile_Handle, ucrData_Block, 128, &dwNumb, NULL) != TRUE)
							{
								this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Write data 1 block fail!"));
								this->m_iError_Code = BACKUP_QCN_IN_AT_Fail110;
								throw(0);
							}

							//释放内存
							this->m_cla_GFC.BUFF_CHAR_FREE(&cprItem_Data[i]);
						}
						break;
					default://若<p3>为非0值，buffer整体后移一个字节，buffer[0]=m，写入文件；然后m加1，继续执行
						{
							//清空接收BUFF
							this->Clear_Com_Rx_Buffer();

							//为了while循环，载入参数
							iCnt = irData_Cnt[i];
							sprintf_s(crTemp_Data, "%s", cprItem_Data[i]);

							//释放内存
							this->m_cla_GFC.BUFF_CHAR_FREE(&cprItem_Data[i]);

							//
							do
							{
								//防止实际读出数据字符数量与params中的数据数量不符
								if(((irP4[i] * 2) != iCnt) || (irP4[i] >= 128) || (iCnt >= 256))
								{
									this->m_csError_Code.Format(_T("ERROR, BACKUP_QCN_IN_AT, Item(%d), index(%d), P4(%d), HexCnt(%d), Error 2!"),
										irN[i], irM[i], irP4[i], iCnt);
									this->m_iError_Code = BACKUP_QCN_IN_AT_Fail111;
									throw(0);
								}

								//打包头数据，ID数据
								ucrHead_Block[0] = 0x26;
								ucrHead_Block[1] = BYTE(irN[i]);
								ucrHead_Block[2] = BYTE(irN[i] >> 8);//((usiCRC16 >> 8) & 0xFF)

								//写头数据，3byte
								if(::WriteFile(hFile_Handle, ucrHead_Block, 3, &dwNumb, NULL) != TRUE)
								{
									this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Write head data fail!"));
									this->m_iError_Code = BACKUP_QCN_IN_AT_Fail112;
									throw(0);
								}

								//清空数据BUFF
								memset(ucrData_Block, 0, sizeof(ucrData_Block));

								//载入index数据
								ucrData_Block[0] = irM[i] & 0xFF;

								//载入data数据
								for(j=0; j<irP4[i]; j++)
								{
									ucrData_Block[j + 1] = 0xFF & this->m_cla_GFC.HEX_BYTE_TO_DWORD((unsigned char *)(&crTemp_Data[j * 2]), 2);
								}

								//写data数据
								if(::WriteFile(hFile_Handle, ucrData_Block, 128, &dwNumb, NULL) != TRUE)
								{
									this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Write data 2 block fail!"));
									this->m_iError_Code = BACKUP_QCN_IN_AT_Fail113;
									throw(0);
								}


								//读下一个index的item data
								irM[i]++;

								//读NV数据
								memset(crTemp_Data, 0, sizeof(crTemp_Data));
								if(this->Read_Nv_Item_Data_In_AT(irN[i], irM[i], crTemp_Data, &iCnt) == false)
								{
									throw(0);
								}

								if(iCnt < 0)//NV无数据, 如果返回ERROR，n加1，m置为0，继续执行
								{
									break;//退出while
								}
								else if((iCnt > 256) || ((iCnt % 2) != 0))//NV数据不正常
								{
									this->m_csError_Code.Format(_T("FAIL, BACKUP_QCN_IN_AT, Nv item %d index %d data count (%d) is wrong!"), irN[i], irM[i], iCnt);
									this->m_iError_Code = BACKUP_QCN_IN_AT_Fail114;
									throw(0);
								}
								else//NV数据有效，可以保存
								{
									continue;
								}
							}
							while(true);
						}
						break;
					}
				}//for(i=0; i<iQuan_Item_Send; i++
			}//有item params需要读
			//-------------------------- 


			//统计有item指令发出
			n += iQuan_Item_Send;

			//进度条显示
			this->Show_Progress((1.0 * n / iMax_Item));

		}//while(n <= iMax_Item


		//关闭文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//
		for(i=0; i<iQuan_Expected; i++)
		{
			this->m_cla_GFC.BUFF_CHAR_FREE(&cprItem_Data[i]);
		}

		//关闭串口
		this->COM_PORT_CLOSE();

		//显示成功信息
		csData.Format(_T("Save nv data as %s successfully. %s"), str_QCN_FILE.cs_Name, str_QCN_FILE.cs_Path);
		this->Show_Status(csData);
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		//关闭文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//
		for(i=0; i<iQuan_Expected; i++)
		{
			this->m_cla_GFC.BUFF_CHAR_FREE(&cprItem_Data[i]);
		}

		//关闭串口
		this->COM_PORT_CLOSE();

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_AT_In_AT(int i_TimeOut)
{
	//用AT指令通过UART口发送AT读OK

	unsigned char ucrAT_Cmd[] = {"ATE1\r\n"};
	unsigned char ucrTgt_Key[] = {"OK"};
	time_t t_Start, t_End;
	unsigned long ulRead_Quan, ulIndex;
	unsigned char * ucpRead_Data = NULL;

	try
	{
		this->Show_Status(_T("Send at in at......"));

		//计时开始
		time(&t_Start);

		//总循环，时间超时控制其退出
		do
		{
			//暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				this->m_iError_Code = Send_AT_In_AT_Fail11;
				throw(0);
			}

			//发送指令
			this->QUERY_BYTE(ucrAT_Cmd, 6, &ucpRead_Data, &ulRead_Quan, 1);

			//有数据
			if(ulRead_Quan >= 2)//有应答
			{
				//有数据则核对目标数据
				//预计回复 OK
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key, 2, &ulIndex) == true)
				{
					return true;
				}
			}

			//超时检测
			time(&t_End);
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Send_AT_In_AT, Query byte timeout!"));
				this->m_iError_Code = Send_AT_In_AT_Fail12;
				throw(0);
			}

			//下次读取的间隔时间
			Sleep(1);
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return false;
}

bool CARM_OP_QCM::Read_Nv_Item_Data_In_AT(int i_Item, int i_Index, char * cp_Item_Data, int * ip_Data_Quan)
{
	//用AT指令通过UART口读模块最大NV item数量和最大
	char crAt_Cmd[32];
	CString csData;
	unsigned long ulTemp, ulRead_Quan, ulIndex, i, j;
	unsigned char * ucpRead_Data = NULL;
	unsigned char ucrData_Key[] = {"+QNVR: \""};

	/*
	[2013-12-25_17:18:00]AT+QNVR=0,0
	[2013-12-25_17:18:00]+QNVR: "00000000"

	[2013-12-25_17:18:00]OK

	[2013-12-25_17:18:02]AT+QNVR=0
	[2013-12-25_17:18:02]+QNVR: 0,1,0,4

	[2013-12-25_17:18:02]OK

	[2013-12-25_17:18:05]AT+QNVR=1,0
	[2013-12-25_17:18:05]+QNVR: "FFFFFFFF"

	[2013-12-25_17:18:05]OK

	[2013-12-25_17:18:08]AT+QNVR=1
	[2013-12-25_17:18:08]+QNVR: 1,1,0,4

	[2013-12-25_17:18:08]OK
	*/

	try
	{
		csData.Format(_T("Read Nv item %d - %d"), i_Item, i_Index);
		this->Show_Status(csData);

		//打包AT切换指令
		sprintf_s(crAt_Cmd, "AT+QNVR=%d,%d\r\n", i_Item, i_Index);
		ulTemp = strlen(crAt_Cmd);

		//发送指令
		this->QUERY_BYTE((unsigned char *)crAt_Cmd, ulTemp, &ucpRead_Data, &ulRead_Quan, 2);

		//无数据
		if(ulRead_Quan <= 0)//无应答
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Data_In_AT, No data!"));
			this->m_iError_Code = Read_Nv_Item_Data_In_AT_Fail11;
			throw(0);
		}

		//有数据则核对目标数据
		if(strstr((char *)ucpRead_Data, "ERROR") != NULL)//有ERROR返回，代表该item无数据，函数返回
		{
			*ip_Data_Quan = -1;
			return true;
		}

		//预计回复 OK
		if(strstr((char *)ucpRead_Data, "OK") == NULL)//无OK，不正常
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Data_In_AT, No rsp ok data!"));
			this->m_iError_Code = Read_Nv_Item_Data_In_AT_Fail12;
			throw(0);
		}

		//预计回复 +QNVR: "00000000"
		ulTemp = 8;
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrData_Key, ulTemp, &ulIndex) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Data_In_AT, No right key data!"));
			this->m_iError_Code = Read_Nv_Item_Data_In_AT_Fail13;
			throw(0);
		}


		//
		j = 0;

		for(i=(ulIndex + ulTemp); i<ulRead_Quan; i++)
		{
			if(*(ucpRead_Data + i) == '\"')
			{
				*(cp_Item_Data + j) = '\0';
				*ip_Data_Quan = j;
				break;
			}
			else
			{
				*(cp_Item_Data + j) = *(ucpRead_Data + i);
				j++;
			}
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Read_Nv_Item_Params_In_AT(int i_Item, int * ip_Array_Size, int * ip_Item_Size)
{
	//用AT指令通过UART口读模块最大NV item数量和最大
	char crAt_Cmd[32], crData[64];
	CString csData;
	int iCnt, irData[5];
	unsigned long ulTemp, ulRead_Quan, ulIndex, i, j;
	unsigned char * ucpRead_Data = NULL;
	unsigned char ucrData_Key[] = {"+QNVR:"};

	/*
	[2013-12-25_17:18:00]AT+QNVR=0,0
	[2013-12-25_17:18:00]+QNVR: "00000000"

	[2013-12-25_17:18:00]OK

	[2013-12-25_17:18:02]AT+QNVR=0
	[2013-12-25_17:18:02]+QNVR: 0,1,0,4

	[2013-12-25_17:18:02]OK

	[2013-12-25_17:18:05]AT+QNVR=1,0
	[2013-12-25_17:18:05]+QNVR: "FFFFFFFF"

	[2013-12-25_17:18:05]OK

	[2013-12-25_17:18:08]AT+QNVR=1
	[2013-12-25_17:18:08]+QNVR: 1,1,0,4

	[2013-12-25_17:18:08]OK
	*/

	try
	{
		//打包AT切换指令
		sprintf_s(crAt_Cmd, "AT+QNVR=%d\r\n", i_Item);
		ulTemp = strlen(crAt_Cmd);

		//发送指令
		this->QUERY_BYTE((unsigned char *)crAt_Cmd, ulTemp, &ucpRead_Data, &ulRead_Quan, 2);

		//无数据
		if(ulRead_Quan <= 0)//无应答
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Params_In_AT, No data!"));
			this->m_iError_Code = Read_Nv_Item_Params_In_AT_Fail11;

			throw(0);
		}

		//预计回复 OK
		if(strstr((char *)ucpRead_Data, "OK") == NULL)//无OK，不正常
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Params_In_AT, No rsp ok data!"));
			this->m_iError_Code = Read_Nv_Item_Params_In_AT_Fail12;
			throw(0);
		}

		//预计回复 +QNVR: 1,1,0,4
		ulTemp = 6;
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrData_Key, ulTemp, &ulIndex) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Params_In_AT, No right key data!"));
			this->m_iError_Code = Read_Nv_Item_Params_In_AT_Fail13;
			throw(0);
		}

		//
		j = 0;
		iCnt = 0;

		for(i=(ulIndex + ulTemp); i<ulRead_Quan; i++)
		{
			if((*(ucpRead_Data + i) == ',') || (*(ucpRead_Data + i) == '\r') || (*(ucpRead_Data + i) == '\n'))
			{
				crData[j] = '\0';

				irData[iCnt] = atoi(crData);

				j = 0;
				iCnt++;
			}
			else if((*(ucpRead_Data + i) >= '0') && (*(ucpRead_Data + i) <= '9'))
			{
				crData[j] = *(ucpRead_Data + i);
				j++;
			}

			//
			if((*(ucpRead_Data + i) == '\r') || (*(ucpRead_Data + i) == '\n') || (iCnt == 4))
			{
				break;
			}
		}//for(i=(ulIndex + ulTemp); i<ulRead_Quan; i++

		//
		if(iCnt == 4)
		{
			*ip_Array_Size = irData[2];
			*ip_Item_Size = irData[3];
		}
		else
		{
			this->m_csError_Code.Format(_T("FAIL, Read_Nv_Item_Params_In_AT, Params count (%d) is wrong!"), iCnt);
			this->m_iError_Code = Read_Nv_Item_Params_In_AT_Fail14;
			throw(0);
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_AT_Nv_Item_Data(int * ip_Item, int * ip_Index, char * cp_Item_Data, int * ip_Data_Quan)
{
	unsigned char ucrKey_Head[] = {"AT+QNVR="};
	unsigned char ucrKey_Data[] = {"+QNVR: \""};
	unsigned char ucrKey_Err[] = {"ERROR"};
	unsigned char * ucpRx_Buff = NULL;
	unsigned long ulRx_Quan, i, j;
	char crData[512];
	int iResult;
	int iItem_ID = -1;
	int iIndex_ID = -1;
	CString csData;
	bool bGet_Key_End = false;//从关键词开始往后找，找到\r\n代表关键词数据段结束

	/*
	AT+QNVR=18,0...+QNVR: "0000"....OK..
	41 54 2B 51 4E 56 52 3D    31 38 2C 30    0D 0D 0A    2B 51 4E 56 52 3A 20 22 30 30 30 30 22    0D 0A 0D 0A    4F 4B    0D 0A
	AT+QNVR=19,0...ERROR..	
	41 54 2B 51 4E 56 52 3D    31 39 2C 30    0D 0D 0A    45 52 52 4F 52    0D 0A

	//还要防止有读params的响应混入
	AT+QNVR=880,0.	
	AT+QNVR=876...+QNVR: 876,1,0,1....OK..AT+QNVR=880,0...+QNVR: "01"....OK..
	AT+QNVR=881,0.	
	*/

	try
	{
		//读响应数据
		this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);

		//找"AT+QNVR="带item和index数据的字头
		if(this->m_cla_GFC.mem_uc_str(ucpRx_Buff, ulRx_Quan, ucrKey_Head, 8, &i) == false)
		{
			throw(0);//无数据
		}

		//
		memset(crData, 0, sizeof(crData));
		j = 0;

		//搜索"AT+QNVR="解析item和index数据
		for(i=(i + 8); i<ulRx_Quan; i++)
		{
			if((*(ucpRx_Buff + i) >= '0') && (*(ucpRx_Buff + i) <= '9'))
			{
				crData[j] = *(ucpRx_Buff + i);
				j++;
			}
			else if(*(ucpRx_Buff + i) == ',')//item数据
			{
				if(j > 0)
				{
					crData[j] = '\0';
					iItem_ID = atoi(crData);

					memset(crData, 0, sizeof(crData));
					j = 0;
				}
			}
			else if((*(ucpRx_Buff + i) == '\r') || (*(ucpRx_Buff + i) == '\n'))//index数据
			{
				bGet_Key_End = true;//找到数据段的结束

				if(j > 0)
				{
					crData[j] = '\0';
					iIndex_ID = atoi(crData);

					break;
				}
			}
		}//for(i=(i + 8); i<ulRx_Quan; i++


		//判断关键词数据段
		if(bGet_Key_End == true)
		{
			//数据段结束了
			if((iItem_ID < 0) || (iIndex_ID < 0))
			{
				//无item或index数据，则代表这个数据段不是可以解析的数据段，可以删除
				this->DEL_BYTE(i + 1);
				throw(0);
			}
		}
		else
		{
			//数据段没有结束
			throw(0);
		}


		//去掉中间的\r\n
		for(i=(i + 1); i<ulRx_Quan; i++)
		{
			if((*(ucpRx_Buff + i) == '\r') || (*(ucpRx_Buff + i) == '\n'))
			{
				continue;
			}
			else
			{
				break;//发现非换行字符，退出
			}
		}

		//检测接下来一段数据
		iResult = -1;

		if(*(ucpRx_Buff + i) == 'E')
		{
			if(this->m_cla_GFC.mem_uc_str((ucpRx_Buff + i), (ulRx_Quan - i), ucrKey_Err, 5, &j) == true)
			{
				if(j == 0)
				{
					//ERROR有目标数据
					iResult = 2;
				}
			}
		}
		else if(*(ucpRx_Buff + i) == '+')
		{
			if(this->m_cla_GFC.mem_uc_str((ucpRx_Buff + i), (ulRx_Quan - i), ucrKey_Data, 8, &j) == true)
			{
				if(j == 0)
				{
					//+QNVR: "0000"....OK..有目标数据
					iResult = 1;
				}
			}
		}
		
		//判断是否找到数据
		switch(iResult)
		{
		case 1://有+QNVR:目标数据，但也有可能数据不完整，做无数据处理
			{
				memset(crData, 0, sizeof(crData));
				j = 0;

				for(i=(i + 8); i<ulRx_Quan; i++)
				{
					if(*(ucpRx_Buff + i) == '\"')
					{
						crData[j] = '\0';
						break;
					}
					else
					{
						crData[j] = *(ucpRx_Buff + i);
						j++;
					}
				}

				if(i < ulRx_Quan)//找到完整数据
				{
					sprintf(cp_Item_Data, "%s", crData);
					*ip_Data_Quan = j;
				}
				else
				{
					throw(0);
				}
			}
			break;
		case 2://ERROR有目标数据
			{
				*ip_Data_Quan = -1;
			}
			break;
		default:
			throw(0);//没找到数据
		}

		//去掉已提取的一段数据
		this->DEL_BYTE(i + 1);

		//返回数据
		*ip_Item = iItem_ID;
		*ip_Index = iIndex_ID;
		//
		csData.Format(_T("Read Nv item %d - %d"), iItem_ID, iIndex_ID);
		this->Show_Status(csData);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::DEL_BYTE(unsigned long ul_Del_Quan)
{
	//删除串口BUFF中的byte数据量
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		{
			this->m_cla_GFC.PKT_BUFF_DEL_DATA(&this->m_cla_Com_Port.m_str_Com_Rx_Buff, ul_Del_Quan);
		}
		break;
	case COMM_OVERLAPPED:
		{
			this->m_cla_Com_Thr_Port.Buffer_Del_Data(&this->m_cla_Com_Thr_Port.m_str_COM.recvBuffer, ul_Del_Quan);			
		}
		break;
	default:
		::AfxMessageBox(_T("FAIL, DEL_BYTE, Comm type error!"));
		break;
	}
}

bool CARM_OP_QCM::Get_AT_Nv_Item_Params(int * ip_Item, int * ip_P3, int * ip_P4)
{
	unsigned char ucrKey_Data[] = {"+QNVR:"};
	unsigned char * ucpRx_Buff = NULL;
	unsigned long ulRx_Quan, i, j;
	char crData[128];
	int irData[5], iCnt;

	/*
	[2013-12-25_17:18:02]AT+QNVR=0
	[2013-12-25_17:18:02]+QNVR: 0,1,0,4

	[2013-12-25_17:18:02]OK

	[2013-12-25_17:18:08]AT+QNVR=1
	[2013-12-25_17:18:08]+QNVR: 1,1,0,4

	[2013-12-25_17:18:08]OK

	//还要防止有读params的响应混入
	AT+QNVR=880,0.	
	AT+QNVR=876...+QNVR: 876,1,0,1....OK..AT+QNVR=880,0...+QNVR: "01"....OK..
	AT+QNVR=881,0.	
	*/

	try
	{
		//读响应数据
		this->READ_BYTE(&ucpRx_Buff, &ulRx_Quan);

		//找"+QNVR: 1,1,0,4"数据的字头
		if(this->m_cla_GFC.mem_uc_str(ucpRx_Buff, ulRx_Quan, ucrKey_Data, 6, &i) == false)
		{
			throw(0);//无数据
		}

		//
		memset(crData, 0, sizeof(crData));
		memset(irData, 0, sizeof(irData));
		j = 0;
		iCnt = 0;

		//搜索"+QNVR: 1,1,0,4"解析item参数数据
		for(i=(i + 6); i<ulRx_Quan; i++)
		{
			if((*(ucpRx_Buff + i) == ',') || (*(ucpRx_Buff + i) == '\r') || (*(ucpRx_Buff + i) == '\n'))
			{
				//逗号和换行符代表数据结束
				crData[j] = '\0';

				irData[iCnt] = atoi(crData);

				j = 0;
				iCnt++;
			}
			else if((*(ucpRx_Buff + i) >= '0') && (*(ucpRx_Buff + i) <= '9'))
			{
				crData[j] = *(ucpRx_Buff + i);
				j++;
			}
			else if(*(ucpRx_Buff + i) == ' ')
			{
				continue;//空格键忽略
			}
			else
			{
				/*
				this->m_csError_Code.Format(_T("Get_AT_Nv_Item_Params, error char = [%d]"), *(ucpRx_Buff + i));
				::AfxMessageBox(this->m_csError_Code);
				*/
				//其他字符便是不正常，可以删除这段数据
				this->DEL_BYTE(i + 1);
				throw(0);
			}

			//
			if((*(ucpRx_Buff + i) == '\r') || (*(ucpRx_Buff + i) == '\n') || (iCnt == 4))
			{
				break;
			}
		}//for(i=(i + 6); i<ulRx_Quan; i++

		//
		if(iCnt == 4)
		{
			*ip_Item = irData[0];
			*ip_P3 = irData[2];
			*ip_P4 = irData[3];
		}
		else
		{
			this->m_csError_Code.Format(_T("FAIL, Get_AT_Nv_Item_Params, Params count (%d) is wrong!"), iCnt);
			this->m_iError_Code = Get_AT_Nv_Item_Params_Fail1;
			throw(0);
		}

		//去掉已提取的一段数据
		this->DEL_BYTE(i + 1);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::RESTORE_QCN(MBN_FILE_S str_QCN_FILE_1, MBN_FILE_S str_QCN_FILE_2)
{
	//探测当前通信口类型，确定是以哪种方式来导出QCN文件

	CString csData;
	bool bRtn;
	MBN_FILE_S str_Curr_File, str_Temp_File;
	int iTemp;
	wchar_t wcrData[8];

	try
	{
		//
		str_Temp_File.cs_Path.Format(_T(""));

		if(this->m_bQCN_RESTORE == true)
		{
			str_Temp_File.cs_Name.Format(_T("%s"), str_QCN_FILE_1.cs_Name);
			str_Temp_File.cs_Path.Format(_T("%s"), str_QCN_FILE_1.cs_Path);
			str_Temp_File.ul_File_Size = str_QCN_FILE_1.ul_File_Size;
			str_Temp_File.b_Enable_DL = str_QCN_FILE_1.b_Enable_DL;
		}
		if(this->m_bQCN_DL == true)
		{
			str_Temp_File.cs_Name.Format(_T("%s"), str_QCN_FILE_2.cs_Name);
			str_Temp_File.cs_Path.Format(_T("%s"), str_QCN_FILE_2.cs_Path);
			str_Temp_File.ul_File_Size = str_QCN_FILE_2.ul_File_Size;
			str_Temp_File.b_Enable_DL = str_QCN_FILE_2.b_Enable_DL;
		}


		str_Temp_File.cs_Path.MakeLower();
		iTemp = str_Temp_File.cs_Path.GetLength();

		if(iTemp < 4)
		{
			this->m_csError_Code.Format(_T("ERROR, RESTORE_QCN, QCN file path is wrong!"));
			this->m_iError_Code = RESTORE_QCN_Fail1;
			throw(0);
		}

		//提取文件扩展名
		memset(wcrData, 0, sizeof(wcrData));
		wcrData[0] = str_Temp_File.cs_Path.GetAt(iTemp - 4);
		wcrData[1] = str_Temp_File.cs_Path.GetAt(iTemp - 3);
		wcrData[2] = str_Temp_File.cs_Path.GetAt(iTemp - 2);
		wcrData[3] = str_Temp_File.cs_Path.GetAt(iTemp - 1);

		//比对文件扩展名
		if(wcscmp(wcrData, _T(".qcn")) == 0)
		{
			iTemp = 1;//QLIB
			str_Curr_File.cs_Path.Format(_T("%s"), str_Temp_File.cs_Path);
		}
		else if(wcscmp(wcrData, _T(".qqb")) == 0)
		{
			iTemp = 2;//AT
			str_Curr_File.cs_Path.Format(_T("%s"), str_Temp_File.cs_Path);
		}
		else
		{
			iTemp = 0;
			//需要探测
			//需要临时切换波特率到115200
			this->COM_PORT_CHANGE_BAUDRATE(115200);

			//打开串口
			if(this->COM_PORT_OPEN() == false)
			{
				this->m_csError_Code.Format(_T("%s, RESTORE_QCN, Detect port open"), this->GET_COM_PORT_ERROR_INFO());
				this->m_iError_Code = RESTORE_QCN_Fail2;
				throw(0);
			}

			//往通信口发AT看是否有OK返回，若是UART AT口，则有返回，否则便是QLIB
			bRtn = this->Send_AT_In_AT(4);

			//关闭串口
			this->COM_PORT_CLOSE();

			//
			if(bRtn == true)
			{
				//AT口操作
				iTemp = 2;//AT
				str_Curr_File.cs_Path.Format(_T("%s.qqb"), str_Temp_File.cs_Path);
				
			}
			else
			{
				//QLIB操作
				iTemp = 1;//QLIB
				str_Curr_File.cs_Path.Format(_T("%s.qcn"), str_Temp_File.cs_Path);
			}
		}

		//
		str_Curr_File.cs_Name.Format(_T("%s"), str_Temp_File.cs_Name);
		str_Curr_File.ul_File_Size = str_Temp_File.ul_File_Size;
		str_Curr_File.b_Enable_DL = str_Temp_File.b_Enable_DL;

		switch(iTemp)
		{
		case 1://QLIB
			{
				if(this->RESTORE_QCN_QLIB(str_QCN_FILE_1, str_QCN_FILE_2) == false)
				{
					throw(0);
				}
			}
			break;
		case 2://AT
			{
				if(this->RESTORE_QCN_IN_AT(str_Curr_File) == false)
				{
					throw(0);
				}
			}
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, RESTORE_QCN, Port type(%d) is wrong!"), iTemp);
			this->m_iError_Code = RESTORE_QCN_Fail3;
			throw(0);
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::RESTORE_QCN_IN_AT(MBN_FILE_S str_QCN_FILE)
{
	CString csData, csTemp;
	int iMax_Item, iMax_Len, iItem_Curr, iItem_Last, iIndex, iP3, iP4, i;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;
	BYTE ucrData_Block[132];
	unsigned long ulActual_Read;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//需要临时切换波特率到115200
		this->COM_PORT_CHANGE_BAUDRATE(115200);

		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			this->m_csError_Code.Format(_T("%s, RESTORE_QCN_IN_AT"), this->GET_COM_PORT_ERROR_INFO());
			this->m_iError_Code = RESTORE_QCN_IN_AT_Fail1;
			throw(0);
		}

		//读NV相关数据
		if(this->Read_Nv_Max_Item_Max_Len_In_AT(&iMax_Item, &iMax_Len) == false)
		{
			throw(0);
		}
		if(iMax_Item <= 0)
		{
			this->m_csError_Code.Format(_T("ERROR, RESTORE_QCN_IN_AT, Max item(%d) is wrong!"), iMax_Item);
			this->m_iError_Code = RESTORE_QCN_IN_AT_Fail2;
			throw(0);
		}
		if(iMax_Len <= 0)
		{
			this->m_csError_Code.Format(_T("ERROR, RESTORE_QCN_IN_AT, Max len(%d) is wrong!"), iMax_Len);
			this->m_iError_Code = RESTORE_QCN_IN_AT_Fail3;
			throw(0);
		}


		//打开.qqb文件
		hFile_Handle = ::CreateFile(str_QCN_FILE.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, RESTORE_QCN_IN_AT, Open %s.qqb file failed!"), str_QCN_FILE.cs_Name);
			this->m_iError_Code = RESTORE_QCN_IN_AT_Fail4;
			throw(0);
		}


		//循环读文件，导入NV参数
		iItem_Last = -1;
		do
		{
			//读131个数据
			memset(ucrData_Block, 0, sizeof(ucrData_Block));

			if(::ReadFile(hFile_Handle, ucrData_Block, 131, &ulActual_Read, NULL) != TRUE)
			{
				this->m_csError_Code.Format(_T("FAIL, RESTORE_QCN_IN_AT, Read qqb file failed!"));
				this->m_iError_Code = RESTORE_QCN_IN_AT_Fail5;
				throw(0);
			}

			//
			if(ulActual_Read == 0)
			{
				break;//退出while
			}
			else if(ulActual_Read != 131)
			{
				this->m_csError_Code.Format(_T("FAIL, RESTORE_QCN_IN_AT, Read qqb file byte(%d) is wrong!"), ulActual_Read);
				this->m_iError_Code = RESTORE_QCN_IN_AT_Fail6;
				throw(0);
			}

			//
			if(ucrData_Block[0] != 0x26)
			{
				this->m_csError_Code.Format(_T("FAIL, RESTORE_QCN_IN_AT, QQB file head byte(0x%X) is wrong!"), ucrData_Block[0]);
				this->m_iError_Code = RESTORE_QCN_IN_AT_Fail7;
				throw(0);
			}

			//获取nv item号
			iItem_Curr = ucrData_Block[2] & 0xFF;
			iItem_Curr = iItem_Curr << 8;
			iItem_Curr |= ucrData_Block[1] & 0xFF;
			iItem_Curr &= 0xFFFF;

			if(iItem_Curr != iItem_Last)//全新的item，需要读参数
			{
				//读参数
				if(this->Read_Nv_Item_Params_In_AT(iItem_Curr, &iP3, &iP4) == false)
				{
					throw(0);
				}

				//
				iItem_Last = iItem_Curr;
			}


			//
			csData.Format(_T(""));

			if(iP3 != 0)
			{
				iIndex = ucrData_Block[3] & 0xFF;

				for(i=0; i<iP4; i++)
				{
					csTemp.Format(_T("%02X"), ucrData_Block[4 + i]);
					csData += csTemp;
				}
			}
			else
			{
				iIndex = 0;

				for(i=0; i<iP4; i++)
				{
					csTemp.Format(_T("%02X"), ucrData_Block[3 + i]);
					csData += csTemp;
				}
			}


			//写item数据
			if(this->Write_Nv_Item_Data_In_AT(iItem_Curr, iIndex, csData) == false)
			{
				throw(0);
			}


			//进度条显示
			this->Show_Progress((1.0 * iItem_Curr / iMax_Item));
		}
		while(true);


		//关闭文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//关闭串口
		this->COM_PORT_CLOSE();

		//显示成功信息
		this->Show_Status(_T("Restore nv data to module successfully"));
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		//关闭串口
		this->COM_PORT_CLOSE();

		//关闭文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Write_Nv_Item_Data_In_AT(int i_Item, int i_Index, const wchar_t * wcp_Item_Data)
{
	char crAt_Cmd[512];
	unsigned char * ucpRead_Data = NULL;
	unsigned long ulTemp, ulRead_Quan;
	int iTemp;
	CString csData;

	try
	{
		//
		csData.Format(_T("Write Nv item %d - %d"), i_Item, i_Index);
		this->Show_Status(csData);

		//打包AT切换指令
		csData.Format(_T("AT+QNVW=%d,%d,\"%s\"\r"), i_Item, i_Index, wcp_Item_Data);
		
		this->m_cla_GFC.WideChar_To_MultiByte(csData, crAt_Cmd, &iTemp);
		ulTemp = strlen(crAt_Cmd);


		//发送指令
		this->QUERY_BYTE((unsigned char *)crAt_Cmd, ulTemp, &ucpRead_Data, &ulRead_Quan, 3);

		//无数据
		if(ulRead_Quan <= 0)//无应答
		{
			this->m_csError_Code.Format(_T("FAIL, Write_Nv_Item_Data_In_AT, Item(%d) index(%d) no data!"), i_Item, i_Index);
			this->m_iError_Code = Write_Nv_Item_Data_In_AT_Fail1;
			throw(0);
		}

		//有数据则核对目标数据
		if(strstr((char *)ucpRead_Data, "OK") != NULL)//有OK返回
		{
			return true;
		}

		if(strstr((char *)ucpRead_Data, "ERROR") != NULL)//有ERROR返回
		{
			return true;
			/*
			this->m_csError_Code.Format(_T("FAIL, Write_Nv_Item_Data_In_AT, Item(%d) index(%d) error rsp!"), i_Item, i_Index);
			throw(0);
			*/
		}

		//
		this->m_csError_Code.Format(_T("FAIL, Write_Nv_Item_Data_In_AT, Item(%d) index(%d) no right rsp!"), i_Item, i_Index);
		this->m_iError_Code = Write_Nv_Item_Data_In_AT_Fail2;
	}
	catch(...)
	{
		return false;
	}

	return false;
}

bool CARM_OP_QCM::SCAN_NEW_COM_PORT(const int i_Tgt_Com_Port, int * ip_New_Com_Port, int i_TimeOut)
{
	//扫描消失后重新生成的COM口

	int irPort_Buff[128];
	int iPort_Buff_Quan;
	int irPort_Min[128];
	int iPort_Min_Quan;
	time_t t_Start, t_End;
	bool bReset_Flag = false;
	int i, j;
	CString csData;

	try
	{
		//
		memset(irPort_Min, 0, sizeof(irPort_Min));
		iPort_Min_Quan = 0;
		//
		if(this->m_cla_GFC.Get_Reg_Com_Port_List(irPort_Min, &iPort_Min_Quan) == false)
		{
			this->m_csError_Code.Format(_T("FAIL, SCAN_NEW_COM_PORT, Read reg fail!"));
			this->m_iError_Code = SCAN_NEW_COM_PORT_Fail1;
			throw(0);
		}


		//开始计时
		time(&t_Start);
		//
		do
		{
			//
			memset(irPort_Buff, 0, sizeof(irPort_Buff));
			iPort_Buff_Quan = 0;
			//
			if(this->m_cla_GFC.Get_Reg_Com_Port_List(irPort_Buff, &iPort_Buff_Quan) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, SCAN_NEW_COM_PORT, Read reg fail!"));
				this->m_iError_Code = SCAN_NEW_COM_PORT_Fail2;
				throw(0);
			}

			//保留COM口最少时的状态
			if(iPort_Buff_Quan < iPort_Min_Quan)
			{
				memset(irPort_Min, 0, sizeof(irPort_Min));
				iPort_Min_Quan = iPort_Buff_Quan;

				for(i=0; i<iPort_Buff_Quan; i++)
				{
					irPort_Min[i] = irPort_Buff[i];
				}
			}

			//
			if(bReset_Flag == false)
			{
				//检查目标COM口是否消失了，说明模块成功关闭了
				for(i=0; i<iPort_Buff_Quan; i++)
				{
					if(i_Tgt_Com_Port == irPort_Buff[i])
					{
						break;
					}
				}
				if(i >= iPort_Buff_Quan)
				{
					bReset_Flag = true;
				}
			}
			else
			{
				//检查目标COM口是否又出现了，说明模块成功重启了
				for(i=0; i<iPort_Buff_Quan; i++)
				{
					if(i_Tgt_Com_Port == irPort_Buff[i])
					{
						*ip_New_Com_Port = -1;//目标COM口号未变
						return true;//目标COM口再次出现，pass
					}
				}
			}

			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)//超时，报fail
			{
				//如果有一个口“新生成”或口“数量不变”，哪怕不是目标口，也可返回pass
				if((iPort_Buff_Quan == (iPort_Min_Quan + 1)) || (iPort_Buff_Quan == iPort_Min_Quan))
				{
					for(i=0; i<iPort_Buff_Quan; i++)
					{
						for(j=0; j<iPort_Min_Quan; j++)
						{
							if(irPort_Buff[i] == irPort_Min[j])
							{
								break;
							}
						}

						if(j >= iPort_Min_Quan)//找到新生成的COM口号
						{
							*ip_New_Com_Port = irPort_Buff[i];//目标COM口号未变

							return true;
						}
					}

					if(i >= iPort_Buff_Quan)
					{
						this->m_csError_Code.Format(_T("ERROR, SCAN_NEW_COM_PORT, No new com port!"));
						this->m_iError_Code = SCAN_NEW_COM_PORT_Fail3;
						throw(0);
					}
				}
				else
				{
					this->m_csError_Code.Format(_T("FAIL, SCAN_NEW_COM_PORT, Time out!"));
					this->m_iError_Code = SCAN_NEW_COM_PORT_Fail4;
					throw(0);
				}
			}

			//
			csData.Format(_T("Scan new com port ...... %d"), (i_TimeOut - (int)difftime(t_End, t_Start)));
			this->Show_Status(csData);

			Sleep(5);//这个延迟如果太长的话，会扫描不到“COM口最少的时刻”和“目标口消失的时刻”
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return false;
}

bool CARM_OP_QCM::LOAD_BB_INFO(const wchar_t * wcp_FW_File_Path)
{
	//从加载的FW文件夹中，判断下载的芯片平台
	CString cs_FW_Dir, cs_Finder_Dir, cs_FW_Name;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	bool bRtn = false;

	if (_T("QDE006EUEF-N06-AAAAA") == m_csOC)//QDE006 MCU2的固件版本
	{
		this->m_eu_BB_Chip = MDM9X07;
		this->m_eu_Memory_Type = NAND;
		return true;
	}

	if (NULL != wcsstr(m_csOC, _T("QDM041"))) //20221117
	{
		this->m_eu_BB_Chip = MDM9X05;
		this->m_eu_Memory_Type = NAND;
		return true;
	}

	//20230628
	CString temp = _T("");
	temp.Format(_T("m_eu_BB_Chip: %d"), m_iBBchip_Curr);
	this->Show_Out(temp);

	if (m_iBBchip_Curr == 118)
	{
		this->m_eu_BB_Chip = Chip_MCU;
		return true;
	}
	else if (m_iBBchip_Curr == 119)
	{
		this->m_eu_BB_Chip = Chip_ESP32;
		return true;
	}

	//20221210
	if (NULL != wcsstr(m_csOC, _T("QDC002"))
		|| m_csOC == _T("QDC004EAXC-I01-AAAAA") 
		|| m_csOC == _T("QDC004EAXD-TI-AAAAA") 
		|| _T("QDC519SASE-E53-A2SUB") == m_csOC ///税控板

		||_T("QDC519SASE-E53-AAASM") == m_csOC
		|| _T("QDC519SASE-E53-BAASM") == m_csOC
		|| _T("QDC519SASE-E53-CAASM") == m_csOC
		|| _T("QDC519SASE-E53-DAASM") == m_csOC

		|| _T("QDC519SASE-E53-AAAAA") == m_csOC
		|| _T("QDC519SASE-E53-BAAAA") == m_csOC
		|| _T("QDC519SASE-E53-CAAAA") == m_csOC
		|| _T("QDC519SASE-E53-DAAAA") == m_csOC

		|| _T("QDC518GLSD-U60-AABAS") == m_csOC //底座
		|| _T("QDC518GLSD-U60-BABAS") == m_csOC //底座   
		|| _T("QDC523SPSW-U67-AAAAA") == m_csOC //底座   
		|| NULL != wcsstr(m_csOC, _T("QDM027"))
		|| _T("QDM062EABL-D08-AAAAA") == m_csOC
		|| _T("QDM042AUBL-D01-AAAAA") == m_csOC
		|| _T("QDM063EABA-N06-AAAAA") == m_csOC //
		|| _T("QDM063EABA-N06-AAASM") == m_csOC //QDM063EABA-N06-AAASM
		|| _T("QDE016EAEF-F81-AAAAA") == m_csOC
		|| _T("QDE016EAEF-F81-BAAAA") == m_csOC
		|| _T("QDM066EPBK-I03-AAAAA") == m_csOC
		)
	{
		this->m_eu_BB_Chip = Chip_MCU;
		return true;
	}

	if (NULL != wcsstr(m_csOC, _T("QDM021"))
		|| _T("QDM064EART-G55-AAAAA") == m_csOC
		|| _T("QDM064EART-1G4-AAAAA") == m_csOC
		|| _T("QDM064EART-2G4-AAAAA") == m_csOC 
		|| _T("QDM064EART-2G4-BAAAA") == m_csOC 
		|| _T("QDM065EABA-N06-AAAAA") == m_csOC
		|| _T("QDM054EARN-NA-AAAAA") == m_csOC
		|| _T("QDM054EARN-EU-AAAAA") == m_csOC
		|| _T("QDM548EAEF-EU-AAASM") == m_csOC
		)
	{
		this->m_eu_BB_Chip = Chip_ESP32;
		return true;
	}


	//20220221
	//QDM002NAEF-D10-CAAAA
	//QDM002EUEF-D10-CAAAA
	//QDM002GLEF-M21-AAAAA
	if (NULL != wcsstr(m_csOC, _T("QDM002")))
	{
		this->m_eu_BB_Chip = MDM9X07;
		this->m_eu_Memory_Type = NAND;
		return true;
	}

	if (NULL != wcsstr(m_csOC, _T("QDM040"))
		|| NULL != wcsstr(m_csOC, _T("QDM059"))
		)
	{
		this->m_eu_BB_Chip = SDX62;
		this->m_eu_Memory_Type = NAND;
		return true;
	}

	try
	{
		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			this->m_iError_Code = LOAD_BB_INFO_Fail1;
			this->Show_Out(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		//
		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//大写

				//如果是.BIN文件
				//if (wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				//{
				//	if (true == this->m_bQDM002_flag)
				//	{
				//		this->m_eu_BB_Chip = QDM002;
				//		bRtn = true;
				//		break;
				//	}
				//}


				//如果是.hex文件
				if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL)
				{
					if(wcsstr(cs_FW_Name, _T("PRG6695")) != NULL)
					{
						this->m_eu_BB_Chip = MDM6X00;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("PRG6270")) != NULL)
					{
						this->m_eu_BB_Chip = QSC6270;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("PRG9X15")) != NULL)
					{
						this->m_eu_BB_Chip = MDM9X15;
						bRtn = true;
						break;
					}
					else if(true == this->m_bHoneywell_A4_flag)
					{
						this->m_eu_BB_Chip = HONEYWELL;
						bRtn = true;
						break;
					}		
				}//if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL

				//如果是 Sdm660_ddr.elf文件
				if(wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					if(wcsstr(cs_FW_Name, _T("SDM660")) != NULL)
					{
						this->m_eu_BB_Chip = SDM660;
						this->m_eu_Memory_Type = UFS;

						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SDX24")) != NULL)//prog_firehose_sdx24.mbn
					{
						this->m_eu_BB_Chip = SDX20;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if (wcsstr(cs_FW_Name, _T("_AG215S")) != NULL)//prog_firehose_ag215s_nand.elf
					{
						this->m_eu_BB_Chip = AG215S;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SDX55")) != NULL)//prog_firehose_sdx55
					{
						this->m_eu_BB_Chip = SDX55;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("9X05")) != NULL)//prog_firehose_nand_mdm9x05
					{
						this->m_eu_BB_Chip = MDM9X05;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SDM845")) != NULL)//prog_ufs_firehose_Sdm845_ddr.elf
					{
						this->m_eu_BB_Chip = SDM845;
						this->m_eu_Memory_Type = UFS;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SM6115")) != NULL)//prog_firehose_sm6115_ddr.elf
					{
						this->m_eu_BB_Chip = SM6115;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else if (wcsstr(cs_FW_Name, _T("_QCM6125")) != NULL)//prog_firehose_QCM6125_ddr.elf
					{
						this->m_eu_BB_Chip = QCM6125;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else if (wcsstr(cs_FW_Name, _T("_SM4350")) != NULL)//prog_firehose_SM4350_ddr.elf
					{
						this->m_eu_BB_Chip = SM4350;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else
					{
						//...
					}
				}

				//如果是.mbn文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					if(wcsstr(cs_FW_Name, _T("PRG9X07")) != NULL)
					{
						this->m_eu_BB_Chip = MDM9X07;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("PRG9X06")) != NULL)
					{
						this->m_eu_BB_Chip = MDM9X06;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("PRG9X45")) != NULL)
					{
						this->m_eu_BB_Chip = MDM9X40;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_9X07")) != NULL)//prog_nand_firehose_9x07.mbn
					{
						this->m_eu_BB_Chip = MDM9X07;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_9X45")) != NULL)//prog_nand_firehose_9x45.mbn
					{
						this->m_eu_BB_Chip = MDM9X40;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}

					else if((wcsstr(cs_FW_Name, _T("_8909")) != NULL)//prog_emmc_firehose_8909_ddr.mbn
						|| (wcsstr(cs_FW_Name, _T("ENPRG8909")) != NULL)
						|| (wcsstr(cs_FW_Name, _T("NPRG8909")) != NULL))
					{
						this->m_eu_BB_Chip = MSM8909;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_8917")) != NULL)//prog_emmc_firehose_8917_ddr.mbn
					{
						this->m_eu_BB_Chip = MSM8917;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_8937")) != NULL)//prog_emmc_firehose_8937_ddr.mbn
					{
						this->m_eu_BB_Chip = MSM8937;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}	
					else if(wcsstr(cs_FW_Name, _T("_8953")) != NULL)//prog_emmc_firehose_8953_ddr.mbn
					{
						this->m_eu_BB_Chip = MSM8953;
						this->m_eu_Memory_Type = EMMC;
						bRtn = true;
						break;
					}
					else if((wcsstr(cs_FW_Name, _T("_9X65")) != NULL)//prog_firehose_9x65.mbn
						||(wcsstr(cs_FW_Name, _T("PRG9X65")) != NULL)
						||(wcsstr(cs_FW_Name, _T("9X05")) != NULL))//prog_firehose_nand_mdm9x05
					{
						this->m_eu_BB_Chip = SDX20;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_9X06")) != NULL)//prog_nand_firehose_9x06.mbn
					{
						this->m_eu_BB_Chip = MDM9X06;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if((wcsstr(cs_FW_Name, _T("_9X55")) != NULL)//prog_firehose_9x55.mbn
						||(wcsstr(cs_FW_Name, _T("PRG9X55")) != NULL))//
					{
						this->m_eu_BB_Chip = MDM9X55;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SDX24")) != NULL)//prog_firehose_sdx24.mbn
					{
						this->m_eu_BB_Chip = SDX20;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					else if(wcsstr(cs_FW_Name, _T("_SDX55")) != NULL)//prog_firehose_sdx55
					{
						this->m_eu_BB_Chip = SDX55;
						this->m_eu_Memory_Type = NAND;
						bRtn = true;
						break;
					}
					
				}//if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL
			}
		}//while(b_Found


		//关闭find
		cla_Finder.Close();


		//错误信息
		if(bRtn == false)
		{
			this->m_csError_Code.Format(_T("Error, Detect BB chip info fail!"));
			this->m_iError_Code = LOAD_BB_INFO_Fail2;
			this->Show_Out(_T("Error, Detect BB chip info fail!"));
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}

	//
	return bRtn;

}

bool CARM_OP_QCM::Send_Stream_Cmd_Open_Multi_Image_Cus_V1(const wchar_t * wcp_Mbn_Name)
{
	int i_TimeOut = 4;
	RSP_INFO_S str_Rsp_Info;

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_OPEN_MULTI_IMAGE_CUS_V1(&this->m_str_Pkt_Send, wcp_Mbn_Name);//7E 1B 0E 30 3A 53 42 4C 31 00 xx xx 7E

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_OPENED_MULTI_IMAGE;//7E 1C 00 76 33 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 4;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Stream_Cmd_Open_Multi_Image_Cus_V1]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Stream_Cmd_Open_Multi_Image_Cus_V2(const wchar_t * wcp_Mbn_Name)
{
	//int i_TimeOut = 4;
	int i_TimeOut = 8;
	RSP_INFO_S str_Rsp_Info;
	CString  err_info =_T("");

	try
	{
		//打包命令
		this->PKT_STREAM_CMD_OPEN_MULTI_IMAGE_CUS_V2(&this->m_str_Pkt_Send, wcp_Mbn_Name);//7E 1B 0E 30 3A 53 42 4C 31 00 xx xx 7E

		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_OPENED_MULTI_IMAGE;//7E 1C 00 76 33 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 4;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//发送
		if(this->SEND_PKT_V1(this->m_str_Pkt_Send, str_Rsp_Info, &this->m_str_Pkt_Read, i_TimeOut) == false)
		{
			throw(0);
		}
	}
	catch(...)
	{
		CString strImageName;
		strImageName.Format(_T("%s:Send_Stream_Cmd_Open_Multi_Image_Cus_V2"),wcp_Mbn_Name);
		AfxMessageBox(strImageName);

		err_info.Format(_T("[Send_Stream_Cmd_Open_Multi_Image_Cus_V2]-%s"),wcp_Mbn_Name);
		this->m_csError_Code += err_info;
		return false;
	}

	return true;
}

void CARM_OP_QCM::PKT_STREAM_CMD_OPEN_MULTI_IMAGE_CUS_V1(PKT_BUFF_S * strp_Pkt_Cmd, const wchar_t * wcp_Mbn_Name)
{
	//7E 1B 0E 30 3A 53 42 4C 31 00 xx xx 7E
	//7E 1B 0E       0:SBL1      00 xx xx 7E

	int iName_Len = wcslen(wcp_Mbn_Name);
	int iBuff_Size = 12 + iName_Len;//定义用于装此命令BUFF的尺寸（正常为6个字符）
	unsigned short usiCRC16;
	int i;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_OPEN_MULTI_IMAGE, true);

	//数据部分载入
	//Which Image mode to open in
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (0x0E & 0xFF), true);//Image for user-defined partition
	//将SBL1、SBL2、RPM、APPSBL、DSP1、DSP2、DSP3镜像路径编辑到“partition name”和“file path”中
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, '0', true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ':', true);
	for(i=0; i<iName_Len; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, (*(wcp_Mbn_Name + i) & 0xFF), true);
	}
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x00, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

void CARM_OP_QCM::PKT_STREAM_CMD_OPEN_MULTI_IMAGE_CUS_V2(PKT_BUFF_S * strp_Pkt_Cmd, const wchar_t * wcp_Mbn_Name)
{
	//7E 1B 0E 30 3A 53 42 4C 31 00 xx xx 7E
	//7E 1B 0E       0:SBL1      00 xx xx 7E

	int iName_Len = wcslen(wcp_Mbn_Name);
	int iBuff_Size = 12 + iName_Len;//定义用于装此命令BUFF的尺寸（正常为6个字符）
	unsigned short usiCRC16;
	int i;

	//先释放内存
	this->m_cla_GFC.PKT_BUFF_FREE(strp_Pkt_Cmd);

	//分配内存
	this->m_cla_GFC.PKT_BUFF_CALLOC(strp_Pkt_Cmd, iBuff_Size);

	//组建命令部分
	//Frame头，不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
	//Command ID
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, CMD_OPEN_MULTI_IMAGE, true);

	//数据部分载入
	//Which Image mode to open in
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (0x0E & 0xFF), true);//Image for user-defined partition
	//将SBL1、SBL2、RPM、APPSBL、DSP1、DSP2、DSP3镜像路径编辑到“partition name”和“file path”中
	for(i=0; i<iName_Len; i++)
	{
		this->Add_Byte_To_Packet(strp_Pkt_Cmd, (*(wcp_Mbn_Name + i) & 0xFF), true);
	}
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, 0x00, true);

	//计算校验位
	usiCRC16 = this->Get_CRC_16((strp_Pkt_Cmd->ucp_Buff + 1), (strp_Pkt_Cmd->ul_Data_Length - 1), true);//Frame头不参加校验计算，需要进行“转意检查”

	//添加校验位（2位）
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, (usiCRC16 & 0xFF), true);
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ((usiCRC16 >> 8) & 0xFF), true);

	//添加结束符（Flag），不转意
	this->Add_Byte_To_Packet(strp_Pkt_Cmd, ASYNC_HDLC_FLAG, false);
}

int CARM_OP_QCM::DL_FW_V2(void)
{
	CString csData;
	unsigned long ulMax_Block_Size = 0;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//初始化PKT_BUFF内存
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);

		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			m_csError_Code = csData;
			throw(0);
		}


		//----------------------- 下载口和下载模式的初始值设置 ----------------------- 
		//“下载模式”初始值设置
		switch(this->m_iCTRL_DL_TYPE)
		{
		case QCMM_DL_TYPE_AUTO://“自动识别下载模式”
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;
			break;
		case QCMM_DL_TYPE_EMERG:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;
			break;
		case QCMM_DL_TYPE_NORM:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;
			break;
		default:
			this->Show_Status(_T("Error, Ctrl dl type is wrong!"));
			throw(0);
		}

		//“下载口”初始值设置
		this->m_iDLOAD_PORT = QCMM_DL_PORT_NDF;



		//----------------------- 探测确定“下载口”----------------------- 
		switch(this->m_iCTRL_DLOAD_PORT)
		{
		case QCMM_DL_PORT_AUTO://自动识别下载口和模式
			{
				//探测、识别下载口（有可能会确认好“下载模式”）
				if(this->Ping_DLoad_Port(&this->m_iDLOAD_PORT, &this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_PORT_DIAG://手动选择USB-Diag口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;
			}
			break;
		case QCMM_DL_PORT_UART://手动选择UART口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_UART;
			}
			break;
		default:
			this->Show_Status(_T("ERROR, Ctrl dload port is wrong!"));
			throw(0);
		}



		//----------------------- 如果已确认了“下载模式”，则不需要切换到“下载状态”，因为已经是下载状态了 ----------------------- 
		//----------------------- 如果还没有识别到“下载模式”，则需要依据“下载口”发送切换下载状态的指令 ----------------------- 
		if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF)
		{
			//依据“下载口”不同，切换下载模式的操作也是不同的
			switch(this->m_iDLOAD_PORT)
			{
			case QCMM_DL_PORT_DIAG://USB-Diag口，使用协议指令
				{
					//发3A A1 6E 7E
					if(this->Switch_To_DL_Mode(2) == true)
					{
						//重启串口
						if(this->COM_PORT_RE_DETECT(_T("DIAG Switching"), 6000, true) == false)
						{
							this->m_csError_Code += _T(" [Diag Open]");
							this->Show_Status(this->m_csError_Code);
							throw(0);
						}
					}
					else
					{
						this->Show_Status(this->m_csError_Code);
						throw(0);
					}
				}
				break;
			case QCMM_DL_PORT_UART://UART口，使用AT指令，并把波特率切换到115200
				this->Show_Status(_T("ERROR, dload port does not use uart port!"));
				throw(0);
			default:
				this->Show_Status(_T("ERROR, dload port is wrong!"));
				throw(0);
			}
		}//if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF

		

		//----------------------- 切换到下载模式（能下载hex和mbn文件），已经识别到下载模式的情况，则不用再切换了 ----------------------- 
		//----------------------- 未识别到下载模式时，在此步探测、确定下载模式 ----------------------- 
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_NDF:	//下载模式未知
		case QCMM_DL_TYPE_AUTO:	//“自动识别下载模式”
			{
				//PING 模块，切换下载模式，并且探测下载模式
				if(this->Ping_Downloader(&this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_EMERG:
		case QCMM_DL_TYPE_NORM:
			break;//已有确切的下载模式
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}


		//把识别到的DL_TYPE显示到界面
		this->Show_DL_Info();


		//CMD_NOP
		if(this->Send_Dmss_Cmd_No_OP(2) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		for(int i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}

		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;

		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}


		//----------------------- 读flash的max write block size数据 ----------------------- 
		if(this->READ_DMSS_HW_INFO(&ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		/*
		CString cs;
		cs.Format(_T("READ_DMSS_HW_INFO, ulMax_Block_Size = 0x%X"), ulMax_Block_Size);
		::AfxMessageBox(cs);
		*/


		//判定CPU类型
		switch(ulMax_Block_Size)
		{
		case 0x0200:	//UC15紧急下载
			this->m_bLow_Speed_CPU = true;//低速
			break;
		case 0x1000:	//UC15正常下载
		case 0x0100:	//UC20紧急下载
		case 0x4000:	//UC20正常下载
		case 0x2000:	//EC20正常下载
		case 0x0600:	//EC20紧急下载
			this->m_bLow_Speed_CPU = false;//高速
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, Flash block size [ 0x%X ] is wrong!"), ulMax_Block_Size);
			this->m_iError_Code = Flash_block_size_Fail;
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x3F9)
		{
			ulMax_Block_Size = 0x3F9;//高速
		}


		//----------------------- 下载HEX文件 ----------------------- 
		//按下载模式不同，下载不同的HEX文件
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_E.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_E, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_NORM:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_N.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_N, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}




		//======================= 重启串口，开始下载mbn文件 =======================
		if(this->COM_PORT_RE_DETECT(_T("Detect"), 5000, true) == false)
		{
			this->m_csError_Code += _T(" [2nd Open]");
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}



		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		if(this->Send_Stream_Cmd_Hello(10, 0x03, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}



		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}


		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));

		//----------------------- 设置Security_Mode，我们用“0x01 – trusted”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//----------------------- 下载其他mbn文件 ----------------------- 
		if(this->DL_Mbn_All_File(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//----------------------- 下载cefs文件 ----------------------- 
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			if(this->DL_Cefs_File(ulMax_Block_Size) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}


		//----------------------- 重启模块 ----------------------- 
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type 2 is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

bool CARM_OP_QCM::FB_DEVICE_V1()
{
	//使用fastboot.exe探测一次是否有Adb设备

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	unsigned long ulActual_Read;
	CString csTotal_Info;
	int iTemp;
	bool bSuccess_Flag = false;


	try
	{
		//
		csTotal_Info.Format(_T(""));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DEVICE, Create pipe fail!"));
			this->m_iError_Code = FB_DEVICE_V1_Fail1;
			throw(0);

		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe devices"), '/', this->m_csCurr_Exe_Path, this->m_iClass_Idx);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DEVICE, Create process fail!"));
			this->m_iError_Code = FB_DEVICE_V1_Fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		//读info（若.exe运行已结束，还继续read的话，会死在这一步）
		memset(cpRead_Buff, 0, 2048);
		ulActual_Read = 0;
		//
		ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

		//读到info数据了
		if(ulActual_Read > 0)
		{
			//字符转换
			memset(wcpData, 0, 2048);
			this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

			csTotal_Info.Format(_T("%s"), wcpData);
			csTotal_Info.Replace(_T('\r'), _T(' '));
			csTotal_Info.Replace(_T('\n'), _T(' '));

//			this->Save_Trace_Log(csTotal_Info);

			//汇总数据
			csTotal_Info.MakeLower();

			this->Show_Status(csTotal_Info);
		}//if(ulActual_Read > 0

		//检查是否pass
		if((wcsstr(csTotal_Info, _T("mdm")) != NULL) && (wcsstr(csTotal_Info, _T("fastboot")) != NULL))
		{
			bSuccess_Flag = true;//pass
		}
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		return false;
	}

	return bSuccess_Flag;
}

bool CARM_OP_QCM::Switch_To_FB_Mode_In_AT()
{
	//用AT指令通过UART口把模块切换到“fastboot”模式

	char crAt_Cmd[32];
	unsigned long ulCmd_Len;

	try
	{
		//打包AT切换指令
		sprintf_s(crAt_Cmd, "AT+QFASTBOOT\r\n");
		ulCmd_Len = strlen(crAt_Cmd);

		this->WRITE_BYTE(crAt_Cmd, ulCmd_Len);

		this->Show_Status(_T("Switch to fastboot mode uart......"));
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FB_V1(void)
{
	int iTimeOut = 100;//探测adb设备的超时
	int iTemp, i;
	CString csData;
	time_t t_Start, t_End;
	int irAT_Port[64];
	int iPort_Cnt;

	try
	{
		//
		this->Show_Status(_T("Start fastboot downloading ......"));

		//------------------------------ 搜索、探测adb设备 ------------------------------ 
		//开始计时
		time(&t_Start);

		while(this->FB_DEVICE_V1() == false)//探测是否有adb设备
		{
			Sleep(700);

			//超时检测
			time(&t_End);
			iTemp = (int)difftime(t_End, t_Start);
			iTemp = iTimeOut - iTemp;

			csData.Format(_T("Detect adb device ...... %d"), iTemp);
			this->Show_Status(csData);


			//
			memset(irAT_Port, 0, sizeof(irAT_Port));
			iPort_Cnt = 0;

			//读可能存在的高通COM AT Port列表
			this->Read_Reg_USB_AT_Port(irAT_Port, &iPort_Cnt);

			//往所有COM口发一遍切换的AT指令
			for(i=0; i<iPort_Cnt; i++)
			{
				//检查该AT口是否已经生成（存在）
				if(this->m_cla_GFC.Confirm_Reg_Com_Port(irAT_Port[i]) == true)
				{
					//有AT口就打开，并发送 AT+QFASTBOOT 指令
					if(this->COM_PORT_OPEN_CUS(irAT_Port[i], 115200) == true)
					{
						csData.Format(_T("Sweep com port %d"), irAT_Port[i]);
						this->Show_Status(csData);
						m_csError_Code = csData;
						Sleep(1000);

						//切换到fastboot后，AT口在注册表中不会消失
						this->Switch_To_FB_Mode_In_AT();

						//关闭AT口
						this->COM_PORT_CLOSE();

						csData.Format(_T("Close com port %d"), irAT_Port[i]);
						this->Show_Status(csData);
					}
				}
			}//for(i=0; i<iPort_Cnt; i++


			//超时，报fail
			if(iTemp <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FB, Detect adb device time out!"));
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
		}//while(this->FB_DEVICE_V1() == false
		//------------------------------ 


		//------------------------------ fastboot模式中下载FW文件 ------------------------------ 
		//下载.yaffs2文件
		for(i=0; i<MAX_YAFFS2_FILE; i++)
		{
			if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
			{
				if(this->FB_DL_FILE(this->m_strr_Yaffs2_File_List[i]) == false)
				{
					throw(3);
				}
			}
		}//for(i=0; i<MAX_YAFFS2_FILE; i++

		//下载.img文件
		for(i=0; i<MAX_IMG_FILE; i++)
		{
			if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
			{
				if(this->FB_DL_FILE(this->m_strr_Img_File_List[i]) == false)
				{
					throw(4);
				}
			}
		}//for(i=0; i<MAX_IMG_FILE; i++
		//------------------------------ 

		//重启
		this->FB_CONTINUE();

		//pass显示
		this->Show_Status(_T("FW download success."));
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::COM_PORT_OPEN_CUS(int i_Com_Port, int i_BR)
{
	//自定义的COM口和BR值打开串口

	//同步串口
	this->m_cla_Com_Port.m_iPort = i_Com_Port;
	this->m_cla_Com_Port.m_iBaudRate = i_BR;
	//重叠串口
	this->m_cla_Com_Thr_Port.m_str_COM.dwCom = i_Com_Port;
	this->m_cla_Com_Thr_Port.m_str_COM.dwBaudRate = i_BR;

	//打开COM口
	switch(this->m_iComm_Type)
	{
	case COMM_SYNC:
		return this->m_cla_Com_Port.Port_Open(100);
	case COMM_OVERLAPPED:
		return this->m_cla_Com_Thr_Port.Port_Open();
	default:
		::AfxMessageBox(_T("FAIL, Comm type error! [COM_PORT_OPEN_CUS]"));
		break;
	}

	return false;
}

bool CARM_OP_QCM::FB_DL_FILE(const MBN_FILE_S str_FB_File)
{
	if(str_FB_File.b_Enable_DL == false)
	{
		this->m_csError_Code.Format(_T("ERROR, FB_DL_FILE, No FB file!"));
		this->Show_Status(this->m_csError_Code);
		return false;
	}


	//使用fastboot.exe下载一个文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csFB_Type_Name;
	int iTemp;
	bool bSuccess_Flag = false;

//	wchar_t * wcprFB_Type_Name[] = {_T("flash system"), _T("flash userdata"), _T("flash boot")};

	try
	{
		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DL_FILE, Create pipe fail!"));
			throw(0);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + str_FB_File.cs_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//
		csFB_Type_Name.Format(_T("%s"), str_FB_File.cs_Name);
		csFB_Type_Name.MakeLower();

		if(wcsstr(csFB_Type_Name, _T("app")) != NULL)
		{
			csFB_Type_Name.Format(_T("aboot"));
		}


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe flash %s \"%s\""),
			'/', this->m_csCurr_Exe_Path, this->m_iClass_Idx, csFB_Type_Name, str_FB_File.cs_Path);

//		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DL_FILE, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

//				this->Save_Trace_Log(csData);

				//显示每次的读出data
				csTemp.Format(_T("FB Download [ %s ] %s"), csFB_Type_Name, csData);
				this->Show_Status(csTemp);

				//汇总数据
				csTotal_Info += csData;
				csTotal_Info.MakeLower();
			}//if(ulActual_Read > 0


			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("fail")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, FB_DL_FILE, Download %s fail!"), csFB_Type_Name);
				throw(3);
			}

			//检查是否pass
			if((wcsstr(csTotal_Info, _T("finished")) != NULL) && (wcsstr(csTotal_Info, _T("total time")) != NULL))
			{
				//显示进度条
				this->m_ul_Transmit_Bytes += str_FB_File.ul_File_Size;
				this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));

				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= 20)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, FB_DL_FILE, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		return false;
	}

	return bSuccess_Flag;
}

bool CARM_OP_QCM::FB_CONTINUE(void)
{
	//使用fastboot.exe命令模块重启

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp;
	int iTemp;
	bool bSuccess_Flag = false;


	try
	{
		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_CONTINUE, Create pipe fail!"));
			throw(0);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe continue"), '/', this->m_csCurr_Exe_Path, this->m_iClass_Idx);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_CONTINUE, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//显示每次的读出data
				csTemp.Format(_T("FB continue %s"), csData);
				this->Show_Status(csTemp);

				//汇总数据
				csTotal_Info += csData;
				csTotal_Info.MakeLower();
			}//if(ulActual_Read > 0

			//检查是否pass
			if((wcsstr(csTotal_Info, _T("finished")) != NULL) && (wcsstr(csTotal_Info, _T("total time")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= 10)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, FB_CONTINUE, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		return false;
	}

	return bSuccess_Flag;
}

bool CARM_OP_QCM::Read_Reg_USB_AT_Port(int * ip_AT_Port_List, int * ip_Port_Quan)
{
	//依据“VID和PID”提取端口列表（提起AT口列表或DM口列表）

	/*
	//UC20
	VID_05C6&PID_9003&MI_00
	USB DM Port (COM16)
	VID_05C6&PID_9003&MI_02
	USB AT Port (COM19)

	//UC15
	VID_05C6&PID_9090&MI_00
	USB DM Port (COM155)
	VID_05C6&PID_9090&MI_02
	USB AT Port (COM152)

	//EC20
	VID_05C6&PID_9215&MI_00
	USB DM Port (COM11)
	VID_05C6&PID_9215&MI_02
	USB AT Port (COM13)

	//9x07平台
	VID_2C7C&PID_0125&REV_0000&MI_00
	VID_2C7C&PID_0125&MI_00
	Quectel USB DM Port (COM242)
	VID_2C7C&PID_0125&REV_0318&MI_02
	VID_2C7C&PID_0125&MI_02
	Quectel USB AT Port (COM243)
	*/
	

	wchar_t wcrUSB_PID_VID[] = _T("VID_05C6&PID_9215&MI_02");//EC20的AT口
	CString csrUsb_Dev_List[64], csFriendly_Name;
	int iUsb_Dev_Quan, i, iCnt;
	wchar_t wcrData[128];
	wchar_t * wcpPoint = NULL;

	try
	{
		//
		*ip_Port_Quan = 0;
		iUsb_Dev_Quan = 0;
		iCnt = 0;

		//读PC上可能多个MDM9215下载设备列表（例如“6&3641b2c&1&0000”设备名）
		this->m_cla_GFC.Get_Reg_Usb_Dev_List(wcrUSB_PID_VID, csrUsb_Dev_List, &iUsb_Dev_Quan);

		for(i=0; i<iUsb_Dev_Quan; i++)
		{
			csFriendly_Name.Format(_T(""));
			
			//依据设备名找“FriendlyName”（例如“Quectel USB DM Port (COM242)”）
			if(this->m_cla_GFC.Get_Reg_Usb_Dev_Friendly_Name(wcrUSB_PID_VID, csrUsb_Dev_List[i], &csFriendly_Name) == false)
			{
				::AfxMessageBox(_T("ERROR, Read_Reg_USB_AT_Port, Fail!"));
				throw(0);
			}

			//数值转换
			csFriendly_Name.MakeUpper();
			csFriendly_Name.Replace(')', '\0');

			swprintf_s(wcrData, _T("%s"), csFriendly_Name);

			wcpPoint = wcsstr(wcrData, _T("(COM"));
			wcpPoint += 4;
			*(ip_AT_Port_List + iCnt) = _wtoi(wcpPoint);
			iCnt++;
		}//for(i=0; i<iUsb_Dev_Quan; i++

		//
		*ip_Port_Quan = iCnt;
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Read_Reg_USB_DM_Port(int * ip_DM_Port_List, int * ip_Port_Quan)
{
	/*
	//UC20
	VID_05C6&PID_9003&MI_00
	USB DM Port (COM16)
	VID_05C6&PID_9003&MI_02
	USB AT Port (COM19)

	//UC15
	VID_05C6&PID_9090&MI_00
	USB DM Port (COM155)
	VID_05C6&PID_9090&MI_02
	USB AT Port (COM152)

	//EC20
	VID_05C6&PID_9215&MI_00
	USB DM Port (COM11)
	VID_05C6&PID_9215&MI_02
	USB AT Port (COM13)

	//9x07平台
	VID_2C7C&PID_0125&REV_0000&MI_00
	VID_2C7C&PID_0125&MI_00
	Quectel USB DM Port (COM242)
	VID_2C7C&PID_0125&REV_0318&MI_02
	VID_2C7C&PID_0125&MI_02
	Quectel USB AT Port (COM243)
	*/

	wchar_t wcrUSB_PID_VID[64];//DM口
	CString csrUsb_Dev_List[64], csFriendly_Name;
	int iUsb_Dev_Quan, i, iCnt;
	wchar_t wcrData[128];
	wchar_t * wcpPoint = NULL;

	try
	{
		//不同平台USB的驱动关键词不同
		switch(this->m_eu_BB_Chip)
		{
		case MDM6X00:
			swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9003&MI_00"));//UC20的DM口
			break;
		case QSC6270:
			swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9090&MI_00"));//UC15的DM口
			break;
		case MDM9X15:
			swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9215&MI_00"));//EC20的DM口
			break;
		case MDM9X07:
		case MDM9X40:
		case MDM9X06:
		case MDM9X55:
		case SDX20:
		case SDX55:
			swprintf_s(wcrUSB_PID_VID, _T("VID_2C7C&PID_0125&MI_00"));//9x07的DM口
			break;
		default:
			throw(0);
		}

		//
		*ip_Port_Quan = 0;
		iUsb_Dev_Quan = 0;
		iCnt = 0;

		//读PC上可能多个MDM9215下载设备列表
		this->m_cla_GFC.Get_Reg_Usb_Dev_List(wcrUSB_PID_VID, csrUsb_Dev_List, &iUsb_Dev_Quan);

		for(i=0; i<iUsb_Dev_Quan; i++)
		{
			csFriendly_Name.Format(_T(""));
			
			if(this->m_cla_GFC.Get_Reg_Usb_Dev_Friendly_Name(wcrUSB_PID_VID, csrUsb_Dev_List[i], &csFriendly_Name) == false)
			{
				::AfxMessageBox(_T("ERROR, Read_Reg_USB_DM_Port, Fail!"));
				throw(0);
			}

			//数值转换
			csFriendly_Name.MakeUpper();
			csFriendly_Name.Replace(')', '\0');

			swprintf_s(wcrData, _T("%s"), csFriendly_Name);

			wcpPoint = wcsstr(wcrData, _T("(COM"));
			wcpPoint += 4;
			*(ip_DM_Port_List + iCnt) = _wtoi(wcpPoint);
			iCnt++;
		}//for(i=0; i<iUsb_Dev_Quan; i++

		//
		*ip_Port_Quan = iCnt;
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_Yaffs2_File_Index(CString cs_Yaffs2_Name, int * ip_Index)
{
	if((wcsstr(cs_Yaffs2_Name, _T("ROOTFS")) != NULL) && (wcsstr(cs_Yaffs2_Name, _T("RECOVERY")) == NULL))
	{
		*ip_Index = SYS_YAFFS2_FILE_I;
	}
	else if((wcsstr(cs_Yaffs2_Name, _T("USR-IMAGE")) != NULL) && (wcsstr(cs_Yaffs2_Name, _T("RECOVERY")) == NULL))
	{
		*ip_Index = USER_YAFFS2_FILE_I;
	}
	else if((wcsstr(cs_Yaffs2_Name, _T("RECOVERY-IMAGE")) != NULL) && (wcsstr(cs_Yaffs2_Name, _T("ROOTFS")) == NULL))
	{
		*ip_Index = RECOV_YAFFS2_FILE_I;
	}
	else
	{
		this->m_csError_Code.Format(_T("FAIL, Get %s.yaffs2 file index error!"), cs_Yaffs2_Name);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_Img_File_Index(CString cs_Img_Name, int * ip_Index)
{
	if(wcsstr(cs_Img_Name, _T("RECOVERY-BOOT")) != NULL)
	{
		*ip_Index = RECOV_IMG_FILE_I;
	}
	else if(wcsstr(cs_Img_Name, _T("BOOT")) != NULL)
	{
		*ip_Index = BOOT_IMG_FILE_I;
	}
	else
	{
		this->m_csError_Code.Format(_T("FAIL, Get %s.yaffs2 file index error!"), cs_Img_Name);
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Get_New_Dynamic_Com_Port(int * ip_New_Port_List, int * ip_New_Port_Quan, int i_TimeOut)
{
	time_t t_Start, t_End;
	CString csNew, csData;
	int irCom_List_Min[64], iCom_Quan_Min, irList_Buff[64], iQuan_Buff, x, y, iTime;
	int irCom_List_New[64], iCom_Quan_New;
	int iGet_New_Port_Flag = 0;


	try
	{
		//清空buff
		iCom_Quan_Min = 0;
		memset(irCom_List_Min, 0, sizeof(irCom_List_Min));
		iQuan_Buff = 0;
		memset(irList_Buff, 0, sizeof(irList_Buff));
		iCom_Quan_New = 0;
		memset(irCom_List_New, 0, sizeof(irCom_List_New));
		csNew.Format(_T(""));

		//
		if ((m_eu_BB_Chip == MSM8953)
			||(m_eu_BB_Chip == MSM8909)
			||(m_eu_BB_Chip == MSM8917)
			||(m_eu_BB_Chip == MDM9X40)
			||(m_eu_BB_Chip == SDX20)
			||(m_eu_BB_Chip == SDX55)
			||(m_eu_BB_Chip == MDM9X07)
			||(m_eu_BB_Chip == MDM9X15)
			||(m_eu_BB_Chip == MDM9X06)
			||(m_eu_BB_Chip == MDM9X55)
			||(m_eu_BB_Chip == QSC6270)
			||(m_eu_BB_Chip == MDM6X00)
			||(m_eu_BB_Chip == MDM9X05)
			||(m_eu_BB_Chip == SDM660)
			||(m_eu_BB_Chip == SDM845)
			||(m_eu_BB_Chip == SM6115)
			|| (m_eu_BB_Chip == QCM6125)
			|| (m_eu_BB_Chip == AG215S)
			|| (m_eu_BB_Chip == SM4350)
			)
		{
			m_iCom_Quan_MSM8953 = 0;
			memset(m_irCom_List_MSM8953, 0, sizeof(m_irCom_List_MSM8953));
		}

		Sleep(3000);//增加3秒的延时再去检查 20180509

		//初始值“min状态”的buff
		if(this->m_cla_GFC.Get_Reg_Com_Port_List(irCom_List_Min, &iCom_Quan_Min) == false)
		{		
			this->m_csError_Code.Format(_T("FAIL, Get_New_Dynamic_Com_Port, Read reg fail!"));
			throw(0);
		}
		else
		{//MSM8953 MSM8909
			if ((m_eu_BB_Chip == MSM8953)
				||(m_eu_BB_Chip == MSM8909)
				||(m_eu_BB_Chip == MSM8917)
				||(m_eu_BB_Chip == MDM9X40)
				||(m_eu_BB_Chip == SDX20)
				||(m_eu_BB_Chip == SDX55)
				||(m_eu_BB_Chip == MDM9X07)
				||(m_eu_BB_Chip == MDM9X15)
				||(m_eu_BB_Chip == MDM9X06)
				||(m_eu_BB_Chip == MDM9X55)
				||(m_eu_BB_Chip == MDM9X05)
				||(m_eu_BB_Chip == QSC6270)
				||(m_eu_BB_Chip == MDM6X00)
				||(m_eu_BB_Chip == SDM660)
				||(m_eu_BB_Chip == SDM845)
				||(m_eu_BB_Chip == SM6115)
				|| (m_eu_BB_Chip == QCM6125)
				|| (m_eu_BB_Chip == AG215S)
				|| (m_eu_BB_Chip == SM4350)
				)
			{
				m_iCom_Quan_MSM8953 = iCom_Quan_Min;
				for(x=0; x<iCom_Quan_Min; x++)
				{
					m_irCom_List_MSM8953[x] =irCom_List_Min[x];
				}

				//将irCom_List_Min的内容和发送指令前的m_irCom_List_old进行比较，不同的COM口即为新生成的QDload口
				for(x=0;x<iCom_Quan_Min;x++)
				{
					for(y=0;y<m_iCom_Quan_old;y++)
					{
						if (irCom_List_Min[x] == m_irCom_List_old[y])//如果能找到，继续找一下irCom_List_Min[x+1]
						{
							break;
						}
					}
					if (y == m_iCom_Quan_old) //如果没找到，说明就是新生成的串口
					{
						//返回值的载入
						*ip_New_Port_Quan = 1;
						*ip_New_Port_List = irCom_List_Min[x];
						csData.Format(_T("Get Port%d-1 Pass"),irCom_List_Min[x]);
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						return true;							
					}

				}

			}

		}


		//
		time(&t_Start);
		//
		do
		{
			//读出regedit中的COM列表
			if(this->m_cla_GFC.Get_Reg_Com_Port_List(irList_Buff, &iQuan_Buff) == false)
			{
				this->m_csError_Code.Format(_T("FAIL, Get_New_Dynamic_Com_Port, Read reg fail!"));
				throw(0);
			}
			else
			{
				if ((m_eu_BB_Chip == MSM8953)
					||(m_eu_BB_Chip == MSM8909)
					||(m_eu_BB_Chip == MSM8917)
					||(m_eu_BB_Chip == MDM9X40)
					||(m_eu_BB_Chip == SDX20)
					||(m_eu_BB_Chip == SDX55)
					||(m_eu_BB_Chip == MDM9X07)
					||(m_eu_BB_Chip == MDM9X15)
					||(m_eu_BB_Chip == MDM9X55)
					||(m_eu_BB_Chip == MDM9X05)
					||(m_eu_BB_Chip == MDM9X06)
					||(m_eu_BB_Chip == QSC6270)
					||(m_eu_BB_Chip == MDM6X00)
					||(m_eu_BB_Chip == SDM660)
					||(m_eu_BB_Chip == SDM845)
					||(m_eu_BB_Chip == SM6115)
					|| (m_eu_BB_Chip == QCM6125)
					|| (m_eu_BB_Chip == AG215S)
					|| (m_eu_BB_Chip == SM4350)
					)
				{
					m_iCom_Quan_MSM8953 = iCom_Quan_Min;
					for(x=0; x<iCom_Quan_Min; x++)
					{
						m_irCom_List_MSM8953[x] =irCom_List_Min[x];
					}
				}

				//将irCom_List_Min的内容和发送指令前的m_irCom_List_old进行比较，不同的COM口即为新生成的QDload口
				if((m_eu_BB_Chip == MSM8953)
					||(m_eu_BB_Chip == MDM9X40)
					||(m_eu_BB_Chip == MSM8909)
					||(m_eu_BB_Chip == SDX20)
					||(m_eu_BB_Chip == SDX55)
					||(m_eu_BB_Chip == MDM9X07)
					||(m_eu_BB_Chip == MDM9X15)
					||(m_eu_BB_Chip == MDM9X55)
					||(m_eu_BB_Chip == MDM9X05)
					||(m_eu_BB_Chip == MDM9X06)
					||(m_eu_BB_Chip == QSC6270)
					||(m_eu_BB_Chip == MDM6X00)
					||(m_eu_BB_Chip == SDM660)
					||(m_eu_BB_Chip == SDM845)
					||(m_eu_BB_Chip == SM6115)
					|| (m_eu_BB_Chip == QCM6125)
					|| (m_eu_BB_Chip == AG215S)
					|| (m_eu_BB_Chip == SM4350)
					)
				{
					for(x=0;x<iCom_Quan_Min;x++)
					{
						for(y=0;y<m_iCom_Quan_old;y++)
						{
							if (irCom_List_Min[x] == m_irCom_List_old[y])//如果能找到，继续找一下irCom_List_Min[x+1]
							{
								break;
							}
						}
						if (y == m_iCom_Quan_old) //如果没找到，说明就是新生成的串口
						{
							//返回值的载入
							*ip_New_Port_Quan = 1;
							*ip_New_Port_List = irCom_List_Min[x];

							csData.Format(_T("Get Port%d-2 Pass"),irCom_List_Min[x]);
							this->Show_Status(csData);
							this->Save_Trace_Log(csData);

							return true;							
						}

					}
				}



			}

			//检查串口数量的变化
			if(iQuan_Buff < iCom_Quan_Min)
			{
				//数量变少，刷新COM口最小数量值的备份
				iCom_Quan_Min = iQuan_Buff;
				//
				for(x=0; x<iQuan_Buff; x++)
				{
					irCom_List_Min[x] = irList_Buff[x];

				}
				if ((m_eu_BB_Chip == MSM8953)
					||(m_eu_BB_Chip == MSM8909)
					||(m_eu_BB_Chip == MSM8917)
					||(m_eu_BB_Chip == MDM9X40)
					||(m_eu_BB_Chip == SDX20)
					||(m_eu_BB_Chip == SDX55)
					||(m_eu_BB_Chip == MDM9X07)
					||(m_eu_BB_Chip == MDM9X15)
					||(m_eu_BB_Chip == MDM9X55)
					||(m_eu_BB_Chip == MDM9X05)
					||(m_eu_BB_Chip == MDM9X06)
					||(m_eu_BB_Chip == QSC6270)
					||(m_eu_BB_Chip == MDM6X00)
					||(m_eu_BB_Chip == SDM660)
					||(m_eu_BB_Chip == SDM845)
					||(m_eu_BB_Chip == SM6115)
					|| (m_eu_BB_Chip == QCM6125)
					|| (m_eu_BB_Chip == AG215S)
					|| (m_eu_BB_Chip == SM4350)
					)
				{
					m_iCom_Quan_MSM8953 = iCom_Quan_Min;
					for(x=0; x<iCom_Quan_Min; x++)
					{
						m_irCom_List_MSM8953[x] =irCom_List_Min[x];
					}
				}
			}
			else if(iQuan_Buff > iCom_Quan_Min)
			{
				//数量增大，把相对于“min状态”时“新产生”的com列表刷新下
				iCom_Quan_New = 0;
				memset(irCom_List_New, 0, sizeof(irCom_List_New));
				csNew.Format(_T(""));

				//
				for(x=0; x<iQuan_Buff; x++)
				{
					for(y=0; y<iCom_Quan_Min; y++)
					{
						if(irList_Buff[x] == irCom_List_Min[y])
						{
							break;
						}
					}
					//发现全新的com口
					if(y >= iCom_Quan_Min)
					{
						irCom_List_New[iCom_Quan_New] = irList_Buff[x];
						iCom_Quan_New++;

						//
						csData.Format(_T("%d "), irList_Buff[x]);
						csNew += csData;
					}
				}//for(x=0; x<iQuan_Buff; x++

				//有新com port生成
				iGet_New_Port_Flag++;
			}


			//系统暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//检查是否超时
			time(&t_End);
			iTime = i_TimeOut - (int)difftime(t_End, t_Start);

			if(csNew.GetLength() > 0)
			{
				csData.Format(_T("Detect dynamic new com port( %s) ...... %d"), csNew, iTime);
			}
			else
			{
				csData.Format(_T("Detect dynamic new com port ...... %d"), iTime);
			}

			this->Show_Status(csData);

			if(iTime <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, Get_New_Dynamic_Com_Port, Timeout fail!"));
				throw(0);
			}

			//已经有新生成的口发现，再扫描3次，这时可以pass了
			if(iGet_New_Port_Flag >= 3)
			{
				break;//退出while
			}

			//每次读取注册表的延迟
			if(iGet_New_Port_Flag > 0)
			{
				Sleep(1000);
			}
			else
			{
				Sleep(400);
			}
		}
		while(true);


		//返回值的载入
		*ip_New_Port_Quan = iCom_Quan_New;
		//
		for(x=0; x<iCom_Quan_New; x++)
		{
			*(ip_New_Port_List + x) = irCom_List_New[x];
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

int CARM_OP_QCM::DL_FW_V3(bool b_Reset_DUT)
{
	CString csData;
	unsigned long ulMax_Block_Size = 0;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//初始化PKT_BUFF内存
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);

		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			m_csError_Code = csData;
			m_iError_Code = QCM_ERR_COM_PORT_OPEN_FAIL;
			throw(0);
		}


		//----------------------- 下载口和下载模式的初始值设置 ----------------------- 
		//“下载模式”初始值设置
		switch(this->m_iCTRL_DL_TYPE)
		{
		case QCMM_DL_TYPE_AUTO://“自动识别下载模式”
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;
			break;
		case QCMM_DL_TYPE_EMERG:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;
			break;
		case QCMM_DL_TYPE_NORM:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;
			break;
		default:
			this->Show_Status(_T("Error, Ctrl dl type is wrong!"));
			m_csError_Code.Format(_T("Ctrl dl type is wrong"));
			m_iError_Code = QCM_ERR_CTRL_DL_TYPE_FAIL;
			throw(0);
		}


		//“下载口”初始值设置
		this->m_iDLOAD_PORT = QCMM_DL_PORT_NDF;


		//----------------------- 探测确定“下载口”----------------------- 
		switch(this->m_iCTRL_DLOAD_PORT)
		{
		case QCMM_DL_PORT_AUTO://自动识别下载口和模式
			{
				//探测、识别下载口（有可能会确认好“下载模式”）
				if(this->Ping_DLoad_Port(&this->m_iDLOAD_PORT, &this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					m_iError_Code = QCM_ERR_PING_DLOAD_PORT_FAIL;
					throw(0);
				}
			}
			break;
		case QCMM_DL_PORT_DIAG://手动选择USB-Diag口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;
			}
			break;
		case QCMM_DL_PORT_UART://手动选择UART口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_UART;
			}
			break;
		default:
			this->Show_Status(_T("ERROR, Ctrl dload port is wrong!"));
			m_csError_Code.Format(_T("Ctrl dload port is wrong"));
			m_iError_Code = QCM_ERR_CTRL_DLOAD_PORT_FAIL;
			throw(0);
		}



		//----------------------- 如果已确认了“下载模式”，则不需要切换到“下载状态”，因为已经是下载状态了 ----------------------- 
		//----------------------- 如果还没有识别到“下载模式”，则需要依据“下载口”发送切换下载状态的指令 ----------------------- 
		if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF)
		{
			//依据“下载口”不同，切换下载模式的操作也是不同的
			switch(this->m_iDLOAD_PORT)
			{
			case QCMM_DL_PORT_DIAG://USB-Diag口，使用协议指令
				{
					//发3A A1 6E 7E
					if(this->Switch_To_DL_Mode(2) == true)
					{
						//重启串口
						if(this->COM_PORT_RE_DETECT(_T("DIAG Switching"), 6000, true) == false)
						{
							this->m_csError_Code += _T(" [Diag Open]");
							this->Show_Status(this->m_csError_Code);
							m_iError_Code = QCM_ERR_DIAG_Switching_FAIL;
							throw(0);
						}
					}
					else
					{
						this->Show_Status(this->m_csError_Code);
						m_iError_Code = QCM_ERR_Switch_To_DL_Mode_FAIL;
						throw(0);
					}
				}
				break;
			case QCMM_DL_PORT_UART://UART口，使用AT指令，并把波特率切换到115200
				this->Show_Status(_T("ERROR, dload port does not use uart port!"));
				m_csError_Code.Format(_T("Dload port does not use uart port"));
				m_iError_Code = QCM_ERR_Dload_port_use_uart_port_FAIL;
				throw(0);
			default:
				this->Show_Status(_T("ERROR, dload port is wrong!"));
				m_csError_Code.Format(_T("Dload port FAIL"));
				m_iError_Code = QCM_ERR_Dload_port_use_FAIL;
				throw(0);
			}
		}//if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF

		

		//----------------------- 切换到下载模式（能下载hex和mbn文件），已经识别到下载模式的情况，则不用再切换了 ----------------------- 
		//----------------------- 未识别到下载模式时，在此步探测、确定下载模式 ----------------------- 
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_NDF:	//下载模式未知
		case QCMM_DL_TYPE_AUTO:	//“自动识别下载模式”
			{
				//PING 模块，切换下载模式，并且探测下载模式
				if(this->Ping_Downloader(&this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					m_iError_Code = QCM_ERR_Ping_Downloader_FAIL;
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_EMERG:
		case QCMM_DL_TYPE_NORM:
			break;//已有确切的下载模式
		default:
			m_iError_Code = QCM_ERR_DL_type_FAIL;
			m_csError_Code.Format(_T("DL type FAIL"));
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}


		//把识别到的DL_TYPE显示到界面
		this->Show_DL_Info();


		//CMD_NOP
		if(this->Send_Dmss_Cmd_No_OP(2) == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_Send_Dmss_Cmd_No_OP_FAIL;
			throw(0);
		}


		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		int i;
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		for(i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}

		//
		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;

		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}

		//假文件
		if(this->m_str_Mbn_SBL2_TMP.b_Enable_DL == true)
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_SBL2_TMP.ul_File_Size;
		}
		if(this->m_str_Mbn_APPSBL_TMP.b_Enable_DL == true)
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_APPSBL_TMP.ul_File_Size;
		}
		//Fastboot下载完成后，重新用协议下载的mbn文件
		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;
		this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I].ul_File_Size;

		//YAFFS2文件
		for(i=0; i<MAX_YAFFS2_FILE; i++)
		{
			if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Yaffs2_File_List[i].ul_File_Size;
			}
		}

		//IMG文件
		for(i=0; i<MAX_IMG_FILE; i++)
		{
			if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Img_File_List[i].ul_File_Size;
			}
		}


		//yaffs_head.aa
		if(this->m_str_Yaffs_Head_aa.b_Enable_DL == true)
		{
			this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_aa.ul_File_Size;
		}


		//yaffs_head.ab
		if(this->m_str_Yaffs_Head_ab.b_Enable_DL == true)
		{
			this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_ab.ul_File_Size;
		}
		//----------------------- 


		//----------------------- 读flash的max write block size数据 ----------------------- 
		if(this->READ_DMSS_HW_INFO(&ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_READ_DMSS_HW_INFO_FAIL;
			throw(0);
		}


		/*
		CString cs;
		cs.Format(_T("READ_DMSS_HW_INFO, ulMax_Block_Size = 0x%X"), ulMax_Block_Size);
		::AfxMessageBox(cs);
		*/


		//判定CPU类型
		switch(ulMax_Block_Size)
		{
		case 0x0200:	//UC15紧急下载
			this->m_bLow_Speed_CPU = true;//低速
			break;
		case 0x1000:	//UC15正常下载
		case 0x0100:	//UC20紧急下载
		case 0x4000:	//UC20正常下载
		case 0x2000:	//EC20正常下载
		case 0x0600:	//EC20紧急下载
			this->m_bLow_Speed_CPU = false;//高速
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, Flash block size [ 0x%X ] is wrong!"), ulMax_Block_Size);
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_Flash_block_size_FAIL;
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x3F9)
		{
			ulMax_Block_Size = 0x3F9;//高速
		}


		//----------------------- 下载HEX文件 ----------------------- 
		//按下载模式不同，下载不同的HEX文件
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_E.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_E, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					m_iError_Code = QCM_ERR_DL_Hex_E_File_FAIL;
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_NORM:
			{
				this->m_ul_DL_All_Bytes += this->m_str_Hex_N.ul_File_Size;

				if(this->DL_Hex_File(this->m_str_Hex_N, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					m_iError_Code = QCM_ERR_DL_Hex_N_File_FAIL;
					throw(0);
				}
			}
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			m_iError_Code = QCM_ERR_DL_type_FAIL;
			m_csError_Code.Format(_T("DL type FAIL"));

			throw(0);
		}



		//======================= 重启串口，开始下载mbn文件 =======================
		if(this->COM_PORT_RE_DETECT(_T("Detect"), 5000, true) == false)
		{
			this->m_csError_Code += _T(" [2nd Open]");
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_COM_PORT_RE_DETECT_FAIL;
			throw(0);
		}



		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		/*
		if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		*/

		if(this->Send_Stream_Cmd_Hello(10, 0x03, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_Send_Stream_Cmd_Hello_FAIL;
			throw(0);
		}



		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}


		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));


		//----------------------- 设置Security_Mode，我们用“0x01 – trusted”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_Send_Stream_Cmd_Security_Mode_FAIL;
			throw(0);
		}


		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Mbn_Partition_Table() == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_DL_Mbn_Partition_Table_FAIL;
			throw(0);
		}


		//----------------------- 下载其他mbn文件 ----------------------- 
		//按下载模式不同，下载不同的MBN文件
		if(this->DL_Mbn_All_File_V3(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			m_iError_Code = QCM_ERR_DL_Mbn_All_File_V3_FAIL;
			throw(0);
		}


		//----------------------- 重启模块 ----------------------- 
		if(b_Reset_DUT == true)
		{
			if(this->Send_Stream_Cmd_Reset() == false)
			{
				this->Show_Status(this->m_csError_Code);
				m_iError_Code = QCM_ERR_Send_Stream_Cmd_Reset_FAIL;
				throw(0);
			}
		}


		//关闭串口
		this->COM_PORT_CLOSE();


		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type 2 is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_Mbn_All_File_V3(unsigned long ul_Pkt_Data_Len)
{
	try
	{
		//---------------------- SBL1 ---------------------- 
		if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_strr_Mbn_File_List[SBL1_MBN_FILE_I].cs_Name) == false)
		{
			throw(0);
		}
		//开始下载mbn文件
		if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[SBL1_MBN_FILE_I], ul_Pkt_Data_Len) == false)
		{
			throw(0);
		}
		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
		//---------------------- 

		//---------------------- 假SBL2 ---------------------- 
		if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_str_Mbn_SBL2_TMP.cs_Name) == false)
		{
			throw(0);
		}
		//开始下载mbn文件
		if(this->DL_Mbn_File_V2(this->m_str_Mbn_SBL2_TMP, ul_Pkt_Data_Len) == false)
		{
			throw(0);
		}
		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
		//---------------------- 

		//---------------------- RPM ---------------------- 
		if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_strr_Mbn_File_List[RPM_MBN_FILE_I].cs_Name) == false)
		{
			throw(0);
		}
		//开始下载mbn文件
		if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[RPM_MBN_FILE_I], ul_Pkt_Data_Len) == false)
		{
			throw(0);
		}
		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
		//---------------------- 

		//---------------------- 假APPSBL ---------------------- 
		if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_str_Mbn_APPSBL_TMP.cs_Name) == false)
		{
			throw(0);
		}
		//开始下载mbn文件
		if(this->DL_Mbn_File_V2(this->m_str_Mbn_APPSBL_TMP, ul_Pkt_Data_Len) == false)
		{
			throw(0);
		}
		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
		//---------------------- 
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FB_V3(bool b_Detect_ADB_DUT, bool b_Reboot_DUT)
{
	int iTimeOut = 50;//探测adb设备的超时
	int iTemp, i;
	CString csData;
	time_t t_Start, t_End;

	try
	{
		//
		this->Show_Status(_T("Start fastboot downloading ......"));

		//------------------------------ 搜索、探测adb设备 ------------------------------ 
		if(b_Detect_ADB_DUT == true)
		{
			//开始计时
			time(&t_Start);

			while(this->FB_DEVICE_V1() == false)//探测是否有adb设备
			{
				Sleep(700);

				//超时检测
				time(&t_End);
				iTemp = (int)difftime(t_End, t_Start);
				iTemp = iTimeOut - iTemp;

				csData.Format(_T("Detect adb device ...... %d"), iTemp);
				this->Show_Status(csData);

				//超时，报fail
				if(iTemp <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FB_V3, Detect adb device time out!"));
					this->Show_Status(this->m_csError_Code);
					throw(2);
				}
			}//while(this->FB_DEVICE_V1() == false
		}
		//------------------------------ 


		//
		Sleep(500);


		//------------------------------ fastboot模式中下载FW文件 ------------------------------ 
		//下载“真SBL2文件”
		if(this->FB_DL_FILE(this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I]) == false)
		{
			throw(3);
		}

		//下载“真appsbl文件”
		if(this->FB_DL_FILE(this->m_strr_Mbn_File_List[APPSBL_MBN_FILE_I]) == false)
		{
			throw(3);
		}

		//下载dsp1 dsp2 dsp3文件
		for(i=DSP1_MBN_FILE_I; i<=DSP3_MBN_FILE_I; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				if(this->FB_DL_FILE(this->m_strr_Mbn_File_List[i]) == false)
				{
					throw(3);
				}
			}
		}//for(i=DSP1_MBN_FILE_I; i<=DSP3_MBN_FILE_I; i++


		//下载.yaffs2文件
		for(i=0; i<MAX_YAFFS2_FILE; i++)
		{
			if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
			{
				if(this->FB_DL_FILE(this->m_strr_Yaffs2_File_List[i]) == false)
				{
					throw(3);
				}
			}
		}//for(i=0; i<MAX_YAFFS2_FILE; i++


		//下载.img文件
		for(i=0; i<MAX_IMG_FILE; i++)
		{
			if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
			{
				if(this->FB_DL_FILE(this->m_strr_Img_File_List[i]) == false)
				{
					throw(4);
				}
			}
		}//for(i=0; i<MAX_IMG_FILE; i++		


		//yaffs_head.aa
		if(this->m_str_Yaffs_Head_aa.b_Enable_DL == true)
		{
			if(this->FB_DL_FILE(this->m_str_Yaffs_Head_aa) == false)
			{
				throw(5);
			}
		}


		//yaffs_head.ab
		if(this->m_str_Yaffs_Head_ab.b_Enable_DL == true)
		{
			if(this->FB_DL_FILE(this->m_str_Yaffs_Head_ab) == false)
			{
				throw(6);
			}
		}
		//------------------------------ 



		//fastboot.exe erase misc
		if(this->FB_ERASE(_T("misc")) == false)
		{
			throw(7);
		}


		/*
		//fastboot.exe erase fota
		if(this->FB_ERASE(_T("fota")) == false)
		{
			throw(8);
		}
		*/



		//重启（reboot）
		if(b_Reboot_DUT == true)
		{
			this->FB_REBOOT();
		}



		//pass显示
		this->Show_Status(_T("FW download success."));
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FW_SBL2(void)
{
	CString csData;
	unsigned long ulMax_Block_Size = 0;

	try
	{
		//进度条置零
//		this->Show_Progress(0.0);

		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//初始化PKT_BUFF内存
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);

		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			m_csError_Code = csData;
			throw(0);
		}


		//----------------------- 下载口和下载模式的初始值设置 ----------------------- 
		//“下载模式”初始值设置
		switch(this->m_iCTRL_DL_TYPE)
		{
		case QCMM_DL_TYPE_AUTO://“自动识别下载模式”
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;
			break;
		case QCMM_DL_TYPE_EMERG:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;
			break;
		case QCMM_DL_TYPE_NORM:
			this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;
			break;
		default:
			this->Show_Status(_T("Error, Ctrl dl type is wrong!"));
			throw(0);
		}


		//“下载口”初始值设置
		this->m_iDLOAD_PORT = QCMM_DL_PORT_NDF;


		//----------------------- 探测确定“下载口”----------------------- 
		switch(this->m_iCTRL_DLOAD_PORT)
		{
		case QCMM_DL_PORT_AUTO://自动识别下载口和模式
			{
				//探测、识别下载口（有可能会确认好“下载模式”）
				if(this->Ping_DLoad_Port(&this->m_iDLOAD_PORT, &this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_PORT_DIAG://手动选择USB-Diag口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;
			}
			break;
		case QCMM_DL_PORT_UART://手动选择UART口
			{
				this->m_iDLOAD_PORT = QCMM_DL_PORT_UART;
			}
			break;
		default:
			this->Show_Status(_T("ERROR, Ctrl dload port is wrong!"));
			throw(0);
		}



		//----------------------- 如果已确认了“下载模式”，则不需要切换到“下载状态”，因为已经是下载状态了 ----------------------- 
		//----------------------- 如果还没有识别到“下载模式”，则需要依据“下载口”发送切换下载状态的指令 ----------------------- 
		if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF)
		{
			//依据“下载口”不同，切换下载模式的操作也是不同的
			switch(this->m_iDLOAD_PORT)
			{
			case QCMM_DL_PORT_DIAG://USB-Diag口，使用协议指令
				{
					//发3A A1 6E 7E
					if(this->Switch_To_DL_Mode(2) == true)
					{
						//重启串口
						if(this->COM_PORT_RE_DETECT(_T("DIAG Switching"), 6000, true) == false)
						{
							this->m_csError_Code += _T(" [Diag Open]");
							this->Show_Status(this->m_csError_Code);
							throw(0);
						}
					}
					else
					{
						this->Show_Status(this->m_csError_Code);
						throw(0);
					}
				}
				break;
			case QCMM_DL_PORT_UART://UART口，使用AT指令，并把波特率切换到115200
				this->Show_Status(_T("ERROR, dload port does not use uart port!"));
				throw(0);
			default:
				this->Show_Status(_T("ERROR, dload port is wrong!"));
				throw(0);
			}
		}//if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_NDF

		

		//----------------------- 切换到下载模式（能下载hex和mbn文件），已经识别到下载模式的情况，则不用再切换了 ----------------------- 
		//----------------------- 未识别到下载模式时，在此步探测、确定下载模式 ----------------------- 
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_NDF:	//下载模式未知
		case QCMM_DL_TYPE_AUTO:	//“自动识别下载模式”
			{
				//PING 模块，切换下载模式，并且探测下载模式
				if(this->Ping_Downloader(&this->m_iDL_Emerg_Norm_TYPE) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_EMERG:
		case QCMM_DL_TYPE_NORM:
			break;//已有确切的下载模式
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}


		//把识别到的DL_TYPE显示到界面
		this->Show_DL_Info();


		//CMD_NOP
		if(this->Send_Dmss_Cmd_No_OP(2) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}



		//----------------------- 读flash的max write block size数据 ----------------------- 
		if(this->READ_DMSS_HW_INFO(&ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		/*
		CString cs;
		cs.Format(_T("READ_DMSS_HW_INFO, ulMax_Block_Size = 0x%X"), ulMax_Block_Size);
		::AfxMessageBox(cs);
		*/


		//判定CPU类型
		switch(ulMax_Block_Size)
		{
		case 0x0200:	//UC15紧急下载
			this->m_bLow_Speed_CPU = true;//低速
			break;
		case 0x1000:	//UC15正常下载
		case 0x0100:	//UC20紧急下载
		case 0x4000:	//UC20正常下载
		case 0x2000:	//EC20正常下载
		case 0x0600:	//EC20紧急下载
			this->m_bLow_Speed_CPU = false;//高速
			break;
		default:
			this->m_csError_Code.Format(_T("ERROR, Flash block size [ 0x%X ] is wrong!"), ulMax_Block_Size);
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x3F9)
		{
			ulMax_Block_Size = 0x3F9;//高速
		}


		//----------------------- 下载HEX文件 ----------------------- 
		//按下载模式不同，下载不同的HEX文件
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			{
				if(this->DL_Hex_File(this->m_str_Hex_E, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		case QCMM_DL_TYPE_NORM:
			{
				if(this->DL_Hex_File(this->m_str_Hex_N, ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}
		//-----------------------


		//======================= 重启串口，开始下载mbn文件 =======================
		if(this->COM_PORT_RE_DETECT(_T("Detect"), 5000, true) == false)
		{
			this->m_csError_Code += _T(" [2nd Open]");
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}



		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		if(this->Send_Stream_Cmd_Hello(10, 0x03, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}



		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}


		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));

		//----------------------- 设置Security_Mode，我们用“0x01 – trusted”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Mbn_Partition_Table() == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------


		//---------------------- SBL2 ---------------------- 
		if(this->Send_Stream_Cmd_Open_Multi_Image_Cus_V1(this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I].cs_Name) == false)
		{
			throw(0);
		}
		//开始下载mbn文件
		if(this->DL_Mbn_File_V2(this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I], ulMax_Block_Size) == false)
		{
			throw(0);
		}
		//close
		if(this->Send_Stream_Cmd_Close(2) == false)
		{
			throw(0);
		}
		//---------------------- 


		//----------------------- 下载cefs文件 ----------------------- 
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			if(this->DL_Cefs_File(ulMax_Block_Size) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
		//-----------------------


		//----------------------- 重启模块 ----------------------- 
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------

		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//PASS信息显示
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::FB_REBOOT(void)
{
	//使用fastboot.exe命令模块reboot

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp;
	int iTemp;
	bool bSuccess_Flag = false;


	try
	{
		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_REBOOT, Create pipe fail!"));
			throw(0);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe reboot"), '/', this->m_csCurr_Exe_Path, this->m_iClass_Idx);


//		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_REBOOT, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//显示每次的读出data
				csTemp.Format(_T("FB reboot %s"), csData);
				this->Show_Status(csTemp);

				//汇总数据
				csTotal_Info += csData;
				csTotal_Info.MakeLower();
			}//if(ulActual_Read > 0

			//检查是否pass
			if((wcsstr(csTotal_Info, _T("finished")) != NULL) && (wcsstr(csTotal_Info, _T("total time")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= 10)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, FB_REBOOT, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		return false;
	}

	//
	return bSuccess_Flag;
}

bool CARM_OP_QCM::Update_USB_DL_Port(const int i_Old_Port, int * ip_New_Port)
{
	int irNew_Port[64], iNew_Quan, i, j;

	try
	{
		iNew_Quan = 0;
		memset(irNew_Port, 0, sizeof(irNew_Port));

		//读取新生成的com port口列表
		if ((m_eu_BB_Chip == MSM8953 )
			||(m_eu_BB_Chip == MDM9X40)
			||(m_eu_BB_Chip == SDX20)
			||(m_eu_BB_Chip == SDX55)
			||(m_eu_BB_Chip == MDM9X07)
			||(m_eu_BB_Chip == MDM9X55)
			||(m_eu_BB_Chip == SM6115)
			|| (m_eu_BB_Chip == QCM6125)
			|| (m_eu_BB_Chip == SM4350)
			) 
		{
			if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 30) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}

		}
		else
		{
			if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 60) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}

		}

		//
		if(iNew_Quan == 1)
		{
			//唯一的生成口
			*ip_New_Port = irNew_Port[0];
			return true;
		}

		//检查最初的下载口是否在新生成的口之列
		for(i=0; i<iNew_Quan; i++)
		{
			if(irNew_Port[i] == i_Old_Port)
			{
				//最初的下载口未变
				//不改变下载口值
				return true;
			}
		}

		//最初的下载口消失了，需要重新确定可能的下载口

		//“新生成口”与“DM口列表”核对
		int irDM_Port[64], iDM_Quan;

		iDM_Quan = 0;
		memset(irDM_Port, 0, sizeof(irDM_Port));

		//读PC机存在的所有DM口
		this->Read_Reg_USB_DM_Port(irDM_Port, &iDM_Quan);

		for(i=0; i<iNew_Quan; i++)
		{
			for(j=0; j<iDM_Quan; j++)
			{
				if(irNew_Port[i] == irDM_Port[j])
				{
					//新生成口与某个DM口一致
					*ip_New_Port = irNew_Port[i];
					return true;
				}
			}//for(j=0; j<iDM_Quan; j++
		}//for(i=0; i<iNew_Quan; i++
	}
	catch(...)
	{
		return false;
	}

	this->m_csError_Code.Format(_T("FAIL, Update_USB_DL_Port, No right port!"));
	return false;
}

bool CARM_OP_QCM::Send_Hex_Pkt_Data_V2(HEX_REAL_DATA_S * strp_Hex_Real_Data, const int i_Pkt_Length)
{
	if(strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length <= 0)
	{
		this->m_csError_Code.Format(_T("FAIL, Hex buff is empty! [Send_Hex_Pkt_Data_V2]"));
		return false;
	}

	int iTimeOut = 2;//发射完全部数据后，读其数据包确认回复的总超时时间
	int iCnt;//单句发送的循环超时次数
	RSP_INFO_V2_S str_Rsp_Info_V2;

	try
	{
		//设定预计回复
		//设定预计回复，CMD_ACK
		//7E 02 6A D3 7E
		str_Rsp_Info_V2.ucr_Expect_Rsp[0] = 0x7E;
		str_Rsp_Info_V2.ucr_Expect_Rsp[1] = 0x02;
		str_Rsp_Info_V2.ucr_Expect_Rsp[2] = 0x6A;
		str_Rsp_Info_V2.ucr_Expect_Rsp[3] = 0xD3;
		str_Rsp_Info_V2.ucr_Expect_Rsp[4] = 0x7E;
		str_Rsp_Info_V2.ucr_Expect_Rsp[5] = NULL;
		str_Rsp_Info_V2.ui_Rsp_Data_Length = 5;
		str_Rsp_Info_V2.ui_Rsp_Pkt_Quan = 1;

		//循环打包发送，BUFF中待发数据循环
		while(
			(strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length >= i_Pkt_Length) ||
			((strp_Hex_Real_Data->str_Actual_Data.str_Data.ul_Data_Length > 0) && (strp_Hex_Real_Data->b_End_Flag == true))
			)
		{
			//HEX_REAL_DATA_S中有够一次“打包PKT量”数据时；或者已有“End_Flag”；便允许打包发送数据

			//打包一条命令
			if(this->PKT_DMSS_CMD_WRITE_32BIT(&this->m_str_Pkt_Send, strp_Hex_Real_Data, i_Pkt_Length) == false)
			{
				//打包数据出错，便终止此次下载
				throw(0);
			}

			//单句发送循环
			iCnt = 3;

			while(iCnt > 0)
			{
				if(this->m_iStop_Flag > 0)
				{
					this->m_csError_Code.Format(_T("Operation has been stopped!"));
					throw(0);
				}

				//清空接收BUFF
				this->Clear_Com_Rx_Buffer();

				//发送指令
				if(this->WRITE_BYTE((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
				{
					if(this->m_bLow_Speed_CPU == true)
					{
						Sleep(50);
					}

//					Sleep(80);

					//等待、读取、提取、检查应答，返回Frame中Packet部分数据
					if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, iTimeOut) == true)
					{
//						::AfxMessageBox(_T("pass, READ_PKT_RSP_V2"));
						break;//单句发送成功
					}					
				}
				else
				{
					Sleep(500);
//					::AfxMessageBox(_T("FAIL, Write hex byte!"));
				}

				if((--iCnt) <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Read hex rsp timeout, %s"), this->GET_COM_PORT_ERROR_INFO());
					throw(0);
				}
			}//while(iCnt > 0

		}//while((strp_Hex_Real_Data->str_Actual_Data.ul_Data_Length >= i_Pkt_Length) || (strp_Hex_Real_Data->b_End_Flag)
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Hex_Pkt_Data_V2]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::SEND_PKT_V3(PKT_BUFF_S str_Pkt_Write, RSP_INFO_V2_S str_Rsp_Info_V2, int i_TimeOut)
{
	//在超时内，发送一次“指令”，并核对“期望的返回”，函数本身不返回“读到的实际数据”。

	time_t t_Start, t_End;

	try
	{
		//清空接收BUFF
		this->Clear_Com_Rx_Buffer();
		this->m_csError_Code.Format(_T(""));

		//发送一次指令
		this->WRITE_BYTE((char *)str_Pkt_Write.ucp_Buff, str_Pkt_Write.ul_Data_Length);

		//循环
		time(&t_Start);
		//
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//等待、读取、提取、检查应答，返回Frame中Packet部分数据
			//1秒的超时是不够的，会造成已有回报，但程序却没有读到
			if(this->READ_PKT_RSP_V2(str_Rsp_Info_V2, 2) == true)
			{
				//读到校验正确的应答
				break;//pass
			}

			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				throw(0);
			}
		}
		while(true);
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Mbn_Pkt_Data_V2(PKT_DATA_ADDR_BUFF_S * strp_Mbn_Data_Addr, const int i_Pkt_Data_Len)
{
	//mbn文件数据，以“发一条, 读一条应答”方式处理

	if(strp_Mbn_Data_Addr->str_Data.ul_Data_Length <= 0)
	{
		this->m_csError_Code.Format(_T("FAIL, Pkt data addr buff is empty! [Send_Mbn_Pkt_Data_V2]"));
		return false;
	}

	int iTimeOut = 2;//发射完全部数据后，读其数据包确认回复的总超时时间
	int iCnt;//单句发送的循环超时次数
	RSP_INFO_S str_Rsp_Info;

	try
	{
		//设定预计回复
		str_Rsp_Info.ui_Rsp_ID = CMD_BLOCK_WRITTEN;//7E 08 00 00 00 00 57 95 7E
		str_Rsp_Info.ui_Pkt_Valid_Len = 7;
		str_Rsp_Info.ui_Pkt_Quan = 1;

		//循环打包发送
		while((strp_Mbn_Data_Addr->str_Data.ul_Data_Length >= i_Pkt_Data_Len) ||
			((strp_Mbn_Data_Addr->str_Data.ul_Data_Length > 0) && (strp_Mbn_Data_Addr->b_Read_Finish == true)))
		{
			//HEX_REAL_DATA_S中有够一次“打包PKT量”数据时；或者“b_Read_Finish”读文件结束；便允许打包发送数据

			//打包一条命令
			if(this->PKT_STREAM_CMD_STREAM_WRITE_V1(&this->m_str_Pkt_Send, strp_Mbn_Data_Addr, i_Pkt_Data_Len) == false)
			{
				//打包数据出错，便终止此次下载
				throw(0);
			}

			//单句发送循环
			iCnt = 3;
			//
			while(iCnt > 0)
			{
				//清空接收BUFF
				this->Clear_Com_Rx_Buffer();

				//发送指令
				if(this->WRITE_BYTE((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
				{
					//确认rsp应答
					if(this->READ_PKT_RSP(str_Rsp_Info, &this->m_str_Pkt_Read, iTimeOut) == true)
					{
						break;//while
					}
				}
				else
				{
					Sleep(500);
//					::AfxMessageBox(_T("FAIL, Write mbn byte!"));
				}

				if((--iCnt) <= 0)
				{
					this->m_csError_Code.Format(_T("FAIL, Read mbn rsp timeout, %s"), this->GET_COM_PORT_ERROR_INFO());
					throw(0);
				}
			}//while(iCnt > 0
		}//while((strp_Hex_Real_Data->str_Actual_Data.ul_Data_Length >= i_Pkt_Length) || (strp_Hex_Real_Data->b_End_Flag)
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Mbn_Pkt_Data_V2]");

		return false;
	}

	return true;
}



int CARM_OP_QCM::Execute_MDM6X00(void)
{
	try
	{
		//刷新COM参数
		this->Load_Com_Port_Params();

		CString strData;

		//------------------------------ 检查串口是否存在 ------------------------------ 
		

		if(this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port) == true)
		{
			//DM口已经存在，则说明模块已预先开机，无需特别延迟
			strData.Format(_T("Pass,Confirm_Reg_Com_Port-%d"),this->m_iCom_Port);
			this->Save_Trace_Log(strData);
		}
		else
		{
			//DM口还不存在，需要探测，并额外给开机延迟时间

			//探测DM口生成
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 60) == false)//25
			{
				this->Show_Status(this->m_csError_Code);

				strData.Format(_T("Fail,Confirm_Reg_Com_Port-%d"),this->m_iCom_Port);
				this->Save_Trace_Log(strData);
				this->Save_Trace_Log(this->m_csError_Code);

				throw(1);
			}


			//DM端口刚生成后，模块初始化未完成，模块无法下载
			Sleep(8000);
		}
		//------------------------------



		//------------------------------ 从模块中备份出QCN，FTM模式 ------------------------------ 
		if(this->m_bQCN_BACKUP == true)
		{
			this->Save_Trace_Log(_T("BACKUP_QCN Start..."));
			if(this->BACKUP_QCN(this->m_str_Mbn_QCN_BU_RS) == false)
			{
				this->Save_Trace_Log(this->m_csError_Code);
				this->Save_Trace_Log(_T("Fail,BACKUP_QCN"));
				throw(2);
			}
			else
			{
				this->Save_Trace_Log(_T("Pass,BACKUP_QCN"));			
			}
		}
		//------------------------------


		//------------------------------ 下载FW操作（包括下载EFS文件），下载模式 ------------------------------ 
		if(this->m_bFW_DL == true)
		{
			this->Save_Trace_Log(_T("DL_FW_V1 Start..."));
			if(this->DL_FW_V1() != RTN_SUCCESS)
			{
				this->Save_Trace_Log(this->m_csError_Code);
				this->Save_Trace_Log(_T("Fail,DL_FW_V1"));
				throw(3);
			}
			else
			{
				this->Save_Trace_Log(_T("Pass,DL_FW_V1"));			
			}
		}
		//------------------------------


		//------------------------------ 把QCN导入模块，FTM模式 ------------------------------ 
		if(this->m_bQCN_RESTORE || this->m_bQCN_DL)
		{
			if(this->m_bFW_DL == true)
			{
				//确认下载口
				//清空buff
// 				m_iCom_Quan_old = 0;
// 				memset(m_irCom_List_old, 0, sizeof(m_irCom_List_old));
// 				if(this->m_cla_GFC.Get_Reg_Com_Port_List(m_irCom_List_old, &m_iCom_Quan_old) == false)
// 				{		
// 					this->m_csError_Code.Format(_T("FAIL, Get_Reg_Com_Port_List, Read reg fail!"));
// 					throw(0);
// 				}
				//探测DM口生成
				if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 25) == false)
				{
					this->Show_Status(this->m_csError_Code);
					this->Save_Trace_Log(this->m_csError_Code);
					throw(1);
				}

				//---------------------------------------------------------------
				//20200213 增加6秒的延时再check下端口号
				CString csA, csB;
				int s = 200;
				//模块重启时间，进度简易显示
				csA.Format(_T("%s"), _T("Waitting Port Normal"));
				csB.Format(_T(" ."));
				//循环进度条
				for(int j=0; j<30; j++)
				{
					csA += csB;
					this->Show_Status(csA);
					Sleep(s);
				}
				//探测DM口生成
				if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 25) == false)
				{
					this->Show_Status(this->m_csError_Code);
					this->Save_Trace_Log(this->m_csError_Code);
					throw(1);
				}
				//---------------------------------------------------------------


// 				if(this->Update_USB_DL_Port(this->m_iCom_Port, &this->m_iCom_Port) == false)
// 				{
// 					throw(6);
// 				}

				//刷新COM参数
				this->Load_Com_Port_Params();

				//模块下载重启后的初始化时间
				Sleep(3000);
			}

			//由于qcn操作无法重启模块，所以放在最后
			this->Save_Trace_Log(_T("RESTORE_QCN Start..."));
			if(this->RESTORE_QCN(this->m_str_Mbn_QCN_BU_RS, this->m_str_Mbn_QCN_DL) == false)
			{
				this->Save_Trace_Log(this->m_csError_Code);
				this->Save_Trace_Log(_T("Fail,RESTORE_QCN"));
				throw(5);
			}
			else
			{
				this->Save_Trace_Log(_T("Pass,RESTORE_QCN"));
			}
		}
		//20191117
		Sleep(15000);
		//------------------------------
	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

int CARM_OP_QCM::Execute_MDM9X15_V1(void)
{
	//9x15平台“无代码锁定”下载

	time_t t_Start, t_End;
	CString csData;
	int iTime;


	try
	{
		//等同开机初始化时间
		//自动夹具模式下，要给出足够开机时间，先判定是否生成adb设备
		time(&t_Start);
		//
		do
		{
			Sleep(900);
			//
			time(&t_End);
			//
			iTime = (int)difftime(t_End, t_Start);

			//
			csData.Format(_T("INIT & Detect adb port ...... %ds"), iTime);
			this->Show_Status(csData);
			//
			if(iTime >= 10)
			{
				break;//一直没有adb设备，退出while
			}
		}
		while(this->FB_DEVICE_V1() == false);



		//探测是否有adb设备（用于修复异常模块）
		if(this->FB_DEVICE_V1() == false)
		{
			//------------------------------ 正常，没有adb设备，则是正常下载 ------------------------------


			//刷新COM参数
			this->Load_Com_Port_Params();



			//------------------------------ 检查串口是否存在 ------------------------------ 
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port) == true)
			{
				//DM口已经存在，则说明模块已预先开机，无需特别延迟
			}
			else
			{
				//DM口还不存在，需要探测，并额外给开机延迟时间

				//探测DM口生成
				if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 25) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(1);
				}


				//DM端口刚生成后，模块初始化未完成，模块无法下载
				Sleep(5000);
			}
			//------------------------------



			//------------------------------ 从模块中备份出QCN，FTM模式 ------------------------------ 
			if(this->m_bQCN_BACKUP == true)
			{
				if(this->BACKUP_QCN(this->m_str_Mbn_QCN_BU_RS) == false)
				{
					throw(2);
				}
			}
			//------------------------------


			//------------------------------ 把FW中的QCN文件导入模块 ------------------------------ 
			if(this->m_bQCN_DL == true)
			{
				if(this->RESTORE_QCN(this->m_str_Mbn_QCN_BU_RS, this->m_str_Mbn_QCN_DL) == false)
				{
					//紧急下载时，QDloader口无法下载QCN文件，所以可以忽略这个fail
					if(this->m_bFW_DL == true)
					{
						this->Show_Status(_T(""));
					}
					else
					{
						throw(5);
					}
				}
			}
			//------------------------------


			//------------------------------ 下载FW操作（包括假文件），下载模式 ------------------------------ 
			if(this->m_bFW_DL == true)
			{
				if(this->DL_FW_V3(true) != RTN_SUCCESS)
				{
					throw(3);
				}
			}
			//------------------------------
		}//if(this->FB_DEVICE_V1() == false
		else
		{
			//------------------------------ 异常，有adb设备 ------------------------------


			//最初下载时没有COM口
			this->m_iCom_Port = -1;


			//----------------------- 确定将下载的FW的byte总数 ----------------------- 
			int i;
			//清空发送Byte统计
			this->m_ul_Transmit_Bytes = 0;
			//计算下载文件的总大小
			this->m_ul_DL_All_Bytes = 0;

			for(i=0; i<MAX_MBN_FILE; i++)
			{
				if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
				}
			}

			//
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;

			//如果下载CEFS文件，就要增加CEFS文件的大小
			if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
			{
				this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
			}

			//Fastboot下载完成后，重新用协议下载的mbn文件
			this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I].ul_File_Size;

			//YAFFS2文件
			for(i=0; i<MAX_YAFFS2_FILE; i++)
			{
				if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Yaffs2_File_List[i].ul_File_Size;
				}
			}

			//IMG文件
			for(i=0; i<MAX_IMG_FILE; i++)
			{
				if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Img_File_List[i].ul_File_Size;
				}
			}

			//yaffs_head.aa
			if(this->m_str_Yaffs_Head_aa.b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_aa.ul_File_Size;
			}

			//yaffs_head.ab
			if(this->m_str_Yaffs_Head_ab.b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_ab.ul_File_Size;
			}
			//----------------------- 
		}



		//------------------------------ 在fastboot模式下载yaffs2和img文件 ------------------------------ 
		if(this->m_bFastboot_DL == true)
		{
			if(this->DL_FB_V3(true, true) == false)
			{
				throw(6);
			}

			//确认下载口
			if(this->Update_USB_DL_Port(this->m_iCom_Port, &this->m_iCom_Port) == false)
			{
				throw(6);
			}
			
			//刷新COM参数
			this->Load_Com_Port_Params();

			//下载最后的“真SBL2”文件
			if(this->DL_FW_SBL2() == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
		//------------------------------


		//------------------------------ 把先前备份的QCN导入模块 ------------------------------ 
		if(this->m_bQCN_RESTORE == true)
		{
			if(this->m_bFW_DL || this->m_bFastboot_DL)
			{
				//确认下载口
				if(this->Update_USB_DL_Port(this->m_iCom_Port, &this->m_iCom_Port) == false)
				{
					throw(6);
				}

				//刷新COM参数
				this->Load_Com_Port_Params();

				//模块下载重启后的初始化时间
				Sleep(3000);
			}

			//由于qcn操作无法重启模块，所以放在最后
			if(this->RESTORE_QCN(this->m_str_Mbn_QCN_BU_RS, this->m_str_Mbn_QCN_DL) == false)
			{
				throw(5);
			}
		}
		//------------------------------
	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

void CARM_OP_QCM::LOAD_TEMP_FW_FILE(const wchar_t * wcp_Cur_Exe_File_Path)
{
	//程序当前.exe运行路径
	this->m_csCurr_Exe_Path.Format(_T("%s"), wcp_Cur_Exe_File_Path);

	//假mbn文件
	if(this->m_eu_BB_Chip == MDM9X15)
	{
		//
		this->m_str_Mbn_SBL2_TMP.cs_Name.Format(_T("SBL2"));
		this->m_str_Mbn_SBL2_TMP.cs_Path.Format(_T("%s\\QCMM\\sbl2_tmp.mbn"), wcp_Cur_Exe_File_Path);
		this->m_str_Mbn_SBL2_TMP.b_Enable_DL = true;
		//
		this->m_str_Mbn_APPSBL_TMP.cs_Name.Format(_T("APPSBL"));
		this->m_str_Mbn_APPSBL_TMP.cs_Path.Format(_T("%s\\QCMM\\appsboot_tmp.mbn"), wcp_Cur_Exe_File_Path);
		this->m_str_Mbn_APPSBL_TMP.b_Enable_DL = true;
	}
	else
	{
		this->m_str_Mbn_SBL2_TMP.b_Enable_DL = false;
		this->m_str_Mbn_APPSBL_TMP.b_Enable_DL = false;
	}
}

bool CARM_OP_QCM::DL_Mbn_Partition_Table(void)
{
	try
	{
		//先发送Partition_Table_2文件
		if(this->m_str_Mbn_PT_2.b_Enable_DL == true)
		{
			//发送PT-2文件
			if(this->DL_Partition_Table_File(this->m_str_Mbn_PT_2) == false)
			{
				//为进度条而去掉PT-2文件的大小
				this->m_ul_Transmit_Bytes -= this->m_str_Mbn_PT_2.ul_File_Size;


				//发送“2文件”失败，才发送Partition_Table文件
				if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
		}
		else//没有“2文件”，才发送Partition_Table文件
		{
			//发送Partition_Table文件
			if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_V1(const wchar_t * wcp_FW_File_Path)
{
	//MDM6X00, QSC6270, MDM9X15
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int iHex_Quan = 0;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Hex_E.cs_Name.Format(_T("hex_e"));
		this->m_str_Hex_E.cs_Path.Format(_T(""));
		this->m_str_Hex_N.cs_Name.Format(_T("hex_n"));
		this->m_str_Hex_N.cs_Path.Format(_T(""));

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("cefs"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("QCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();

				//判定文件类型，载入.hex文件
				if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL)
				{
					if(iHex_Quan >= 2)
					{
						this->m_csError_Code.Format(_T("Error, There are more than 2 hex file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".HEX"), _T("\0"));
						//把Hex文件放入临时BUFF中
						strr_Hex_File[iHex_Quan].cs_Name.Format(_T("%s"), cs_FW_Name);
						strr_Hex_File[iHex_Quan].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						iHex_Quan++;
					}
				}//if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL

				//判定文件类型，载入.mbn文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//挑出“partition”文件
					if(wcscmp(cs_FW_Name, _T("PARTITION")) == 0)
					{
						if(this->m_str_Mbn_Partition_Table.b_Enable_DL == true)
						{
							this->m_csError_Code.Format(_T("ERROR, There are more than 1 partition file!"));
							throw(0);
						}
						else
						{
							this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Partition_Table.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Partition_Table.b_Enable_DL = true;
						}
					}
					else if(wcscmp(cs_FW_Name, _T("PARTITION2")) == 0)
					{
						if(this->m_str_Mbn_PT_2.b_Enable_DL == true)
						{
							this->m_csError_Code.Format(_T("ERROR, There are more than 1 partition-2 file!"));
							throw(0);
						}
						else
						{
							this->m_str_Mbn_PT_2.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_PT_2.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_PT_2.b_Enable_DL = true;
						}
					}
					else if(wcsstr(cs_FW_Name, _T("EFS")) != NULL)//挑出“CEFS”文件和“EFS”文件
					{
						if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
						{
							this->m_csError_Code.Format(_T("ERROR, There are more than 1 efs file!"));
							throw(0);
						}
						else
						{
							this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_CEFS.b_Enable_DL = true;
						}
					}
					else if(wcsstr(cs_FW_Name, _T("BODYTRACE")) != NULL)//挑出“BodytraceCore.mbn”文件
					{
						//正式工具，忽略、不处理“BodytraceCore.mbn”文件
//						::AfxMessageBox(cs_FW_Name);
					}
					else//其他用于下载的普通.mbn文件
					{
						//获取mbn文件的index，同时完成排序，确定下载顺序
						if(this->Get_Mbn_File_Index(cs_FW_Name, &j) == false)
						{
							throw(0);
						}

						//APPSBL文件下载文件名是“appsboot.mbn”，但指令中打包的文件名是“APPSBL”
						if(wcscmp(cs_FW_Name, _T("APPSBOOT")) == 0)
						{
							this->m_strr_Mbn_File_List[j].cs_Name.Format(_T("APPSBL"));
						}
						else
						{
							this->m_strr_Mbn_File_List[j].cs_Name.Format(_T("%s"), cs_FW_Name);
						}

						//
						this->m_strr_Mbn_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[j].b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL

				//判定文件类型，载入.qcn文件
				if(wcsstr(cs_FW_Name, _T(".QCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
						//把QCN文件放入BUFF中
//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".QCN")) != NULL

				//判定文件类型，载入.yaffs2文件
				if(wcsstr(cs_FW_Name, _T(".YAFFS2")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".YAFFS2"), _T("\0"));

					//获取yaffs2文件的index，同时完成排序，确定下载顺序
					if(this->Get_Yaffs2_File_Index(cs_FW_Name, &j) == true)//非法命名文件不处理
					{
						//把.yaffs2文件放入BUFF中
						switch(j)
						{
						case SYS_YAFFS2_FILE_I://挑出“fastboot flash system”文件，在fastboot中第一个下载
							{
								this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T("system"));
								this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
								this->m_strr_Yaffs2_File_List[j].b_Enable_DL = true;
							}
							break;
						case USER_YAFFS2_FILE_I://挑出“fastboot flash userdata”文件
							{
								this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T("userdata"));
								this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
								this->m_strr_Yaffs2_File_List[j].b_Enable_DL = true;
							}
							break;
						case RECOV_YAFFS2_FILE_I://挑出“recovery-image”文件
							{
								this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T("recoveryfs"));
								this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
								this->m_strr_Yaffs2_File_List[j].b_Enable_DL = true;
							}
							break;
						default:
							throw(0);
						}
					}
				}//if(wcsstr(cs_FW_Name, _T(".YAFFS2")) != NULL

				//判定文件类型，载入.img文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//获取yaffs2文件的index，同时完成排序，确定下载顺序
					if(this->Get_Img_File_Index(cs_FW_Name, &j) == false)
					{
						throw(0);
					}

					//把.img文件放入BUFF中
					switch(j)
					{
					case BOOT_IMG_FILE_I:
						{
							this->m_strr_Img_File_List[j].cs_Name.Format(_T("boot"));
							this->m_strr_Img_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Img_File_List[j].b_Enable_DL = true;
						}
						break;
					case RECOV_IMG_FILE_I:
						{
							this->m_strr_Img_File_List[j].cs_Name.Format(_T("recovery"));
							this->m_strr_Img_File_List[j].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Img_File_List[j].b_Enable_DL = true;
						}
						break;
					default:
						throw(0);
					}
				}//if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL


				//判定文件类型，载入.aa文件
				if(wcsstr(cs_FW_Name, _T(".AA")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".AA"), _T("\0"));

					this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("cache"));
					this->m_str_Yaffs_Head_aa.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Yaffs_Head_aa.b_Enable_DL = true;
				}//if(wcsstr(cs_FW_Name, _T(".AA")) != NULL


				//判定文件类型，载入.ab文件
				if(wcsstr(cs_FW_Name, _T(".AB")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".AB"), _T("\0"));

					this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("cache"));
					this->m_str_Yaffs_Head_ab.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Yaffs_Head_ab.b_Enable_DL = true;
				}//if(wcsstr(cs_FW_Name, _T(".AB")) != NULL
			}
		}//while(b_Found


		//关闭find
		cla_Finder.Close();

		
		//应该有2个hex文件
		if(iHex_Quan != 2)
		{
			this->m_csError_Code.Format(_T("Error, There should be two hex files!"));
			throw(0);
		}

		//根据hex文件的长度，判定哪个是E文件
		if(strr_Hex_File[0].cs_Name.GetLength() > strr_Hex_File[1].cs_Name.GetLength())
		{
			this->m_str_Hex_E.cs_Name.Format(_T("%s"), strr_Hex_File[0].cs_Name);
			this->m_str_Hex_E.cs_Path.Format(_T("%s"), strr_Hex_File[0].cs_Path);

			this->m_str_Hex_N.cs_Name.Format(_T("%s"), strr_Hex_File[1].cs_Name);
			this->m_str_Hex_N.cs_Path.Format(_T("%s"), strr_Hex_File[1].cs_Path);
		}
		else if(strr_Hex_File[0].cs_Name.GetLength() < strr_Hex_File[1].cs_Name.GetLength())
		{
			this->m_str_Hex_E.cs_Name.Format(_T("%s"), strr_Hex_File[1].cs_Name);
			this->m_str_Hex_E.cs_Path.Format(_T("%s"), strr_Hex_File[1].cs_Path);

			this->m_str_Hex_N.cs_Name.Format(_T("%s"), strr_Hex_File[0].cs_Name);
			this->m_str_Hex_N.cs_Path.Format(_T("%s"), strr_Hex_File[0].cs_Path);
		}
		else
		{
			this->m_csError_Code.Format(_T("Error, The name of hex file is wrong!"));
			
		}
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}
bool CARM_OP_QCM::LOAD_FW_FILE_V2_MDM9X06(const wchar_t * wcp_FW_File_Path)
{
	//MDM9X06
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;

			//20180706
			this->m_strr_Mbn_File_List_Ext[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List_Ext[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List_Ext[j].b_Enable_DL = false;
		}
		mMbn_File_NUM =0;

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//-------------------------
		int iFd=-1;
		CString strMbnPath;

		//20201218 有firehose文件夹里的文件路径的场景
		int IFind = -1;
		IFind = cs_FW_Dir.Find(_T("\\firehose"));
		if(IFind != -1)
		{
		   strMbnPath = cs_FW_Dir.Left(IFind);

		   iFd = strMbnPath.ReverseFind('\\');
		   strMbnPath = cs_FW_Dir.Left(iFd);

		}
		else
		{
			iFd = cs_FW_Dir.ReverseFind('\\');
			strMbnPath = cs_FW_Dir.Left(iFd);
		}

	
		strMbnPath+= _T("\\mbn\\");
		Save_Trace_Log(strMbnPath);


		mMbn_File_NUM =0;
		FindMbnFile(strMbnPath);
		//-------------------------


		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;

		//20191111
		//---------------------------------------------------
		if ((1 == m_iFirhose_DB_Path)||(1 == m_iFirhose_DB))
		{
			m_iMDM9X07_NEW_FLAG =1;
		}
		//---------------------------------------------------



		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		if (0 == m_iFirhose_DB) //离线方式
		{

			if (TRUE == this->m_bSaharaOnly) //如果界面菜单中选择SaharaOnly，则认为只能sahara下载
			{
				if (iFirehoseFind>=0)//载入路径中本身就带有firehose文件夹的话,
				{
					cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind);//去掉firehose那一层目录

					bFirehoseFind = FALSE;
					this->m_iMDM9X07_NEW_FLAG =0;
				}

			}
			else
			{
				if (iFirehoseFind>=0)//载入路径中本身就带有firehose文件夹的话，就必须要firehose方式升级 //客户升级工具 20200113
				{
					cs_FW_Fire_hoseDir = cs_FW_Dir;
					bFirehoseFind = TRUE;
				}
				//------20200113-针对客户升级---如果有firehose文件夹就必须载入firehose文件里面的文件进行下载-----------------
				else//检查载入的文件路径没有firehose，但可能是存在firehose文件夹的情况--非法不给载入
				{

					cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

					b_Found = cla_Finder.FindFile(cs_Finder_Dir);

					while(b_Found) 
					{
						b_Found = cla_Finder.FindNextFile();

						if(cla_Finder.IsDots())
						{
							continue;//找到的是当前目录或上级目录则跳过
						}

						if(cla_Finder.IsDirectory())	//如果是文件夹
						{
							cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
							cs_FW_Name.MakeUpper();//统一大写
							if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
							{
								cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
								cs_FW_Fire_hoseDir = cs_FW_Dir;
								bFirehoseFind = TRUE;

								this->m_iMDM9X07_NEW_FLAG =1;

								break;
							}
						}
					}

				}
			}


			//-------------------------------------------------------------------------------------------------

		} 
		else if(((1 == m_iFirhose_DB) && (1 == m_iAutoDL_Flag))//在线方式 Firehose  自动Firmware载入
			|| (1 == m_iFirhose_DB_Path)) //Firmware路径中有Firehose
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else //查找firehose文件夹
			{
				cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

				b_Found = cla_Finder.FindFile(cs_Finder_Dir);

				while(b_Found) 
				{
					b_Found = cla_Finder.FindNextFile();

					if(cla_Finder.IsDots())
					{
						continue;//找到的是当前目录或上级目录则跳过
					}

					if(cla_Finder.IsDirectory())	//如果是文件夹
					{
						cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
						cs_FW_Name.MakeUpper();//统一大写
						if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
						{
							cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
							cs_FW_Fire_hoseDir = cs_FW_Dir;
							bFirehoseFind = TRUE;
							break;
						}
					}
				}

			}

		}
		else //20190403
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}	
		}

		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p4K_b256K_update.xml\rawprogram_nand_p4K_b256K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p4K_b256K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
				}
				//挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn

				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}

				if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}

				//寻找 mbn 驱动文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_nand_firehose_9x07.mbn”文件
					//if if(1 == m_iFirhose_DB) //在线方式 Firehose
					//{
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;

						//保存全路径
						this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);

						//m_iMDM9X07_NEW_FLAG =1;
					}
					//}


					//挑出“ENPRG9x06.mbn”文件
					if(wcscmp(cs_FW_Name, _T("ENPRG9X06")) == 0)
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
					}


					//挑出“NPRG9x06.mbn”文件
					if(wcscmp(cs_FW_Name, _T("NPRG9X06")) == 0)
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						//						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
						//把QCN文件放入BUFF中
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					// 					sbl1.mbn
					// 					13:10:44: INFO: Looking for file '../tz.mbn'
					// 					13:10:44: INFO: Looking for file '../rpm.mbn'
					// 					13:10:44: INFO: Looking for file '../appsboot.mbn'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-boot.img'
					// 					13:10:44: INFO: Looking for file '../mdm-perf-recovery-image-mdm9607-perf.ubi'
					// 					13:10:44: INFO: Looking for file '../NON-HLOS.ubi'
					// 					13:10:44: INFO: Looking for file '../usrdata.ubi'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-sysfs.ubi'
					for(num=0;num<Firehose_File_NUM;num++)
					{
						if (Firehose_File[num].Firehose_File == cs_FW_Name)
						{
							Firehose_File[num].dis_flag =1;
						}
					}
					//Firehose_File[11].dis_flag =1;//E:\Firmware\Stanley\app_atc_pipe(0725)\update\firehose\partition_complete_p4K_b256K.mbn

					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
					//寻找 mbn 驱动文件
					if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

						//------------------------------------------

						//挑出“ENPRG9X06.mbn”文件
						if(wcscmp(cs_FW_Name, _T("ENPRG9X06")) == 0)
						{
							this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Emerg.b_Enable_DL = true;
						}


						//挑出“NPRG9X06.mbn”文件
						if(wcscmp(cs_FW_Name, _T("NPRG9X06")) == 0)
						{
							this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Norm.b_Enable_DL = true;
						}
					}

					//客户无需下载QCN
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}

		//关闭find
		cla_Finder.Close();

		if (TRUE == bFirehoseFind)
		{
			if(this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				this->Show_Out(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if(this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				this->Show_Out(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径

			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
			//this->m_csFW_File_Path.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);
		}
		else
		{
			//检查是否找到文件
			if(this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				this->Show_Out(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No ENPRG9x07.mbn file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No NPRG9x07.mbn file!"));
				throw(0);
			}

			//从“partition_nand.xml”文件中解析“下载文件”
			if(this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				this->Show_Out(_T("FAIL, Load_Partition_Xml_Data"));
				throw(0);
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::LOAD_FW_FILE_V2(const wchar_t * wcp_FW_File_Path)
{
	//MDM9X07
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;

	//20220223
	if (NULL != wcsstr(m_csOC, _T("QDM002")))
	{
		return true;
	}

	if (NULL != wcsstr(m_csOC, _T("QDM040")) || NULL != wcsstr(m_csOC, _T("QDM059")))
	{
		return true;
	}


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//20210226
		this->m_str_QDE007_HEX.cs_Name.Format(_T(""));
		this->m_str_QDE007_HEX.cs_Path.Format(_T(""));
		this->m_str_QDE007_HEX.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}
		
		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;
#if 0
		//20210329
		if ((_T("QDM002EUEF-D10-CAAAA") == m_csOC)
			|| (_T("QDM002NAEF-D10-CAAAA") == m_csOC)
			|| (_T("QDM002EUEF-D10-BAAAA") == m_csOC)
			|| (_T("QDM002NAEF-D10-BAAAA") == m_csOC))
		{
			if (false == this->LOAD_FW_FILE_QDM002(wcp_FW_File_Path))
			{
				this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDM002 fail!"));
				//
				this->Show_Out(_T("Error, LOAD_FW_FILE_QDM002 fail!"));

				throw(0);
			}
			else
			{
				this->Show_Out(_T("LOAD_FW_FILE_QDM002 Pass!"));
			}
		}
#endif
		//QDE006EUEF - N06 - AAAAA
		if (_T("QDE006EUEF-N06-AAAAA") == m_csOC)//QDE006 MCU2的固件版本
		{
			if (false == this->LOAD_FW_FILE_QDE006(wcp_FW_File_Path))
			{
				this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDE006 fail!"));
				//
				this->Show_Out(_T("Error, LOAD_FW_FILE_QDE006 fail!"));

				throw(0);
			}
			else
			{
				this->Show_Out(_T("LOAD_FW_FILE_QDE006 Pass!"));
				return true;
			}
		}
		else
		{
			//....
		}


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;

		//20191111
		//---------------------------------------------------
		if ((1 == m_iFirhose_DB_Path)||(1 == m_iFirhose_DB))
		{
			m_iMDM9X07_NEW_FLAG =1;
		}
		//---------------------------------------------------



		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		if (0 == m_iFirhose_DB) //离线方式
		{

			if (TRUE == this->m_bSaharaOnly) //如果界面菜单中选择SaharaOnly，则认为只能sahara下载
			{
				if (iFirehoseFind>=0)//载入路径中本身就带有firehose文件夹的话,
				{
					cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind);//去掉firehose那一层目录

					bFirehoseFind = FALSE;
					this->m_iMDM9X07_NEW_FLAG =0;
				}

			}
			else
			{
				if (iFirehoseFind>=0)//载入路径中本身就带有firehose文件夹的话，就必须要firehose方式升级 //客户升级工具 20200113
				{
					cs_FW_Fire_hoseDir = cs_FW_Dir;
					bFirehoseFind = TRUE;
				}
				//------20200113-针对客户升级---如果有firehose文件夹就必须载入firehose文件里面的文件进行下载-----------------
				else//检查载入的文件路径没有firehose，但可能是存在firehose文件夹的情况--非法不给载入
				{

					cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

					b_Found = cla_Finder.FindFile(cs_Finder_Dir);

					while(b_Found) 
					{
						b_Found = cla_Finder.FindNextFile();

						if(cla_Finder.IsDots())
						{
							continue;//找到的是当前目录或上级目录则跳过
						}

						if(cla_Finder.IsDirectory())	//如果是文件夹
						{
							cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
							cs_FW_Name.MakeUpper();//统一大写
							if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
							{
								cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
								cs_FW_Fire_hoseDir = cs_FW_Dir;
								bFirehoseFind = TRUE;

								this->m_iMDM9X07_NEW_FLAG =1;

								break;
							}
						}
					}

				}
			}
			

			//-------------------------------------------------------------------------------------------------
			
		} 
		else if(((1 == m_iFirhose_DB) && (1 == m_iAutoDL_Flag))//在线方式 Firehose  自动Firmware载入
			|| (1 == m_iFirhose_DB_Path)) //Firmware路径中有Firehose
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else //查找firehose文件夹
			{
				cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

				b_Found = cla_Finder.FindFile(cs_Finder_Dir);

				while(b_Found) 
				{
					b_Found = cla_Finder.FindNextFile();

					if(cla_Finder.IsDots())
					{
						continue;//找到的是当前目录或上级目录则跳过
					}

					if(cla_Finder.IsDirectory())	//如果是文件夹
					{
						cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
						cs_FW_Name.MakeUpper();//统一大写
						if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
						{
							cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
							cs_FW_Fire_hoseDir = cs_FW_Dir;
							bFirehoseFind = TRUE;
							break;
						}
					}
				}

			}

		}
		else //20190403
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}	
		}
		
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p4K_b256K_update.xml\rawprogram_nand_p4K_b256K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p4K_b256K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
				}
              //挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn
				
				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}
			
				//20210226 QDE007
				if ((_T("QDE007NAEF-M21-AAAAA") == m_csOC)
					|| (_T("QDE007NAEF-M21-BAAAA") == m_csOC))
				{
					//QDE007NAEFM21_34D1015930.hex
					if (wcsstr(cs_FW_Name, m_csMCU_Name) != NULL)
					//if (_T("QDE007_V1.1.HEX") == cs_FW_Name)
					{
						//加载数据
						this->m_str_QDE007_HEX.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_QDE007_HEX.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_QDE007_HEX.b_Enable_DL = true;
					}
					
					this->m_str_Mbn_CEFS.cs_Name= _T("");
					this->m_str_Mbn_CEFS.cs_Path = _T("");
					this->m_str_Mbn_CEFS.b_Enable_DL = false;
				}
				else
				{
					if (wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
				}

				//寻找 mbn 驱动文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_nand_firehose_9x07.mbn”文件
					//if if(1 == m_iFirhose_DB) //在线方式 Firehose
					//{
						if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
						{
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;

							//保存全路径
							this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);

							//m_iMDM9X07_NEW_FLAG =1;
						}
					//}


					//挑出“ENPRG9x07.mbn”文件
					if((wcscmp(cs_FW_Name, _T("ENPRG9X07")) == 0)
						||(wcscmp(cs_FW_Name, _T("ENPRG9X65")) == 0))
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
					}


					//挑出“NPRG9x07.mbn”文件
					if((wcscmp(cs_FW_Name, _T("NPRG9X07")) == 0)
						||(wcscmp(cs_FW_Name, _T("NPRG9X65")) == 0))
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;
					}
				}
				//--------------------
				//寻找 ELF 驱动文件
				if (wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//------------------------------------------
					//挑出“prog_firehose_ag215s_nand.elf”文件
					if (wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;

						//保存全路径
						this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);
					}
				}
				//----------------------
				//20210226 QDE007
				if ((_T("QDE007NAEF-M21-AAAAA") != m_csOC)
					&& (_T("QDE007NAEF-M21-BAAAA") != m_csOC))
				{
					//判定文件类型，载入.xqcn文件
					if (wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
					{
						if (this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
						{
							this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
							throw(0);
						}
						else
						{
							//去掉文件类型显示
							//						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
							//把QCN文件放入BUFF中
							//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
						}
					}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
				}
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
// 					sbl1.mbn
// 					13:10:44: INFO: Looking for file '../tz.mbn'
// 					13:10:44: INFO: Looking for file '../rpm.mbn'
// 					13:10:44: INFO: Looking for file '../appsboot.mbn'
// 					13:10:44: INFO: Looking for file '../mdm9607-perf-boot.img'
// 					13:10:44: INFO: Looking for file '../mdm-perf-recovery-image-mdm9607-perf.ubi'
// 					13:10:44: INFO: Looking for file '../NON-HLOS.ubi'
// 					13:10:44: INFO: Looking for file '../usrdata.ubi'
// 					13:10:44: INFO: Looking for file '../mdm9607-perf-sysfs.ubi'
					for(num=0;num<Firehose_File_NUM;num++)
					{
						if (Firehose_File[num].Firehose_File == cs_FW_Name)
						{
							Firehose_File[num].dis_flag =1;
						}
					}
					//Firehose_File[11].dis_flag =1;//E:\Firmware\Stanley\app_atc_pipe(0725)\update\firehose\partition_complete_p4K_b256K.mbn

					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
					//寻找 mbn 驱动文件
					if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

						//------------------------------------------
						
						//挑出“ENPRG9x07.mbn”文件
						if((wcscmp(cs_FW_Name, _T("ENPRG9X07")) == 0)
							||(wcscmp(cs_FW_Name, _T("ENPRG9X65")) == 0))
						{
							this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Emerg.b_Enable_DL = true;
						}


						//挑出“NPRG9x07.mbn”文件
						if((wcscmp(cs_FW_Name, _T("NPRG9X07")) == 0)
							||(wcscmp(cs_FW_Name, _T("NPRG9X65")) == 0))
						{
							this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Norm.b_Enable_DL = true;
						}
					}

					//客户无需下载QCN
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}

		//关闭find
		cla_Finder.Close();

		if (TRUE == bFirehoseFind)
		{
			if(this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				this->Show_Out(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if(this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				this->Show_Out(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径
			
			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
			//this->m_csFW_File_Path.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);
		}
		else
		{
			//检查是否找到文件
			if(this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				this->Show_Out(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No ENPRG9x07.mbn file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No NPRG9x07.mbn file!"));
				throw(0);
			}
		
			//从“partition_nand.xml”文件中解析“下载文件”
			if(this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				this->Show_Out(_T("FAIL, Load_Partition_Xml_Data"));
				throw(0);
			}

			//20210226 QDE007
			if ((_T("QDE007NAEF-M21-AAAAA") == m_csOC)
				|| (_T("QDE007NAEF-M21-BAAAA") == m_csOC))
			{
				if (false == this->m_str_QDE007_HEX.b_Enable_DL)
				{
					this->m_csError_Code.Format(_T("FAIL, No QDE007NAEFM21_34D1015930.hex file!"));
					this->Show_Out(_T("FAIL, No QDE007NAEFM21_34D1015930.hex file!"));
					this->Save_Trace_Log(_T("FAIL, No QDE007NAEFM21_34D1015930.hex file!"));

					throw(0);
				}
				else
				{
					CString  strD;
					strD.Format(_T("Find %s file Pass"), this->m_str_QDE007_HEX.cs_Path);
					this->Show_Out(strD);

					if (false == this->CreatQDE007_Jlink_CMD())
					{
						this->m_csError_Code.Format(_T("FAIL, QDE007_Jlink_CMD file Fail!"));
						this->Show_Out(_T("FAIL, QDE007_Jlink_CMD file Fail!"));
						this->Save_Trace_Log(_T("FAIL, QDE007_Jlink_CMD file Fail!"));
						throw(0);
					}
					else
					{
						this->Show_Out(_T("QDE007_Jlink_CMD file Pass!"));
						//this->Save_Trace_Log(_T("QDE007_Jlink_CMD file Pass!"));
					}
				}
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}
		
	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::CreatQDE007_Jlink_CMD(void)
{
	//

	//device LPC1768		//选择MCU型号
	//	usb 0
	//	si 1				//选择swd接口
	//	speed 4000			//选择速度
	//	erase				//擦除
	//	sleep 400
	//	loadfile "D:\software\WeChat Files\sezai1014440164\FileStorage\File\2021-02\Danlow_QDE007-NA\34VB011900.hex"	0x00//选择你要下载的文件，后面是FW烧录到目标芯片的地址
	//	sleep 100
	//	r
	//	g
	//	q

	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\QDE007\\%d\\eraseAndFlash.jlink"), this->m_csCurr_Exe_Path, m_iClass_Idx);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();

		csData.Format(_T("device LPC1768\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("usb 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("si 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("speed 4000\n"));
		Cmd_File.WriteString(csData);

		//csData.Format(_T("erase\n"));
		//Cmd_File.WriteString(csData);

		csData.Format(_T("sleep 400\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("loadfile \"%s\"\n"), this->m_str_QDE007_HEX.cs_Path);
		Cmd_File.WriteString(csData);

		csData.Format(_T("sleep 100\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("loadfile \"%s\"\n"), this->m_str_QDE007_HEX.cs_Path);
		Cmd_File.WriteString(csData);

		csData.Format(_T("sleep 100\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("r\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("g\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("q\n"));
		Cmd_File.WriteString(csData);


		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
		return true;
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return false;

	}

}
bool CARM_OP_QCM::LOAD_FW_FILE_V2_EXT(const wchar_t * wcp_FW_File_Path)
{
	//MDM9X40
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;

		//20191111
		//---------------------------------------------------
		if ((1 == m_iFirhose_DB_Path)||(1 == m_iFirhose_DB))
		{
			m_iMDM9X07_NEW_FLAG =1;
		}
		//---------------------------------------------------


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;
		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		if (0 == m_iFirhose_DB) //离线方式
		{
			if (TRUE == this->m_bSaharaOnly) //如果界面菜单中选择SaharaOnly，则认为只能sahara下载
			{
				if (iFirehoseFind>=0)//载入路径中本身就带有firehose文件夹的话,
				{
					cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind);//去掉firehose那一层目录

					bFirehoseFind = FALSE;
					this->m_iMDM9X07_NEW_FLAG =0;
				}
			}
			else
			{
				if (iFirehoseFind>=0)
				{
					cs_FW_Fire_hoseDir = cs_FW_Dir;
					bFirehoseFind = TRUE;
				}
				//------20200113-针对客户升级---如果有firehose文件夹就必须载入firehose文件里面的文件进行下载-----------------
				else//检查载入的文件路径没有firehose，但可能是存在firehose文件夹的情况--非法不给载入
				{

					cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

					b_Found = cla_Finder.FindFile(cs_Finder_Dir);

					while(b_Found) 
					{
						b_Found = cla_Finder.FindNextFile();

						if(cla_Finder.IsDots())
						{
							continue;//找到的是当前目录或上级目录则跳过
						}

						if(cla_Finder.IsDirectory())	//如果是文件夹
						{
							cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
							cs_FW_Name.MakeUpper();//统一大写
							if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
							{
								cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
								cs_FW_Fire_hoseDir = cs_FW_Dir;
								bFirehoseFind = TRUE;
								this->m_iMDM9X07_NEW_FLAG =1;
								break;
							}
						}
					}
				}
			}
			
			//-------------------------------------------------------------------------------------------------
		} 
		else if(((1 == m_iFirhose_DB) &&(1 == m_iAutoDL_Flag))//在线方式 Firehose
			|| (1 == m_iFirhose_DB_Path)) //Firmware路径中有Firehose
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else //查找firehose文件夹
			{
				cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

				b_Found = cla_Finder.FindFile(cs_Finder_Dir);

				while(b_Found) 
				{
					b_Found = cla_Finder.FindNextFile();

					if(cla_Finder.IsDots())
					{
						continue;//找到的是当前目录或上级目录则跳过
					}

					if(cla_Finder.IsDirectory())	//如果是文件夹
					{
						cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
						cs_FW_Name.MakeUpper();//统一大写
						if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
						{
							cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
							cs_FW_Fire_hoseDir = cs_FW_Dir;
							bFirehoseFind = TRUE;
							break;
						}
					}
				}

			}

		}
		else //20190403
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
		}
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p4K_b256K_update.xml\rawprogram_nand_p4K_b256K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p4K_b256K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
				}
				//挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn

				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}

				if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}

				//寻找 mbn 驱动文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_nand_firehose_9x07.mbn”文件
					//if (m_bSAHARA_DL_Switch == false) //暂时先关闭 20180210
					{					
						if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
						{
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;
							//保存全路径
							this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);


							m_iMDM9X07_NEW_FLAG =1;
						}
					}

					//挑出“ENPRG9x07.mbn”文件
					if(wcscmp(cs_FW_Name, _T("ENPRG9X45")) == 0)
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
					}


					//挑出“NPRG9x07.mbn”文件
					if(wcscmp(cs_FW_Name, _T("NPRG9X45")) == 0)
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						//						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
						//把QCN文件放入BUFF中
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			//20200117
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					// 					sbl1.mbn
					// 					13:10:44: INFO: Looking for file '../tz.mbn'
					// 					13:10:44: INFO: Looking for file '../rpm.mbn'
					// 					13:10:44: INFO: Looking for file '../appsboot.mbn'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-boot.img'
					// 					13:10:44: INFO: Looking for file '../mdm-perf-recovery-image-mdm9607-perf.ubi'
					// 					13:10:44: INFO: Looking for file '../NON-HLOS.ubi'
					// 					13:10:44: INFO: Looking for file '../usrdata.ubi'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-sysfs.ubi'
					for(num=0;num<Firehose_File_NUM;num++)
					{
						if (Firehose_File[num].Firehose_File == cs_FW_Name)
						{
							Firehose_File[num].dis_flag =1;
						}
					}
					//Firehose_File[11].dis_flag =1;//E:\Firmware\Stanley\app_atc_pipe(0725)\update\firehose\partition_complete_p4K_b256K.mbn

					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
					//寻找 mbn 驱动文件
					if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

						//------------------------------------------

						//挑出“ENPRG9x07.mbn”文件
						if(wcscmp(cs_FW_Name, _T("ENPRG9X45")) == 0)
						{
							this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Emerg.b_Enable_DL = true;
						}


						//挑出“NPRG9x07.mbn”文件
						if(wcscmp(cs_FW_Name, _T("NPRG9X45")) == 0)
						{
							this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Norm.b_Enable_DL = true;
						}
					}

					//客户无需下载QCN
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}


		//关闭find
		cla_Finder.Close();

		if (1 == m_iMDM9X07_NEW_FLAG)
		{
			if(this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if(this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径
			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
		}
		else
		{
			//检查是否找到文件
			if(this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x45.mbn file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x45.mbn file!"));
				throw(0);
			}

			//从“partition_nand.xml”文件中解析“下载文件”
			if(this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				throw(0);
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

//BG95 MDM9X05
bool CARM_OP_QCM::LOAD_FW_FILE_V6_EXT(const wchar_t * wcp_FW_File_Path)

{
	//MDM9X05
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;

	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;






		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;
		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		
		if (iFirehoseFind>=0)
		{
			cs_FW_Fire_hoseDir = cs_FW_Dir;
			bFirehoseFind = TRUE;
		}
		else //查找firehose文件夹
		{
			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}

				if(cla_Finder.IsDirectory())	//如果是文件夹
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					cs_FW_Name.MakeUpper();//统一大写
					if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
					{
						cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
						cs_FW_Fire_hoseDir = cs_FW_Dir;
						bFirehoseFind = TRUE;
						break;
					}
				}
			}
			if (FALSE == bFirehoseFind)//20200113 MDM9X05平台就仅仅支持firehose方式升级
			{
				AfxMessageBox(_T("Please load firehose file"));
				this->m_csError_Code.Format(_T("Please load firehose file"));
				throw(0);
			}

		}

	
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p2K_b128K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p2K_b128K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
				}
				//挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn

				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}

				if(wcsstr(cs_FW_Name, _T("EFS2.MBN")) != NULL)//判断是不是“efs2.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}

				//寻找 elf 驱动文件
				if(wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//------------------------------------------
					//挑出“prog_firehose_nand_mdm9x05.elf”文件

					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;
						//保存全路径
						this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);

						m_iMDM9X07_NEW_FLAG =1;
					}
				}
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					
					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("EFS2.MBN")) != NULL)//判断是不是“efs2.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}				
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}

		//关闭find
		cla_Finder.Close();

		if(this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}
		//软件包的路径

		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);



		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::LOAD_FW_FILE_V6(const wchar_t * wcp_FW_File_Path)

{
	//MDM9X06
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;

	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;

			//20180706
			this->m_strr_Mbn_File_List_Ext[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List_Ext[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List_Ext[j].b_Enable_DL = false;
		}

		mMbn_File_NUM =0;

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//-------------------------
		int iFd=-1;
		CString strMbnPath;

		iFd = cs_FW_Dir.ReverseFind('\\');
		strMbnPath = cs_FW_Dir.Left(iFd);
		strMbnPath+= _T("\\mbn\\");
		mMbn_File_NUM =0;
		FindMbnFile(strMbnPath);
		//-------------------------

		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;
		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		if (0 == m_iFirhose_DB) //离线方式
		{
			if (iFirehoseFind>=0)//-----------客户升级场景下仅支持Sahara方式，如果载入firehose则认为是违法报错 20200113
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
				//BG96 仅支持Sahara方式升级
// 				AfxMessageBox(_T("Please load Sahara file"));
// 				this->m_csError_Code.Format(_T("Please load Sahara file"));
// 				throw(0);

			}
		} 
		else if(((1 == m_iFirhose_DB) &&(1 == m_iAutoDL_Flag) )//在线方式 Firehose
			|| (1 == m_iFirhose_DB_Path)) //Firmware路径中有Firehose
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else //查找firehose文件夹
			{
				cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

				b_Found = cla_Finder.FindFile(cs_Finder_Dir);

				while(b_Found) 
				{
					b_Found = cla_Finder.FindNextFile();

					if(cla_Finder.IsDots())
					{
						continue;//找到的是当前目录或上级目录则跳过
					}

					if(cla_Finder.IsDirectory())	//如果是文件夹
					{
						cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
						cs_FW_Name.MakeUpper();//统一大写
						if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
						{
							cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
							cs_FW_Fire_hoseDir = cs_FW_Dir;
							bFirehoseFind = TRUE;
							break;
						}
					}
				}

			}

		}
		else
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
		}
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p4K_b256K_update.xml\rawprogram_nand_p4K_b256K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p4K_b256K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
				}
				//挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn

				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}

				if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}

				//寻找 mbn 驱动文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_nand_firehose_9x07.mbn”文件
					//if (m_bSAHARA_DL_Switch == false)
					//{
						if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
						{
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;

							//保存全路径
							this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);

							m_iMDM9X07_NEW_FLAG =1;
						}
					//}


					//挑出“ENPRG9x06.mbn”文件
					if(wcscmp(cs_FW_Name, _T("ENPRG9X06")) == 0)
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
					}


					//挑出“NPRG9x06.mbn”文件
					if(wcscmp(cs_FW_Name, _T("NPRG9X06")) == 0)
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						//						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
						//把QCN文件放入BUFF中
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					// 					sbl1.mbn
					// 					13:10:44: INFO: Looking for file '../tz.mbn'
					// 					13:10:44: INFO: Looking for file '../rpm.mbn'
					// 					13:10:44: INFO: Looking for file '../appsboot.mbn'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-boot.img'
					// 					13:10:44: INFO: Looking for file '../mdm-perf-recovery-image-mdm9607-perf.ubi'
					// 					13:10:44: INFO: Looking for file '../NON-HLOS.ubi'
					// 					13:10:44: INFO: Looking for file '../usrdata.ubi'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-sysfs.ubi'
					for(num=0;num<Firehose_File_NUM;num++)
					{
						if (Firehose_File[num].Firehose_File == cs_FW_Name)
						{
							Firehose_File[num].dis_flag =1;
						}
					}
					//Firehose_File[11].dis_flag =1;//E:\Firmware\Stanley\app_atc_pipe(0725)\update\firehose\partition_complete_p4K_b256K.mbn

					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
					//寻找 mbn 驱动文件
					if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

						//------------------------------------------

						//挑出“ENPRG9x07.mbn”文件
						if(wcscmp(cs_FW_Name, _T("ENPRG9X06")) == 0)
						{
							this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Emerg.b_Enable_DL = true;
						}


						//挑出“NPRG9x07.mbn”文件
						if(wcscmp(cs_FW_Name, _T("NPRG9X06")) == 0)
						{
							this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Norm.b_Enable_DL = true;
						}
					}

					//客户无需下载QCN
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}

		//关闭find
		cla_Finder.Close();

		if (1 == m_iMDM9X07_NEW_FLAG)
		{
			if(this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if(this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径

			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
			//this->m_csFW_File_Path.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);
		}
		else
		{
			//检查是否找到文件
			if(this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x06.mbn file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x06.mbn file!"));
				throw(0);
			}

			//从“partition_nand.xml”文件中解析“下载文件”
			if(this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				throw(0);
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::Load_Partition_Xml_Data(const wchar_t * wcp_Xml_File, const wchar_t * wcp_Dir_Path)
{
	CStdioFile cla_XML_File;
	CString csData, csrBuff_List[8], csFW_Image, csFW_Name;
	int iQuan, i, iIndex;
	MBN_FILE_S str_Mbn_Temp;

	CString cs_sbl_Name=_T("");
	CString cs_sbl_path=_T("");
	BOOL   bHasSbl = FALSE;


	try
	{
		//打开 partition_nand.xml 文件
		if(cla_XML_File.Open(wcp_Xml_File, (CFile::modeRead | CFile::modeNoTruncate | CFile::typeText)) == NULL)
		{
			//打开目标文件失败
			this->m_csError_Code.Format(_T("ERROR, Load_Partition_Xml_Data, Open xml file fail!"));
			::AfxMessageBox(this->m_csError_Code);
			throw(0);
		}

		//定位到头
		cla_XML_File.SeekToBegin();


		//
		csFW_Image.Format(_T(""));
		csFW_Name.Format(_T(""));

		//针对9x07 做个改进 20170923
		int iMdnIndex =0;


		//循环读取数据
		while(cla_XML_File.ReadString(csData) != NULL)
		{
			//先判定是否有关键词
			if(wcsstr(csData, _T("type=\"string\">")) == NULL)
			{
				//无关键词
				continue;
			}

			//有关键词，开始处理
			//<name length="16" type="string">0:SBL</name>
			//<img_name type="string">sbl1.mbn</img_name>

			//分段提取
			this->m_cla_GFC.WCSTOK_STRING_T_C(csData, _T("<>"), csrBuff_List, &iQuan);

			//
			if(iQuan >= 8)
			{
				this->m_csError_Code.Format(_T("ERROR, Load_Partition_Xml_Data, Buff overload fail!"));
				::AfxMessageBox(this->m_csError_Code);
				throw(0);
			}

			//找关键词的“开始”
			for(i=0; i<iQuan; i++)
			{
				if(wcsstr(csrBuff_List[i], _T("name length=")) != NULL)
				{
					//image
					csFW_Image.Format(_T("%s"), csrBuff_List[i+1]);
					//成功提取image，退出循环
					break;
				}

				if(wcsstr(csrBuff_List[i], _T("img_name type=")) != NULL)
				{
					//文件名
					csFW_Name.Format(_T("%s"), csrBuff_List[i+1]);
					//成功提取文件名，退出循环
					break;
				}
			}//for(i=0; i<iQuan; i++
			//
			if(i >= iQuan)
			{
				this->m_csError_Code.Format(_T("ERROR, Load_Partition_Xml_Data, Decode data fail!"));
				::AfxMessageBox(this->m_csError_Code);
				throw(0);
			}


			//判断两个关键词是否都有数据了
			if(((csFW_Image.GetLength() > 0) && (csFW_Name.GetLength() > 0))
				//20181211
				//<img_name type="string"></img_name>
				&&(csFW_Name.Find(_T("\/")) == -1))
			{
				//临时存放
				str_Mbn_Temp.cs_Name.Format(_T("%s"), csFW_Image);
				str_Mbn_Temp.cs_Path.Format(_T("%s\\%s"), wcp_Dir_Path, csFW_Name);

				//统一大写
				csFW_Image.MakeUpper();
				csFW_Name.MakeUpper();


				//
				if(wcsstr(csFW_Name, _T("PARTITION")) != NULL)//判断是不是“partition.mbn”
				{
					//加载数据
					this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("%s"), str_Mbn_Temp.cs_Name);
					this->m_str_Mbn_Partition_Table.cs_Path.Format(_T("%s"), str_Mbn_Temp.cs_Path);
					this->m_str_Mbn_Partition_Table.b_Enable_DL = true;
				}
				else if(wcsstr(csFW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), str_Mbn_Temp.cs_Name);
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s"), str_Mbn_Temp.cs_Path);
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}
				else
				{
					if((iMdnIndex<MAX_MBN_FILE)
						&&((m_eu_BB_Chip == MDM9X07)||(m_eu_BB_Chip == MDM9X55)
						||(m_eu_BB_Chip == SDX20)||(m_eu_BB_Chip == SDX55)
						|| (m_eu_BB_Chip == MDM9X40) || (m_eu_BB_Chip == MSM8909)))
					{
						//加载数据
                     //将SBL1.MBN文件放到最后进行下载
						if(wcscmp(csFW_Image, _T("0:SBL")) == 0)
						{
							cs_sbl_Name = str_Mbn_Temp.cs_Name;
							cs_sbl_path = str_Mbn_Temp.cs_Path;
							bHasSbl = TRUE;
						}
						else
						{
							this->m_strr_Mbn_File_List[iMdnIndex].cs_Name.Format(_T("%s"), str_Mbn_Temp.cs_Name);
							this->m_strr_Mbn_File_List[iMdnIndex].cs_Path.Format(_T("%s"), str_Mbn_Temp.cs_Path);
							this->m_strr_Mbn_File_List[iMdnIndex].b_Enable_DL = true;
							iMdnIndex++;
						}

					}
					else
					{
						//用image名确定文件的index
						if(this->Get_Mbn_File_Index(csFW_Image, &iIndex) == false)
						{
							::AfxMessageBox(this->m_csError_Code);
							throw(0);
						}

						//加载数据
						this->m_strr_Mbn_File_List[iIndex].cs_Name.Format(_T("%s"), str_Mbn_Temp.cs_Name);
						this->m_strr_Mbn_File_List[iIndex].cs_Path.Format(_T("%s"), str_Mbn_Temp.cs_Path);
						this->m_strr_Mbn_File_List[iIndex].b_Enable_DL = true;
					}

				}

				//清空
				csFW_Image.Format(_T(""));
				csFW_Name.Format(_T(""));
			}
		}//while(cla_XML_File.ReadString(csData) != NULL

		// 9X07的将SBL1.MBN文件放到最后进行下载
		if(((m_eu_BB_Chip == MDM9X07)
			||(m_eu_BB_Chip == SDX20)
			||(m_eu_BB_Chip == SDX55)
			||(m_eu_BB_Chip == MDM9X55)//后加 20190831
			|| (m_eu_BB_Chip == MSM8909)
			||(m_eu_BB_Chip == MDM9X40))
			&& (bHasSbl == TRUE))
		{
			this->m_strr_Mbn_File_List[iMdnIndex].cs_Name.Format(_T("%s"), cs_sbl_Name);
			this->m_strr_Mbn_File_List[iMdnIndex].cs_Path.Format(_T("%s"), cs_sbl_path);
			this->m_strr_Mbn_File_List[iMdnIndex].b_Enable_DL = true;
			iMdnIndex++;
		}
		


		//关闭 xml 文件
		cla_XML_File.Close();
	}
	catch(...)
	{
		//关闭 xml 文件
		cla_XML_File.Close();

		//
		return false;
	}

	return true;
}
int CARM_OP_QCM::Execute_MDM9X05(void)
{
	//------------------------------
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		int iDL_Flag = RTN_FAIL;

		if (NULL != wcsstr(m_csOC, _T("QDM041"))) //20221114 Daniel
		{
			if (this->Execute_DL_Jlink(_T("QDM041")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM041_Jlink Fail"));
				this->Show_Out(_T("QDM041_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM041_Jlink Pass"));
				this->Show_Out(_T("QDM041_Jlink Pass"));
			}
		} 
		else if (NULL != wcsstr(m_csOC, _T("QDC002")) 
			|| (_T("QDC004EAXC-I01-AAAAA") == m_csOC)  
			|| (_T("QDC004EAXD-TI-AAAAA") == m_csOC)  
			) //20221210 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink_Newest")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jlink Fail"));
				this->Show_Out(_T("Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jlink Pass"));
				this->Show_Out(_T("Flash_Jlink Pass"));
			}
		}
		else if (_T("QDM062EABL-D08-AAAAA") == m_csOC
			) //20230419 Daniel
		{
			if (this->Execute_DL_Jlink(_T("QDM538")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jlink Fail"));
				this->Show_Out(_T("Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jlink Pass"));
				this->Show_Out(_T("Flash_Jlink Pass"));
			}
		}
		else if (_T("QDM042AUBL-D01-AAAAA") == m_csOC
			) //20230504 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM042 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM042 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM042 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM042 Flash_Jlink Pass"));
			}
		}
		else if (NULL != wcsstr(m_csOC, _T("QDM027"))
			) //20221226 Daniel
		{
			if (this->Execute_DL_Jflash(_T("QDM027"), _T("Jflashfile.jflash")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jflash Fail"));
				this->Show_Out(_T("Flash_Jflash Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jflash Pass"));
				this->Show_Out(_T("Flash_Jflash Pass"));
				Sleep(6000);
			}
		}
		else if (_T("QDC519SASE-E53-A2SUB") == m_csOC) //20230312 Daniel 税控板烧录
		{
			CString str_JTAGConfigFile_Orig = _T("");
			CString str_JTAGConfigFile = _T("");
			str_JTAGConfigFile_Orig.Format(_T("%s\\QDC519\\%d\\Orig\\config.ini"), this->m_csCurr_Exe_Path, m_iClass_Idx);
			str_JTAGConfigFile.Format(_T("%s\\QDC519\\%d\\config.ini"), this->m_csCurr_Exe_Path, m_iClass_Idx);
			CopyFile(str_JTAGConfigFile_Orig, str_JTAGConfigFile, FALSE);

			CString str_MCU_FullPathName = m_csScat_Cfg_File_Path;
			str_MCU_FullPathName.Replace(_T(".hex.txt"), _T(".txt"));
			if (this->Modify_FileContent(str_JTAGConfigFile, _T("CodeFileName		"), str_MCU_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Config Write Fail"));
				this->Show_Out(_T("Flash_Config Write Fail"));
			} 
			else
			{
				if (this->Execute_DL_JTAG(_T("QDC519")) != RTN_SUCCESS)
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("Flash_JTAG Fail"));
					this->Show_Out(_T("Flash_JTAG Fail"));
				}
				else
				{
					iDL_Flag = RTN_SUCCESS;
					Save_Trace_Log(_T("Flash_JTAG Pass"));
					this->Show_Out(_T("Flash_JTAG Pass"));
				}
			}			
		}
		else if (_T("QDC518GLSD-U60-AABAS") == m_csOC 
			|| _T("QDC518GLSD-U60-BABAS") == m_csOC 
			|| _T("QDC523SPSW-U67-AAAAA") == m_csOC  
			) //20230314 Daniel
		{
			if (this->Execute_DL_FLHubTool(_T("QDC518")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("FLHubTool Flash_FW Fail"));
				this->Show_Out(_T("FLHubTool Flash_FW Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("FLHubTool Flash_FW Pass"));
				this->Show_Out(_T("FLHubTool Flash_FW Pass"));
			}
		}
		else
		{
			iDL_Flag = DL_FW_V4_MDM9x05_Firehose();
		}
		

		return iDL_Flag;

	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

int CARM_OP_QCM::Execute_MDM9X06(void)
{
	//------------------------------
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------
		//------------------------------ 下载FW操作 ------------------------------ 
		if (1 == m_iMDM9X07_NEW_FLAG)//Firehose
		{
			int iDL_Flag = RTN_FAIL;
			iDL_Flag = DL_FW_V4_MDM9x06_Firehose();

			return iDL_Flag;
		}
		else//Sahara
		{
			//------------------------------ 检查串口是否存在 ------------------------------ 
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port) == true)
			{
				//DM口已经存在，则说明模块已预先开机，无需特别延迟
			}
			else
			{
				bool  bDL_Flag =false;
				// check port 是否存在
				//---------------------------------------------------------------------------------
				if (this->m_iCom_Port_Auto_Sec>0)//
				{
					//成功找到端口1
					int iFlag = 0;
					iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
					//成功找到端口1
					if(1 == iFlag)
					{
						bDL_Flag = true;
					}
					//成功找到端口2
					else if(2 == iFlag)
					{
						this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
						this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
						bDL_Flag = true;
					}
					else //两个端口都没找到
					{
						bDL_Flag = false;
					}
				}
				else
				{
					if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
					{
						bDL_Flag = false;
					}
					else
					{
						bDL_Flag = true;
					}
				}
				//---------------------------------------------------------------------------------
				if( false ==  bDL_Flag)
				{		
					this->m_iError_Code =  QCM_ERR_COM_PORT_RE_DETECT_FAIL;
					this->Show_Status(this->m_csError_Code);
					throw(1);			
				}
				//刷新COM参数
				this->Load_Com_Port_Params();

			}

			if(this->DL_FW_V4_MDM9x06() == false)
			{
				throw(2);
			}
		}
		//------------------------------

	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V4_MDM9x06(void)
{
	int iM9x06_Cur_Status;
	CString csData;
	unsigned long ulMax_Block_Size = 0;
	//下载步骤控制变量
	bool bSwitch_Sahara = false;
	bool bDL_Sahara = false;


	try
	{
		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//DM口下载
		this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;



		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		//加上mbn文件大小
		for(int i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}
		//加上Partition文件大小
		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;
		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}
		//-----------------------



		//初始化PKT_BUFF内存
		//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
		//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);



		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			m_csError_Code = csData;
			throw(0);
		}
		//-----------------------




		//----------------------- 最先检查“开机是否是sahara模式” -----------------------
		if(this->DL_FW_SAHARA_EMERG() == true)//“紧急下载模式”时的模块一开始就是sahara模式
		{
			//开机就是sahara模式，紧急下载

			this->Show_Status(_T("DL Emerg Switching ......"));
			//关闭COM口前的延时
			Sleep(4000);
			//重启串口
			if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
			{
				this->m_csError_Code += _T(" [DL Re-Start]");
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
		else
		{
			//开机不是sahara模式，正常模块，正常下载

			//----------------------- 探测确定“模块初始化状态（模式）”----------------------- 
			//探测模块状态模式
			if(this->Ping_DLoad_Port_MDM9x06(&iM9x06_Cur_Status, 20) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
			//-----------------------



			//----------------------- 检查状态是否异常, 确定接下来的流程 -----------------------
			switch(iM9x06_Cur_Status)
			{
			case 1://当前“正常状态”
				bSwitch_Sahara = true;
				bDL_Sahara = true;
				break;
			case 3://当前“SAHARA状态”，状态正常
				bSwitch_Sahara = false;
				bDL_Sahara = true;
				break;
			//20170926
				case 4://当前“SAHARA状态”，状态emerg
				bSwitch_Sahara = false;
				bDL_Sahara = true;
				break;
			
			default:
				{
					this->m_csError_Code.Format(_T("ERROR, Status(%d) no defined!"), iM9x06_Cur_Status);
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------



			//----------------------- 切换到SAHARA下载模式，完成重启 -----------------------
			if(bSwitch_Sahara == true)
			{
				//发3A A1 6E 7E
				if(this->Switch_To_DL_Mode(2) == true)
				{
					//重启串口
					if(this->COM_PORT_RE_DETECT(_T("DM Switching"), 10000, true) == false)
					{
						this->m_csError_Code += _T(" [Diag Open]");
						this->Show_Status(this->m_csError_Code);
						throw(0);
					}
				}
				else
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------


			//----------------------- SAHARA下载 -----------------------
			if(bDL_Sahara == true)
			{
				if(this->DL_FW_SAHARA_ALL() == false)
				{
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}


				this->Show_Status(_T("DL Norm Switching ......"));
				//关闭COM口前的延时
				Sleep(4000);
				//重启串口
				if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
				{
					this->m_csError_Code += _T(" [DL Re-Start]");
					this->Show_Status(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------
		}//最先检查“开机是否是sahara模式”
		//-----------------------




		//----------------------- Stream下载 -----------------------

		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}
		//-----------------------



		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));
		//-----------------------



		//----------------------- 设置Security_Mode，我们用“0x01”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 下载其他mbn文件 ----------------------- 
		if(this->DL_Mbn_All_File(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 下载cefs文件 ----------------------- 
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			if(this->DL_Cefs_File(ulMax_Block_Size) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
		//-----------------------

		//----------------------- 重启模块 ----------------------- 
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}
		//-----------------------
		//重启成功后再向后延迟10秒
		Sleep(15000);




		//关闭串口
		this->COM_PORT_CLOSE();


		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);




		/*
		//----------------------- 导入xqcn -----------------------
		if((this->m_bQCN_DL == true) && (this->m_str_Mbn_QCN_DL.b_Enable_DL == true))
		{
		this->Show_Status(_T("Restart ......"));
		//关闭COM口前的延时
		Sleep(2000);
		//重启串口
		if(this->COM_PORT_RE_DETECT(_T("Re-Start"), 4000, false) == false)
		{
		this->m_csError_Code += _T(" [Re-Start]");
		this->Show_Status(this->m_csError_Code);
		throw(0);
		}


		//
		this->Show_Status(_T("Restore xqcn ......"));
		//
		if(::QLIB_QCN_Restore_XQCN(this->m_cla_Com_Port.m_iPort, this->m_str_Mbn_QCN_DL.cs_Path) == false)
		{
		this->Show_Status(_T("FAIL, Restore xqcn fail!"));
		throw(0);
		}
		}
		//-----------------------
		*/




		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Ping_DLoad_Port_MDM9x06(int * ip_Cur_Status, int i_TimeOut)
{
	time_t t_Start, t_End;
	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulTgt_Key_Quan, ulIndex;
	unsigned char ucrTgt_Key_Normal_1[] = {0x13, 0x02, 0x00, 0x00};//（发送过sahara指令后的normal状态的返回）13 02 00 00  00 30 00 00 ...... 00 06 4e 95  7d 5e e7 45  7e
	unsigned char ucrTgt_Key_Normal_2[] = {0x13, 0x06, 0x88, 0xd5, 0x7e};//（没发送过sahara指令后的normal状态的返回）
	unsigned char ucrTgt_Key_2_Streaming[] = {0x7e, 0x02, 0x6a, 0xd3, 0x7e};//Streaming_DLoad
	unsigned char ucrTgt_Key_3_SAHARA[] = {0x01, 0x00, 0x00, 0x00, 0x30};
	unsigned char ucrTgt_Key_4_ERROR[] = {0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};//04 00 00 00 10 00 00 00 0D 00 00 00 01 00 00 00


	try
	{
		this->Show_Status(_T("Ping dload port......"));

		//打包命令，7e 06 4e 95 7e
		this->PKT_DMSS_CMD_NO_OP(&this->m_str_Pkt_Send);


		//计时开始
		time(&t_Start);

		//循环发送指令，并读取响应
		do
		{
			//发送并读取响应
			this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, 2);

			//
			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				break;
			}


			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Ping_DLoad_Port timeout"));
				throw(0);
			}
		}
		while(true);



		//读到响应数据，判定数据，判定状态

		//normal 1
		ulTgt_Key_Quan = 4;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Normal_1, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Normal 1"));
			*ip_Cur_Status = 1;//正常开机

			//			::AfxMessageBox(_T("Ping dload port Normal 1"));

			return true;
		}


		//normal 2
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Normal_2, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Normal 2"));
			*ip_Cur_Status = 1;//正常开机

			//			::AfxMessageBox(_T("Ping dload port Normal 2"));

			return true;
		}


		//2
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_2_Streaming, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Streaming"));
			*ip_Cur_Status = 2;//下载中
			return true;
		}

		//3
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_3_SAHARA, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port SA"));
			*ip_Cur_Status = 3;//SAHARA模式
			return true;
		}

		//4
		ulTgt_Key_Quan = 8;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_4_ERROR, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port error"));
			*ip_Cur_Status = 4;//错误模式
			return true;
		}



		//无法识别的状态
		this->Show_Status(_T("Ping dload port ND"));
		*ip_Cur_Status = 0;
	}
	catch(...)
	{
		return false;
	}

	return true;
}

//检测是否存在UDE DM口
bool CARM_OP_QCM::Detect_UDE_DM_Port_Ext()
{
	CString csData;
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int  i, j;
	bool bAT_Get_Success = false;
	bool bDM_Get_Success = false;
	bool bDetectPortFlag = false;

	bool bQDloader_Get_Success = false;
	int iTimeOut = 40;



	m_bQDloader_Get_Success = false;
	this->m_iDM_Port = 0;
	//
	i = 0;
	//
	try
	{
		do
		{
			//
			i++;
			//
			Sleep(1100);

			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);

			//
			for (j = 0; j < asi.GetSize(); j++)
			{
				if (wcsstr(asi[j].strPortDesc, _T("UDE DM")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iDM_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect DM Port%d"), this->m_iDM_Port);
					this->Show_Out(csData);

					//
					bDM_Get_Success = true;
				}
				//增加Quectel；UDE EDL
				if (wcsstr(asi[j].strPortDesc, _T("UDE EDL")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iDM_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect EDL Port%d"), this->m_iDM_Port);
					this->Show_Out(csData);

					//
					bQDloader_Get_Success = true;

					m_bQDloader_Get_Success = true;
				}
				//
				if ((/*(true == bAT_Get_Success)&&*/ (true == bDM_Get_Success))
					|| (true == bQDloader_Get_Success))
				{
					bDetectPortFlag = true;

					break;
				}
			}
			//显示
			csData.Format(_T("[INFO] Detect Port......%d"), (iTimeOut - i));
			this->Show_Status(csData);
			//
			if ((/*(true == bAT_Get_Success)&&*/ (true == bDM_Get_Success))
				|| (true == bQDloader_Get_Success))
			{
				break;
			}
			else
			{
				//
				if (i >= iTimeOut)
				{
					bDetectPortFlag = false;
					throw(0);
				}
			}
		} while (true);
	}
	catch (...)
	{
		return bDetectPortFlag;
	}

	return bDetectPortFlag;
}


int CARM_OP_QCM::Execute_MDM9X07_EXT(void)
{
	CString csData;
	int i, iQDLoader_Port(0);
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”
	CString csCOM;

	int iQDloadPort=0;

	bool bDL_Flag = true;

	bool bDetectPortFlag = false;

	int iOldCom_Port = this->m_iCom_Port;
	int iOldDmCom_Port = this->m_DM_Port;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		iQDloadPort = this->m_iCom_Port;
#if 1

		if (true == m_bPCIE_DL)//PCIE场景下
		{
			if (SDX55 == m_eu_BB_Chip)
			{
				//---------------------------------------- 探测端口 1----------------------------------------
				this->Show_Status(_T("[INFO] Detect Port......(1)"));
				if (TRUE == this->EnumAllDevice())
				{
					this->Save_Trace_Log(_T("[INFO] EnumAllDevice Pass"));

					// 启动Q_DL_QBhiServer
					if (Q_DL_QBhiServer() == false)
					{
						this->Show_Out(_T("[FAIL] QBhiServer Fail"));

						this->Save_Trace_Log(_T("[INFO] Q_DL_QBhiServer Fail"));
					}
				}
			}
		}

		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;		
			}
			else
			{
				bDL_Flag = true;
			}
		}
		//---------------------------------------------------------------------------------
		//---------------------------------------------------------------------------------

		if (false == bDL_Flag)
		{
			//找不到端口的场景下做下QBhiServer尝试 20201028
			if (true == m_bPCIE_DL)//PCIE场景下
			{
				if (SDX55 == m_eu_BB_Chip)
				{		
					bDetectPortFlag = this->Detect_UDE_DM_Port_Ext();

					if (false == bDetectPortFlag)
					{
						this->Show_Status(_T("[FAIL] Detect UDE Port Fail"));
						this->Show_Out(_T("[FAIL] Detect UDE Port Fail"));

						this->Save_Trace_Log(_T("[FAIL] UDE Detect Port Fail"));
						throw(0);
					}

					this->Save_Trace_Log(_T("[INFO] UDE Detect_DM_Port Pass"));

				}
				else
				{
					// 启动Q_DL_QBhiServer
					if (Q_DL_QBhiServer() == false)
					{
						//throw(4);
					}
					//刷口操作
					if (false == this->Confirm_PCIE_UDE_EDL_Port(30))
					{
						//
						this->Show_Out(_T("Confirm_PCIE_Port FAIL"));
						this->Show_Status(_T("[FAIL] Detect UDE EDL Port Fail"));
						this->Show_Out(_T("[FAIL] Detect UDE EDL Port Fail"));
						throw(0);
					}
					else
					{
						//
						this->m_csError_Code = _T("");
						this->m_iError_Code = 0;
						bDL_Flag = true;
						this->Show_Out(_T("Confirm_PCIE_Port PASS"));
					}
				}
				

			}
		}
//#if 1
		if (false == bDL_Flag)
		{
			if(this->m_iOP_Robot == LOAD_AUTO_ROBOT)//全自动机器人
			{
				this->Show_Status(_T("Reload Fixture......"));
				Save_Trace_Log(_T("Reload Fixture......"));
				bool bReload = false;
				bReload = ::TS_LAN_SEND_RELOAD_FIXTURE_LAN_CMD_TO_MC_PC(m_Ts_Num);
				Sleep(2000);
				if (bReload == true)
				{
					//重新搞一遍				
					this->m_iCom_Port = iQDloadPort;

					// check port 是否存在
					//---------------------------------------------------------------------------------
					if (this->m_iCom_Port_Auto_Sec>0)//
					{
						//成功找到端口1
						int iFlag = 0;
						iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
						//成功找到端口1
						if(1 == iFlag)
						{
							bDL_Flag = true;
						}
						//成功找到端口2
						else if(2 == iFlag)
						{
							this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
							this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
							bDL_Flag = true;
						}
						else //两个端口都没找到
						{
							bDL_Flag = false;
						}
					}
					else
					{
						if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
						{
							bDL_Flag = false;
						}
						else
						{
							bDL_Flag = true;
						}
					}
					//---------------------------------------------------------------------------------

				}
				else
				{
					this->m_iError_Code=0x00000071;
					this->m_csError_Code.Format(_T("Reload Fixture Fail"));
					this->Show_Status(this->m_csError_Code);
//					g_cla_Lock_Port.Lock();
					throw(1);
				}
			}
			else
//#endif
			{
				this->Show_Status(this->m_csError_Code);
				this->Show_Out(this->m_csError_Code);
//				g_cla_Lock_Port.Lock();
				throw(1);
			}
		}	

		//COM口刚生成后，模块初始化未完成，模块无法下载
		//代码锁定
		Sleep(3000);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------

		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“9x07的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“9x07的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++
		//g_cla_Lock_Port.Unlock();
		m_iCom_Old_Port =0;

		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			csCOM.Format(_T("QDLoader %d"), this->m_iCom_Port);
			Save_Trace_Log(csCOM);
			this->Show_Out(csCOM);

			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
			
		}
		else
		{
			csCOM.Format(_T("DM %d"), this->m_iCom_Port);
			Show_COMPORT(csCOM);
			Save_Trace_Log(csCOM);
			this->Show_Out(csCOM);

			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				//此时工具查找9008端口失败情况下，如果设置界面中设置9008端口，就以9008端口为准
				if (this->m_iQDPort >0)
				{
					iQDLoader_Port = this->m_iQDPort;
				}
				else
				{
					this->Show_Status(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					this->m_iError_Code=0x00000072;
					throw(2);

				}				
			}
			else
			{
				//虽找到后Qloader口可能还没准备好 20180508
				Sleep(3000);
			}
			//如果设置界面设置9008端口，如果设置，则已界面设置设置为准 20200212
			if (this->m_iQDPort >0)
			{
				iQDLoader_Port = this->m_iQDPort;
			}

			//刷新端口的显示
			csCOM.Format(_T("QDLoader %d"), iQDLoader_Port);
			Show_COMPORT(csCOM);
			m_iCom_Old_Port=m_iCom_Port;
			Save_Trace_Log(csCOM);
			this->Show_Out(csCOM);
		}

		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);
		Save_Trace_Log(csData);
		this->Show_Out(csData);
//		g_cla_Lock_Port.Unlock();

		//------------------------------

		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V2_MSM9X07( iQDLoader_Port ) == false)
		{
			throw(3);
			//如果失败了，再尝试下载一遍
// 			Sleep(2000);
// 			if(this->DL_FW_V2_MSM9X07( iQDLoader_Port ) == false)
// 			{
// 				throw(3);
// 			}
		}
		else
		{
			//...
		}
		
#endif

		//20200904  EM120/EM160 7个OC需要软重启后读EID 和ESIM
		if(true  ==  this->m_bAT_UseFlag)
		{
			if (true == m_bPCIE_DL)//PCIE场景下
			{
				//存在变口场景，需重新找口--20201029			
				if (false == this->Confirm_PCIE_UDE_AT_Port(30))
				{
					//
					this->Show_Out(_T("Confirm_PCIE_UDE_AT_Port FAIL"));
					//需要做一次程控电源上下电的操作-发送消息
					::SendMessage(this->m_hWnd_View, WM_PowerOn_SPC_Only, (WPARAM)this->m_iClass_Idx, (LPARAM)this->m_iClass_Idx);

					if (false == this->Confirm_PCIE_UDE_AT_Port(60))
					{
						//
						this->Show_Out(_T("Confirm_PCIE_UDE_AT_Port FAIL-1"));
					}
					else
					{
						//
						this->Show_Out(_T("Confirm_PCIE_UDE_AT_Port PASS-1"));
					}
				}
				else
				{
					//
					this->Show_Out(_T("Confirm_PCIE_UDE_AT_Port PASS"));
				}
			}

			//不断检测是否有AT口出现
			if(false == this->Confirm_Dynamic_Com_Port(this->m_iAT_Port,60) )
			{
				csData.Format(_T("AT Port %d Find Fail"), this->m_iAT_Port);
				this->Show_Status(csData);
				this->Show_Out(csData);
				this->Save_Trace_Log(csData);
				throw(4);
			}
			else
			{
				Sleep(5000);

				csData.Format(_T("AT Port %d Find Pass"), this->m_iAT_Port);
				this->Save_Trace_Log(csData);
				this->Show_Out(csData);
			}

			this->m_cla_AT_Com_Port.m_iBaudRate = 115200;
			this->m_cla_AT_Com_Port.m_iPort = m_iAT_Port;
			this->m_cla_AT_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
			this->m_cla_AT_Com_Port.m_dwRTS_CTRL = DTR_CONTROL_ENABLE;

			if(!this->m_cla_AT_Com_Port.Port_Open(500))
			{
				csData.Format(_T("AT Port %d Open Fail"), this->m_iAT_Port);
				this->Show_Status(csData);
				this->Save_Trace_Log(csData);
				this->Show_Out(csData);
				throw(10);
			}
			else
			{
				//...
			}

			//查询指令：AT+QCFG="usbnet"  返回值为0 : RMNET，2: MBIM，EM160版本DL后默认为MBIM
			//设置命令：AT + QCFG = "usbnet", 0设置为RMNET

			if (_T("EM120RGLAU-M21-RMNET") == this->m_csOC)
			{
				//------------------------------------------------------------------
				//AT+QCFG="usbnet",0  返回的是：OK
				if (false == this->Set_RMNET())
				{
					csData.Format(_T("Set_RMNET Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(5);
				}
				else
				{
					csData.Format(_T("Set_RMNET Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}
				//AT+QCFG="usbnet"   返回的是：+QCFG:"usbnet",0 OK
				if (false == this->Get_RMNET())
				{
					csData.Format(_T("Get_RMNET Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(6);
				}
				else
				{
					csData.Format(_T("Get_Quimslo 2 Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}
			}
			else
			{
				//------------------------------------------------------------------
				//at+quimslot=2 OK
				if (false == this->Set_Quimslot(2))
				{
					csData.Format(_T("Set_Quimslot 2 Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(5);
				}
				else
				{
					csData.Format(_T("Set_Quimslot 2 Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}
				//AT+QUIMSLOT? QUIMSLOT: 2
				if (false == this->Get_Quimslot(2))
				{
					csData.Format(_T("Get_Quimslot 2 Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(6);
				}
				else
				{
					csData.Format(_T("Get_Quimslo 2 Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}
				// AT+QSIMCFG="eid" OK,返回的EID截取下来保存到数据库中DB_IMEI_STD_2017_RESERVED_15
				this->m_strEID.Format(_T(""));

				this->Show_Status(_T("Wait EID..."));

				//Sleep(40000);
				Sleep(5000);//20201025

				if (false == this->Get_EID())
				{
					int iTime = 20;
					while (iTime>0)
					{
						Sleep(500);
						if (true == this->Get_EID())
						{
							csData.Format(_T("Get_EID:%s Pass"), this->m_strEID);
							this->Save_Trace_Log(csData);
							this->Show_Out(csData);
							break;
						}
						iTime--;

					}
					if (iTime <= 0)
					{
						csData.Format(_T("Get_EID Fail"));
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						this->Show_Out(csData);
						this->m_cla_AT_Com_Port.Port_Close();
						throw(7);
					}
					else
					{
						//...
					}

				}
				else
				{
					csData.Format(_T("Get_EID:%s Pass"), this->m_strEID);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}

				if (true == this->m_bOldFlag)
				{
					//----------------------------------------------------------
					// 		AT+CSIM=26,"00A4040008A000000151000000"
					// 		+CSIM: 4,"6184"
					if (false == this->Check_ESIM_1())
					{
						csData.Format(_T("Check_ESIM_1 Fail"));
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						this->m_cla_AT_Com_Port.Port_Close();
						this->Show_Out(csData);
						throw(9);
					}
					else
					{
						csData.Format(_T("Check_ESIM_1 Pass"));
						this->Save_Trace_Log(csData);
						this->Show_Out(csData);
					}
					// 		AT+CSIM=10,"80CA004200"
					// 		+CSIM: 48,"4214574C43535036382D65554943432D4D464FFFFFFF9000"
					if (false == this->Check_ESIM_2())
					{
						csData.Format(_T("Check_ESIM_2 Fail"));
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						this->m_cla_AT_Com_Port.Port_Close();
						this->Show_Out(csData);
						throw(9);
					}
					else
					{
						csData.Format(_T("Check_ESIM_2 Pass"));
						this->Save_Trace_Log(csData);
						this->Show_Out(csData);
					}
					//----------------------------------------------------------
				}
				else //新的检测ESIM的方式
				{
					//AT + QSIMCFG = "pn"    //查询PN号，即软件版本号
					//+ QSIMCFG: "pn", WLCSP68-eUICC-MFO
					//OK
					if (false == this->Check_PN())
					{
						csData.Format(_T("Check_PN Fail"));
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						this->m_cla_AT_Com_Port.Port_Close();
						this->Show_Out(csData);
						throw(9);
					}
					else
					{
						csData.Format(_T("Check_PN Pass"));
						this->Save_Trace_Log(csData);
						this->Show_Out(csData);
					}
					//----------------------------------------------------------

					//AT + QSIMCFG = "os"    //查询OS版本
					//+ QSIMCFG : "os", D1497223-B
					//OK
					if (false == this->Check_OS())
					{
						csData.Format(_T("Check_OS Fail"));
						this->Show_Status(csData);
						this->Save_Trace_Log(csData);
						this->m_cla_AT_Com_Port.Port_Close();
						this->Show_Out(csData);
						throw(9);
					}
					else
					{
						csData.Format(_T("Check_OS Pass"));
						this->Save_Trace_Log(csData);
						this->Show_Out(csData);
					}
					//----------------------------------------------------------
				}
				// at+quimslot=1 OK
				if (false == this->Set_Quimslot(1))
				{
					csData.Format(_T("Set_Quimslot 1 Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(8);
				}
				else
				{
					csData.Format(_T("Set_Quimslot 1 Pass"));
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}
				// AT+QUIMSLOT? QUIMSLOT: 1
				if (false == this->Get_Quimslot(1))
				{
					csData.Format(_T("Get_Quimslot 1 Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(9);
				}

				csData.Format(_T("Get_Quimslot 1 Pass"));
				this->Save_Trace_Log(csData);
				this->Show_Out(csData);

			}
	
			//
			this->m_cla_AT_Com_Port.Port_Close();
		}
		else
		{
			if (TRUE == m_bFirehose_Reset_after_DL)
			{
				//重启成功后再向后延迟30秒
				this->Show_Status(_T("Reset..."));
				Sleep(30000);
			}
		}
		//-------------
		
		
		//-----------------
#if 0
		if(this->m_iOP_Robot == LOAD_AUTO_ROBOT)//全自动机器人
		{
			//下载完重启
			//向总控PC发送DC重启指令
			bool bDC_Reset =false;
			csData.Format(_T("Reset......%d OFF"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);


			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("OFF") );
			Sleep(5000);
			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("ON") );

			csData.Format(_T("Reset......%d ON"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);
			Sleep(8000);

// 			if (this->m_DM_Port >0)
// 			{
// 				if(this->Confirm_Dynamic_Com_Port(this->m_DM_Port, 30) == false)
// 				{
// 					this->m_csError_Code.Format(_T("Reset Fail(DM(%d) Find Fail)"),this->m_DM_Port);
// 					this->Show_Status(this->m_csError_Code);
// 					throw(1);
// 				}
// 			}
			this->Show_Status(_T("Reset Suecess"));
			Save_Trace_Log(_T("Reset Suecess"));
			
		}
#endif

		//显示进度条 100%
		this->Show_Progress(1.0);

		//保存当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
		}
		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
			this->Show_Out(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
		}

		//刷新端口的显示
		if (m_iCom_Old_Port != 0)
		{
			csCOM.Format(_T("%d"), m_iCom_Old_Port);
			Show_COMPORT(csCOM);
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
// 		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
// 		{
// 			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
// 		}

		//对应的置零
		switch(m_iClass_Idx)
		{
		case 1:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
			break;
		case 2:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
			break;
		case 3:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
			break;
		case 4:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
			break;
		}
		return RTN_FAIL;
	}

	//对应的置零
	//下载完成后去除当前使用QDLoader的COM口
// 	if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
// 	{
// 		g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
// 	}
	switch(m_iClass_Idx)
	{
	case 1:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
		break;
	case 2:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
		break;
	case 3:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
		break;
	case 4:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
		break;
	}
	return RTN_SUCCESS;
}

int CARM_OP_QCM::Execute_MDM9X07(void)
{
	//------------------------------
	CString strData = _T("");
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//QDE007 继续Jlink下载HEX文件
		//20210226 QDE007

		Sleep(5000);
		if (this->Execute_QDE007_Danlow_Jlink() != RTN_SUCCESS)
		{
			Save_Trace_Log(_T("QDE007_Danlow_Jlink Fail"));
			this->Show_Out(_T("QDE007_Danlow_Jlink Fail"));
			throw(2);
		}

		Sleep(5000);
		//第二次Jlink下载
		if (this->Execute_QDE007_Danlow_Jlink() != RTN_SUCCESS)
		{
			Save_Trace_Log(_T("QDE007_Danlow_Jlink Fail"));
			this->Show_Out(_T("QDE007_Danlow_Jlink Fail"));
			this->m_csError_Code = _T("QDE007_Danlow_Jlink Fail");
			this->Show_Status(this->m_csError_Code);

			throw(2);
		}

		//模块重启的延时，否则关闭端口会有问题
		CString csA, csB;
		int s = 4000 / 10;
		//模块重启时间，进度简易显示
		csA.Format(_T("%s"), _T("Jlink Reset Waiting"));
		csB.Format(_T(" ."));
		//循环进度条
		for (int j = 0; j<10; j++)
		{
			csA += csB;
			this->Show_Status(csA);
			Sleep(s);
		}


		Save_Trace_Log(_T("QDE007_Danlow_Jlink Pass"));
		this->Show_Out(_T("QDE007_Danlow_Jlink Pass"));
		this->Show_Status(_T("QDE007_Danlow_Jlink Pass"));

		return RTN_SUCCESS;
		//增加端口的检测
		//检查端口是否存在
		//bool bPortOk = false;
		//bPortOk = this->Check_Port();

		//if (false == bPortOk)
		//{
		//	this->Show_Out(_T("QCM Port not find"));
		//	this->m_csError_Code = _T("QCM Port not find");
		//	this->Show_Status(this->m_csError_Code);
		//	throw(2);
		//}
		//else
		//{
		//	this->Show_Out(_T("QCM Port not find"));
		//}
	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V4_MDM9x07(void)
{
	int iM9x07_Cur_Status;
	CString csData;
	unsigned long ulMax_Block_Size = 0;
	//下载步骤控制变量
	bool bSwitch_Sahara = false;
	bool bDL_Sahara = false;


	try
	{
		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//DM口下载
		this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;



		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		//加上mbn文件大小
		for(int i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}
		//加上Partition文件大小
		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;
		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}
		//-----------------------



		//初始化PKT_BUFF内存
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);



		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));
		
		CString strPortInfo;
		strPortInfo.Format(_T("Open com port %d......"),m_iCom_Port);
		Save_Trace_Log(strPortInfo);
		this->Show_Out(strPortInfo);

		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			Save_Trace_Log(csData);
			m_csError_Code = csData;
			this->Show_Out(csData);
			throw(0);
		}
		//-----------------------




		//----------------------- 最先检查“开机是否是sahara模式” -----------------------
		if(this->DL_FW_SAHARA_EMERG() == true)//“紧急下载模式”时的模块一开始就是sahara模式
		{
			//开机就是sahara模式，紧急下载

			this->Show_Status(_T("DL Emerg Switching ......"));
			Save_Trace_Log(_T("DL Emerg Switching ......"));
			this->Show_Out(_T("DL Emerg Switching ......"));
			//关闭COM口前的延时
			Sleep(4000);
			//重启串口
			if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
			{
				this->m_csError_Code += _T(" [DL Re-Start]");
				this->Show_Status(this->m_csError_Code);
				Save_Trace_Log(this->m_csError_Code);
				this->Show_Out(this->m_csError_Code);
				throw(0);
			}
		}
		else
		{
			//开机不是sahara模式，正常模块，正常下载

			//----------------------- 探测确定“模块初始化状态（模式）”----------------------- 
			//探测模块状态模式
			this->Show_Out(_T("Ping_DLoad_Port..."));
			if(this->Ping_DLoad_Port_MDM9x07(&iM9x07_Cur_Status, 20) == false)
			{
				this->Show_Status(this->m_csError_Code);
				Save_Trace_Log(this->m_csError_Code);
				this->Show_Out(this->m_csError_Code);
				throw(0);
			}
			this->Show_Out(_T("Ping_DLoad_Port Pass"));
			//-----------------------



			//----------------------- 检查状态是否异常, 确定接下来的流程 -----------------------
			switch(iM9x07_Cur_Status)
			{
			case 1://当前“正常状态”
				bSwitch_Sahara = true;
				bDL_Sahara = true;
				break;
			case 3://当前“SAHARA状态”，状态正常
				bSwitch_Sahara = false;
				bDL_Sahara = true;
				break;
			//0926
			case 4://当前“SAHARA状态”，状态emerg
			bSwitch_Sahara = false;
			bDL_Sahara = true;
			break;

			default:
				{
					this->m_csError_Code.Format(_T("ERROR, Status(%d) no defined!"), iM9x07_Cur_Status);
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------



			//----------------------- 切换到SAHARA下载模式，完成重启 -----------------------
			if(bSwitch_Sahara == true)
			{
				//发3A A1 6E 7E
				this->Show_Out(_T("Switch_To_DL_Mode..."));
				if(this->Switch_To_DL_Mode(2) == true)
				{
					//重启串口
					if(this->COM_PORT_RE_DETECT(_T("DM Switching"), 10000, true) == false)
					{
						this->m_csError_Code += _T(" [Diag Open]");
						this->Show_Status(this->m_csError_Code);
						Save_Trace_Log(this->m_csError_Code);
						this->Show_Out(this->m_csError_Code);
						throw(0);
					}
					else
					{
						this->Show_Out(_T("Switch_To_DL_Mode Pass"));
					}
				}
				else
				{
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------


			//----------------------- SAHARA下载 -----------------------
			if(bDL_Sahara == true)
			{
				this->Show_Out(_T("DL_FW_SAHARA_ALL..."));
				if(this->DL_FW_SAHARA_ALL() == false)
				{
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
				this->Show_Out(_T("DL_FW_SAHARA_ALL Pass"));


				this->Show_Status(_T("DL Norm Switching ......"));
				Save_Trace_Log(_T("DL Norm Switching ......"));
				this->Show_Out(_T("DL Norm Switching..."));

				//关闭COM口前的延时
				Sleep(4000);
				//重启串口
				if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
				{
					this->m_csError_Code += _T(" [DL Re-Start]");
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
				this->Show_Out(_T("DL Norm Switching Pass"));
			}
			//-----------------------
		}//最先检查“开机是否是sahara模式”
		//-----------------------




		//----------------------- Stream下载 -----------------------

		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		this->Show_Out(_T("Send_Stream_Cmd_Hello..."));
		if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}
		//-----------------------
		this->Show_Out(_T("Send_Stream_Cmd_Hello Pass"));

		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));
		//-----------------------

		//----------------------- 设置Security_Mode，我们用“0x01”----------------------- 
		this->Show_Out(_T("Security_Mode..."));
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("Security_Mode Pass"));
		//-----------------------
		//----------------------- 发送Partition_Table文件 ----------------------- 
		this->Show_Out(_T("DL_Partition_Table_File..."));
		if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("DL_Partition_Table_File Pass"));
		//-----------------------

		//----------------------- 下载其他mbn文件 ----------------------- 
		this->Show_Out(_T("DL_Mbn_All_File..."));
		if(this->DL_Mbn_All_File(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		this->Show_Out(_T("DL_Mbn_All_File Pass"));
		//-----------------------
		//20210324
		if ((_T("QDE007NAEF-M21-AAAAA") != m_csOC)
			&& (_T("QDE007NAEF-M21-BAAAA") != m_csOC))
		{
			//----------------------- 下载cefs文件 ----------------------- 
			if (this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
			{
				this->Show_Out(_T("DL_Cefs_File..."));
				if (this->DL_Cefs_File(ulMax_Block_Size) == false)
				{
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					throw(0);
				}
				this->Show_Out(_T("DL_Cefs_File Pass"));
			}
		}
		//-----------------------
		//
		//----------------------- 重启模块 ----------------------- 
		this->Show_Status(_T("Reset..."));
		this->Show_Out(_T("Send_Stream_Cmd_Reset..."));
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			this->Show_Out(this->m_csError_Code);
			throw(0);
		}
		//-----------------------
       //重启成功后再向后延迟10秒
		Sleep(15000);
		this->Show_Out(_T("Send_Stream_Cmd_Reset Pass"));
		this->Show_Status(_T("Reset Pass"));

		//20190801 增加端口的检测
		if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 30) == false)//
		{
			this->m_csError_Code.Format(_T("FAIL,After Reset Com Port:%d"), this->m_iCom_Port);

			this->Show_Out(this->m_csError_Code);
			this->Show_Status(_T("FAIL,After Reset Com Port"));
			throw(0);
		}

		//关闭串口
		this->COM_PORT_CLOSE();


		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);




		/*
		//----------------------- 导入xqcn -----------------------
		if((this->m_bQCN_DL == true) && (this->m_str_Mbn_QCN_DL.b_Enable_DL == true))
		{
			this->Show_Status(_T("Restart ......"));
			//关闭COM口前的延时
			Sleep(2000);
			//重启串口
			if(this->COM_PORT_RE_DETECT(_T("Re-Start"), 4000, false) == false)
			{
				this->m_csError_Code += _T(" [Re-Start]");
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}


			//
			this->Show_Status(_T("Restore xqcn ......"));
			//
			if(::QLIB_QCN_Restore_XQCN(this->m_cla_Com_Port.m_iPort, this->m_str_Mbn_QCN_DL.cs_Path) == false)
			{
				this->Show_Status(_T("FAIL, Restore xqcn fail!"));
				throw(0);
			}
		}
		//-----------------------
		*/




		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			Save_Trace_Log(_T("ERROR, DL type is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Ping_DLoad_Port_MDM9x07(int * ip_Cur_Status, int i_TimeOut)
{
	time_t t_Start, t_End;
	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulTgt_Key_Quan, ulIndex;
	unsigned char ucrTgt_Key_Normal_1[] = {0x13, 0x02, 0x00, 0x00};//（发送过sahara指令后的normal状态的返回）13 02 00 00  00 30 00 00 ...... 00 06 4e 95  7d 5e e7 45  7e
	unsigned char ucrTgt_Key_Normal_2[] = {0x13, 0x06, 0x88, 0xd5, 0x7e};//（没发送过sahara指令后的normal状态的返回）
	unsigned char ucrTgt_Key_2_Streaming[] = {0x7e, 0x02, 0x6a, 0xd3, 0x7e};//Streaming_DLoad
	unsigned char ucrTgt_Key_3_SAHARA[] = {0x01, 0x00, 0x00, 0x00, 0x30};
	unsigned char ucrTgt_Key_4_ERROR[] = {0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};//04 00 00 00 10 00 00 00 0D 00 00 00 01 00 00 00


	try
	{
		this->Show_Status(_T("Ping dload port......"));

		//打包命令，7e 06 4e 95 7e
		this->PKT_DMSS_CMD_NO_OP(&this->m_str_Pkt_Send);


		//计时开始
		time(&t_Start);

		//循环发送指令，并读取响应
		do
		{
			//发送并读取响应
			this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, 2);

			//
			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				break;
			}


			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Ping_DLoad_Port timeout"));
				throw(0);
			}
		}
		while(true);



		//读到响应数据，判定数据，判定状态

		//normal 1
		ulTgt_Key_Quan = 4;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Normal_1, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Normal 1"));
			*ip_Cur_Status = 1;//正常开机

//			::AfxMessageBox(_T("Ping dload port Normal 1"));

			return true;
		}


		//normal 2
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Normal_2, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Normal 2"));
			*ip_Cur_Status = 1;//正常开机

//			::AfxMessageBox(_T("Ping dload port Normal 2"));

			return true;
		}


		//2
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_2_Streaming, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port Streaming"));
			*ip_Cur_Status = 2;//下载中
			return true;
		}

		//3
		ulTgt_Key_Quan = 5;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_3_SAHARA, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port SA"));
			*ip_Cur_Status = 3;//SAHARA模式
			return true;
		}

		//4
		ulTgt_Key_Quan = 8;
		//在 rx_buff 中核对
		if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_4_ERROR, ulTgt_Key_Quan, &ulIndex) == true)
		{
			this->Show_Status(_T("Ping dload port error"));
			*ip_Cur_Status = 4;//错误模式
			return true;
		}



		//无法识别的状态
		this->Show_Status(_T("Ping dload port ND"));
		*ip_Cur_Status = 0;
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FW_SAHARA_ALL(void)
{
	time_t t_Start, t_End;
	int iTimeOut = 8;
	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulIndex;
	unsigned char ucrTgt_Key_3_SAHARA[] = {0x01, 0x00, 0x00, 0x00, 0x30};
	unsigned char ucrTgt_Key_4_EMERG[] = {0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};//04 00 00 00 10 00 00 00 0D 00 00 00 01 00 00 00
	unsigned char ucrHello_Rsp_Packet[] = {0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned long ulImage_ID, ulData_Offset, ulData_Len;
	int iRsp_Type_ID;


	try
	{
		this->Show_Status(_T("DL SA ......"));


		//下载状态待确定
		this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;


		//--------------------------------------- 确认是否已进入“SAHARA” ---------------------------------------
		//打包命令，7e 06 4e 95 7e
		this->PKT_DMSS_CMD_NO_OP(&this->m_str_Pkt_Send);

		//计时开始
		time(&t_Start);

		//循环发送指令，并读取响应
		do
		{
			//发送并读取响应
			this->QUERY_BYTE(this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length, &ucpRead_Data, &ulRead_Quan, 2);

			//
			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				//检查是不是“正常 SAHARA”的关键词
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_3_SAHARA, 5, &ulIndex) == true)
				{
					this->Show_Status(_T("SA download start auto"));
					Save_Trace_Log(_T("SA download start auto"));

					//下载状态待确定
					this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_AUTO;

					//
					break;
				}



				//检查是不是“异常 SAHARA”的关键词
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_4_EMERG, 8, &ulIndex) == true)
				{
					this->Show_Status(_T("SA download start emerg"));
					Save_Trace_Log(_T("SA download start emerg"));

					//下载状态待确定
					this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;

					//
					break;
				}
			}

			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= iTimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Detect SA download timeout!"));
				throw(0);
			}
		}
		while(true);
		//---------------------------------------



		//正常SAHARA模式
		if(this->m_iDL_Emerg_Norm_TYPE == QCMM_DL_TYPE_AUTO)
		{
			//--------------------------------------- 发送“Hello Response packet” ---------------------------------------
			if(this->Query_SA_Read_Data_Packet(ucrHello_Rsp_Packet, 48, 4, &iRsp_Type_ID, &ulImage_ID, &ulData_Offset, &ulData_Len) == false)
			{
				throw(0);
			}
			//---------------------------------------


			//
			if(iRsp_Type_ID != 0x03)
			{
				this->m_csError_Code.Format(_T("FAIL, Detect SA download rsp id wrong!"));
				throw(0);
			}


			//--------------------------------------- 判定下载模式 ---------------------------------------
			if(ulImage_ID == 0x07)
			{
				//正常下载
				this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;

				this->Show_Status(_T("DL SA NORM"));
				Save_Trace_Log(_T("DL SA NORM"));
			}
			else
			{
				this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;

				this->Show_Status(_T("DL SA EMERG"));
				Save_Trace_Log(_T("DL SA EMERG"));
			}
			//---------------------------------------


			//		this->m_csError_Code.Format(_T("ulImage_ID = %d"), ulImage_ID);
			//		::AfxMessageBox(this->m_csError_Code);



			//--------------------------------------- 下载mbn驱动文件 ---------------------------------------
			if(this->DL_FW_SAHARA_Mbn_File(this->m_iDL_Emerg_Norm_TYPE, ulImage_ID, ulData_Offset, ulData_Len) == false)
			{
				throw(0);
			}
			//---------------------------------------
		}
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FW_SAHARA_Mbn_File(int i_DL_Emerg_Norm_Type, unsigned long ul_Image_ID_First, unsigned long ul_Data_Offset_First, unsigned long ul_Data_Length_First)
{
	CString csData;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;
	MBN_FILE_S str_SA_Mbn_File;
	time_t t_Start, t_End;
	unsigned char * ucpRead_Mbn_Buff = NULL;//BYTE
	unsigned long ulRead_Mbn_Byte_Every;		//每次“期望”读mbn的byte数量
	unsigned long ulActual_Read;		//每次“实际”读到mbn的byte数量
	unsigned long ulRead_Mbn_Bytes_All;	//该MBN文件已读到的byte数的统计
	unsigned long ulData_Offset_Every;

	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulIndex;
	int iRsp_Type_ID;
	unsigned long ulImage_ID, ulData_Offset, ulData_Len;

	//Done packet
	unsigned char ucrCmd_Done_Packet[] = {0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00};
	//Done Response packet
	unsigned char ucrTgt_Key_Done_Rsp_Packet[] = {0x06, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00};

	// 上一次的log进度
	int iLastPos = 0;
	double dPos = 0;

	try
	{
		//判定加载哪个下载文件
		switch(i_DL_Emerg_Norm_Type)
		{
		case QCMM_DL_TYPE_EMERG:
			{
				str_SA_Mbn_File.cs_Name.Format(_T("%s"), this->m_str_Mbn_Emerg.cs_Name);
				str_SA_Mbn_File.cs_Path.Format(_T("%s"), this->m_str_Mbn_Emerg.cs_Path);
				str_SA_Mbn_File.b_Enable_DL = true;
			}
			break;
		case QCMM_DL_TYPE_NORM:
			{
				str_SA_Mbn_File.cs_Name.Format(_T("%s"), this->m_str_Mbn_Norm.cs_Name);
				str_SA_Mbn_File.cs_Path.Format(_T("%s"), this->m_str_Mbn_Norm.cs_Path);
				str_SA_Mbn_File.b_Enable_DL = true;
			}
			break;
		default:
			throw(0);
		}



		//打开mbn文件
		hFile_Handle = ::CreateFile(str_SA_Mbn_File.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		CString strlogInfo;
		strlogInfo.Format(_T("%s"),str_SA_Mbn_File.cs_Path);
		Save_Trace_Log(strlogInfo);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Open %s.mbn file failed!"), str_SA_Mbn_File.cs_Name);
			throw(0);
		}



		//获取mbn文件的BYTE数（mbn文件Size）
		str_SA_Mbn_File.ul_File_Size = ::GetFileSize(hFile_Handle, NULL);

		//
		this->m_ul_DL_All_Bytes += str_SA_Mbn_File.ul_File_Size;


		

		//起始值
		ulData_Offset_Every = ul_Data_Offset_First;
		ulRead_Mbn_Byte_Every = ul_Data_Length_First;
		//总byte数量统计
		ulRead_Mbn_Bytes_All = 0;


		//开始读、下载，mbn文件
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}


			//------------------------------ 确定读mbn文件的“偏移量”与“已读出byte数量”的差异 ------------------------------
			ulData_Offset_Every = ulData_Offset_Every - ulRead_Mbn_Bytes_All;


			//是否有“需要读出”但“不需要写入”
			if(ulData_Offset_Every > 0)
			{
				//分配内存
				this->m_cla_GFC.BUFF_BYTE_CALLOC(&ucpRead_Mbn_Buff, (ulData_Offset_Every + 8));

				//
				ulActual_Read = 0;

				//读文件
				if(::ReadFile(hFile_Handle, ucpRead_Mbn_Buff, ulData_Offset_Every, &ulActual_Read, NULL) != TRUE)
				{
					this->m_csError_Code.Format(_T("FAIL, Read mbn file offset failed!"));
					throw(0);
				}

				//释放内存
				this->m_cla_GFC.BUFF_BYTE_FREE(&ucpRead_Mbn_Buff);

				//
				if(ulData_Offset_Every != ulActual_Read)
				{
					this->m_csError_Code.Format(_T("FAIL, Read mbn file offset byte wrong!"));
					throw(0);
				}


				//统计已读到的数据
				ulRead_Mbn_Bytes_All += ulActual_Read;		//单个文件下载过程的数量统计
				this->m_ul_Transmit_Bytes += ulActual_Read;	//完整下载过程的所有文件的数量统计
			}
			//------------------------------



			//------------------------------ 读“真实需要写入的byte” ------------------------------
			//分配内存
			this->m_cla_GFC.BUFF_BYTE_CALLOC(&ucpRead_Mbn_Buff, (ulRead_Mbn_Byte_Every + 8));

			//
			ulActual_Read = 0;

			//读文件
			if(::ReadFile(hFile_Handle, ucpRead_Mbn_Buff, ulRead_Mbn_Byte_Every, &ulActual_Read, NULL) != TRUE)
			{
				this->m_csError_Code.Format(_T("FAIL, Read mbn file data failed!"));
				throw(0);
			}

			//
			if(ulRead_Mbn_Byte_Every != ulActual_Read)
			{
				this->m_csError_Code.Format(_T("FAIL, Read mbn file data byte wrong!"));
				throw(0);
			}


			//统计已读到的数据
			ulRead_Mbn_Bytes_All += ulActual_Read;		//单个文件下载过程的数量统计
			this->m_ul_Transmit_Bytes += ulActual_Read;	//完整下载过程的所有文件的数量统计
			//------------------------------


			dPos = 100.0 * ulRead_Mbn_Bytes_All / str_SA_Mbn_File.ul_File_Size;
            if ((int)dPos > iLastPos)
			{
				//界面显示下载百分比
				csData.Format(_T("Download %s ( %d / %d ) ...... %.0f%%"), str_SA_Mbn_File.cs_Name,
					ulRead_Mbn_Bytes_All, str_SA_Mbn_File.ul_File_Size, dPos);
				this->Show_Status(csData);

				iLastPos = (int)dPos;

				//显示进度条
				this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));//DL_Mbn
			}




			//------------------------------ 发送并读响应 ------------------------------
			iRsp_Type_ID = 0;

			//发送，并读响应
			if(this->Query_SA_Read_Data_Packet(ucpRead_Mbn_Buff, ulActual_Read, 4, &iRsp_Type_ID, &ulImage_ID, &ulData_Offset, &ulData_Len) == false)
			{
				throw(0);
			}


			//释放内存
			this->m_cla_GFC.BUFF_BYTE_FREE(&ucpRead_Mbn_Buff);


			//更新
			ulData_Offset_Every = ulData_Offset;
			ulRead_Mbn_Byte_Every = ulData_Len;
		}
		while(iRsp_Type_ID != 0x04);

	
		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}


		//
		//--------------------------------------- 运行“mbn驱动文件” ---------------------------------------
		//计时开始
		time(&t_Start);

		//循环发送指令，并读取响应
		do
		{
			//发送并读取响应
			this->QUERY_BYTE(ucrCmd_Done_Packet, 8, &ucpRead_Data, &ulRead_Quan, 2);

			//
			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				//在 rx_buff 中核对
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Done_Rsp_Packet, 8, &ulIndex) == true)
				{
					this->Show_Status(_T("SA download re-start"));
					Save_Trace_Log(_T("SA download re-start"));

					//收到“重启”响应
					break;
				}
			}

			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= 4)
			{
				this->m_csError_Code.Format(_T("FAIL, SA download re-start timeout!"));
				throw(0);
			}
		}
		while(true);
		//---------------------------------------


	}
	catch(...)
	{
		//释放内存
		this->m_cla_GFC.BUFF_BYTE_FREE(&ucpRead_Mbn_Buff);

		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Query_SA_Read_Data_Packet(unsigned char * ucp_Cmd_Data, unsigned long ul_Cmd_Quan, int i_TimeOut, int * ip_Rsp_ID, unsigned long * ulp_Rsp_Image_ID, unsigned long * ulp_Rsp_Data_Offset, unsigned long * ulp_Rsp_Data_Length)
{
	time_t t_Start, t_End;
	unsigned long ulImage_ID, ulData_Offset, ulData_Len;
	unsigned char * ucpRead_Data = NULL;//指向“接收串口数据BUFF”的指针
	unsigned long ulRead_Quan, ulIndex;
	unsigned char ucrTgt_Key_Read_Data_Req[] = {0x03, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00};
	unsigned char ucrTgt_Key_End_Image_Trans_Req[] = {0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00};


	try
	{
		//计时开始
		time(&t_Start);


		//循环发送指令，并读取响应
		do
		{
			//发送指令, 并读取响应
			this->QUERY_BYTE(ucp_Cmd_Data, ul_Cmd_Quan, &ucpRead_Data, &ulRead_Quan, 2);

			//
			if(ulRead_Quan > 0)//读到数据则退出循环
			{
				//检查是不是“Read Data packet”关键词
				//在 rx_buff 中核对

				//是否是“继续发送”
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_Read_Data_Req, 8, &ulIndex) == true)
				{
					//SAHARA模式下“Read Data 需求”有回复
					//提取“Read Data 需求”的参数
					if((ulRead_Quan - ulIndex) >= 20)
					{
						//提取数据
						//Image ID1（低位在左，高位在右）
						//(正常)03 00 00 00 14 00 00 00 07 00 00 00 00 00 00 00 34 00 00 00
						//(正常)03 00 00 00 14 00 00 00 07 00 00 00 34 00 00 00 60 00 00 00
						//(紧急)03 00 00 00 14 00 00 00 0D 00 00 00 00 00 00 00 34 00 00 00
						ulImage_ID = *(ucpRead_Data + ulIndex + 11) & 0xFF;
						ulImage_ID = ulImage_ID << 8;
						ulImage_ID |= *(ucpRead_Data + ulIndex + 10) & 0xFF;
						ulImage_ID = ulImage_ID << 8;
						ulImage_ID |= *(ucpRead_Data + ulIndex + 9) & 0xFF;
						ulImage_ID = ulImage_ID << 8;
						ulImage_ID |= *(ucpRead_Data + ulIndex + 8) & 0xFF;
						ulImage_ID &= 0xFFFFFFFF;

						//Data Offset
						ulData_Offset = *(ucpRead_Data + ulIndex + 15) & 0xFF;
						ulData_Offset = ulData_Offset << 8;
						ulData_Offset |= *(ucpRead_Data + ulIndex + 14) & 0xFF;
						ulData_Offset = ulData_Offset << 8;
						ulData_Offset |= *(ucpRead_Data + ulIndex + 13) & 0xFF;
						ulData_Offset = ulData_Offset << 8;
						ulData_Offset |= *(ucpRead_Data + ulIndex + 12) & 0xFF;
						ulData_Offset &= 0xFFFFFFFF;

						//Data Length
						ulData_Len = *(ucpRead_Data + ulIndex + 19) & 0xFF;
						ulData_Len = ulData_Len << 8;
						ulData_Len |= *(ucpRead_Data + ulIndex + 18) & 0xFF;
						ulData_Len = ulData_Len << 8;
						ulData_Len |= *(ucpRead_Data + ulIndex + 17) & 0xFF;
						ulData_Len = ulData_Len << 8;
						ulData_Len |= *(ucpRead_Data + ulIndex + 16) & 0xFF;
						ulData_Len &= 0xFFFFFFFF;


						//返回的数据
						*ulp_Rsp_Image_ID = ulImage_ID;
						*ulp_Rsp_Data_Offset = ulData_Offset;
						*ulp_Rsp_Data_Length = ulData_Len;


						//“Read Data packet”
						*ip_Rsp_ID = 0x03;

						//pass
						break;
					}
				}


				//是否是“结束发送”
				if(this->m_cla_GFC.mem_uc_str(ucpRead_Data, ulRead_Quan, ucrTgt_Key_End_Image_Trans_Req, 8, &ulIndex) == true)
				{
					//“End of Image Transfer packet”
					*ip_Rsp_ID = 0x04;

					//pass
					break;
				}
			}//if(ulRead_Quan > 0

			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Query sa read data rsp timeout!"));
				throw(0);
			}
		}
		while(true);

	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::Send_Mbn_Pkt_Data_V3(PKT_DATA_ADDR_BUFF_S * strp_Mbn_Data_Addr)
{
	//mbn文件数据，以“发一条, 读一条应答”方式处理
	//每次打包buff中“全部数据”成一条指令
	//内存不再反复释放+分配
	//只使用“COM同步通信”

	time_t t_Start, t_End;
	int iTimeOut = 15;//发射完全部数据后，读其数据包确认回复的总超时时间
	int i;
	bool bGet_Rsp_Pass = false;
	unsigned char ucrTgt_Key[] = {0x7e, 0x08};//7E 08 00 00 00 00 57 95 7E
	unsigned long ulIndex;


	try
	{
		//打包一条命令（固定内存）
		if(this->PKT_STREAM_CMD_STREAM_WRITE_V2(&this->m_str_Pkt_Send, strp_Mbn_Data_Addr) == false)
		{
			//打包数据出错，便终止此次下载
			throw(0);
		}


		//计时开始
		time(&t_Start);


		//循环打包发送
		do
		{
			//清空接收BUFF
			this->Clear_Com_Rx_Buffer();


			/*
			//临时代码，故意弄坏模块
			this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length);
			this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length);
			this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length);
			this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length);
			*/


			//发送指令
			if(this->m_cla_Com_Port.Write_Byte((char *)this->m_str_Pkt_Send.ucp_Buff, this->m_str_Pkt_Send.ul_Data_Length) == true)
			{
				for(i=0; i<3; i++)//多次读取是为了防止“回报数据的最初部分有无用数据”
				{
					//只需读9个byte，存入 rx buff 中
					if(this->m_cla_Com_Port.Read_Byte_Sync_V2(9, 3) == true)
					{
						//在 rx_buff 中核对（7E 08 00 00 00 00 57 95 7E）
						if(this->m_cla_GFC.mem_uc_str(
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ucp_Buff,
							this->m_cla_Com_Port.m_str_Com_Rx_Buff.ul_Data_Length,
							ucrTgt_Key, 2, &ulIndex) == true)
						{
							bGet_Rsp_Pass = true;
                            //**************************************************8
// 							wchar_t * wcpTemp_Data = NULL;
// 							int iLen =0;
// 							CString strInfo=_T("");
// 
// 							this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpTemp_Data, (this->m_str_Pkt_Send.ul_Data_Length + 16));
// 
// 							this->m_cla_GFC.MultiByte_To_WideChar(reinterpret_cast<char*> (this->m_str_Pkt_Send.ucp_Buff), wcpTemp_Data, &iLen);
// 
// 							strInfo.Format(_T("%s"), wcpTemp_Data);
// 
// 							this->Show_Out(strInfo);
// 
// 							this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpTemp_Data);
							//**************************************************8

							break;//for
						}
					}
				}//for(i=0; i<3; i++


				//判断提取数据的结果
				if(bGet_Rsp_Pass == true)
				{
					break;//while
				}
			}//write成功



			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= iTimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Send_Mbn_Pkt_Data_V3 timeout"));
				throw(0);
			}


			//
			Sleep(500);
		}
		while(bGet_Rsp_Pass == false);
	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_Mbn_Pkt_Data_V3]");

		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_Mbn_File_V2(const MBN_FILE_S str_Mbn_File, unsigned long ul_Pkt_Data_Len)
{
	//每次从mbn文件中读取“一个包的mbn数据”，然后发送并读取响应。
	//mbn文件数据，以“发一条, 读一条应答”方式处理

	CString csData;
	HANDLE hFile_Handle = INVALID_HANDLE_VALUE;
	unsigned long ul_File_Size;				//MBN文件总byte数
	unsigned long ul_Read_Bytes_All = 0;	//该MBN文件已读到的byte数的统计
	// 上一次的log进度
	int iLastPos = 0;
	double dPos = 0;


	try
	{
		//数据结构BUFF
		//每次读取文件的BUF + 待发送的文件数据的BUFF + 剩余数据的BUFF
		//初始化结构体
		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Mbn_Buff.str_Data);
		this->m_str_Mbn_Buff.dw_Pkt_Addr = 0x00;
		this->m_str_Mbn_Buff.b_Read_Finish = false;


		//打开mbn文件
		hFile_Handle = ::CreateFile(str_Mbn_File.cs_Path,
			GENERIC_READ,				//文件的操作属性 Read only required
			FILE_SHARE_READ,			//文件共享属性 read share file
			NULL,						//文件安全特性 SecurityAttributes - none in Win95
			OPEN_EXISTING,				//文件操作 how to create
			FILE_FLAG_SEQUENTIAL_SCAN,	//文件属性 file attributes
			NULL	//如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 handle of file with attributes to copy
			);

		if(hFile_Handle == INVALID_HANDLE_VALUE)
		{
			this->m_csError_Code.Format(_T("FAIL, Open %s.mbn file failed!"), str_Mbn_File.cs_Name);
			throw(0);
		}

		//获取mbn文件的BYTE数（mbn文件Size）
		ul_File_Size = ::GetFileSize(hFile_Handle, NULL);




		//清空待分配的内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);
		//分配内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Mbn_Buff.str_Data, (ul_Pkt_Data_Len + 8));



		//先释放“send指令buff”内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		//分配“send指令buff”内存
		this->m_cla_GFC.PKT_BUFF_CALLOC(&this->m_str_Pkt_Send, ((9 + ul_Pkt_Data_Len) * 3 / 2));




		//开始读、下载，mbn文件
		do
		{
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}



			//清空每次使用的Read Buff
			this->m_str_Mbn_Buff.str_Data.ul_Data_Length = 0;


			//读文件
			if(::ReadFile(hFile_Handle, this->m_str_Mbn_Buff.str_Data.ucp_Buff,
				ul_Pkt_Data_Len, &this->m_str_Mbn_Buff.str_Data.ul_Data_Length, NULL) != TRUE)
			{
				this->m_csError_Code.Format(_T("FAIL, Read mbn file failed!"));
				throw(0);
			}


			//统计已读到的数据
			ul_Read_Bytes_All += this->m_str_Mbn_Buff.str_Data.ul_Data_Length;
			this->m_ul_Transmit_Bytes += this->m_str_Mbn_Buff.str_Data.ul_Data_Length;


			dPos = 100.0 * ul_Read_Bytes_All / ul_File_Size;
			if ((int)dPos > iLastPos)
			{
				//界面显示下载百分比
				csData.Format(_T("Download %s ( %d / %d ) ...... %.0f%%"), str_Mbn_File.cs_Name,
					ul_Read_Bytes_All, ul_File_Size, dPos);
				this->Show_Status(csData);

				iLastPos = (int)dPos;

				//显示进度条
				this->Show_Progress((1.0 * this->m_ul_Transmit_Bytes / this->m_ul_DL_All_Bytes));//DL_Mbn
			}



			//“已读出的总数”等于“文件实际大小”
			if(ul_Read_Bytes_All == ul_File_Size)
			{
				this->m_str_Mbn_Buff.b_Read_Finish = true;
			}


			if(this->m_str_Mbn_Buff.str_Data.ul_Data_Length > 0)
			{
				//发送this->m_str_Mbn_Buff中的有用数据
				if(this->Send_Mbn_Pkt_Data_V3(&this->m_str_Mbn_Buff) == false)
				{
					throw(0);
				}
			}
		}
		while((this->m_str_Mbn_Buff.str_Data.ul_Data_Length > 0) || (this->m_str_Mbn_Buff.b_Read_Finish == false));//“待发送的数据”必须全部发完；文件已读完；才会结束循环




		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);
	}
	catch(...)
	{
		//关闭mbn文件
		if(hFile_Handle != INVALID_HANDLE_VALUE)
		{
			::CloseHandle(hFile_Handle);
		}

		//释放内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Mbn_Buff.str_Data);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FW_SAHARA_EMERG(void)
{
	//发送“Hello_Rsp_Packet指令”，看是否是sahara模式，如果是，就直接下载sahara mbn文件

	time_t t_Start, t_End;
	int iTimeOut = 3;
	unsigned char ucrHello_Rsp_Packet[] = {0x02, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	unsigned long ulImage_ID, ulData_Offset, ulData_Len;
	int iRsp_Type_ID;


	try
	{
		this->Show_Status(_T("Detect and DL SA ......"));
		Save_Trace_Log(_T("Detect and DL SA ......"));

		//下载状态待确定
		this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NDF;


		//--------------------------------------- 确认是否已进入“SAHARA” ---------------------------------------

		//计时开始
		time(&t_Start);

		//循环发送指令，并读取响应
		do
		{
			//--------------------------------------- 发送“Hello Response packet” ---------------------------------------
			if(this->Query_SA_Read_Data_Packet(ucrHello_Rsp_Packet, 48, 2, &iRsp_Type_ID, &ulImage_ID, &ulData_Offset, &ulData_Len) == true)
			{
				//检查rsp值
				if(iRsp_Type_ID != 0x03)
				{
					this->m_csError_Code.Format(_T("FAIL, Detect and DL SA download rsp id wrong!"));
					Save_Trace_Log(_T("FAIL, Detect and DL SA download rsp id wrong!"));
					throw(0);
				}


				//判定下载模式
				if(ulImage_ID == 0x07)
				{
					//03 00 00 00 14 00 00 00 07 00 00 00 00 00 00 00 34 00 00 00
					//正常下载
					this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_NORM;

					this->Show_Status(_T("DL SA NORM"));

//					::AfxMessageBox(_T("DL SA NORM"));

					//探测到 sahara norm
					break;
				}
				else
				{
					//03 00 00 00 14 00 00 00 0D 00 00 00 00 00 00 00 34 00 00 00 
					//紧急下载
					this->m_iDL_Emerg_Norm_TYPE = QCMM_DL_TYPE_EMERG;

					this->Show_Status(_T("DL SA EMERG"));

//					::AfxMessageBox(_T("DL SA EMERG"));

					//探测到 sahara emerg
					break;
				}
			}
			//---------------------------------------


			//超时检测
			time(&t_End);
			//
			if(difftime(t_End, t_Start) >= iTimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Detect and DL SA timeout!"));
				throw(0);
			}
		}
		while(true);
		//---------------------------------------



		//--------------------------------------- 下载mbn驱动文件 ---------------------------------------
		if(this->DL_FW_SAHARA_Mbn_File(this->m_iDL_Emerg_Norm_TYPE, ulImage_ID, ulData_Offset, ulData_Len) == false)
		{
			throw(0);
		}
		//---------------------------------------
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::FB_ERASE(const wchar_t * wcp_Erase_Cmd)
{
	//使用fastboot.exe命令模块erase
	//fastboot.exe erase misc
	//fastboot.exe erase fota

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp;
	int iTemp;
	bool bSuccess_Flag = false;


	try
	{
		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_ERASE, Create pipe fail!"));
			throw(0);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe erase %s"), '/', this->m_csCurr_Exe_Path, this->m_iClass_Idx, wcp_Erase_Cmd);


//		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_ERASE, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//显示每次的读出data
				csTemp.Format(_T("FB erase %s %s"), wcp_Erase_Cmd, csData);
				this->Show_Status(csTemp);

				//汇总数据
				csTotal_Info += csData;
				csTotal_Info.MakeLower();
			}//if(ulActual_Read > 0

			//检查是否pass
			if((wcsstr(csTotal_Info, _T("finished")) != NULL) && (wcsstr(csTotal_Info, _T("total time")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= 10)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, FB_ERASE, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		return false;
	}

	//
	return bSuccess_Flag;
}

int CARM_OP_QCM::Execute_MDM9X15_V2(void)
{
	//9x15平台“有代码锁定”下载
	//多口下载使用

	time_t t_Start, t_End;
	CString csData;
	int iTime;
	bool bFind_Adb_Device = false;


	try
	{
		//------------------------------ 等同开机初始化时间 ------------------------------
		//自动夹具模式下，要给出足够开机时间，先判定是否生成adb设备
		time(&t_Start);
		//
		do
		{
			Sleep(900);
			//
			time(&t_End);
			//
			iTime = (int)difftime(t_End, t_Start);

			//
			csData.Format(_T("INIT & Detect adb port ...... %ds"), iTime);
			this->Show_Status(csData);
			//
			if(iTime >= 10)
			{
				break;//一直没有adb设备，退出while
			}


			//判断是否有adb设备
			if((this->FB_DEVICE_V1() == true) && (::g_bFastboot_Runing == false))
			{
				//发现adb设备，并且不是“正常下载运行中”的，则是“直接进入fastboot模式的问题模块”
				bFind_Adb_Device = true;
				//
				break;
			}
		}
		while( true );
		//------------------------------




		//------------------------------ 探测是否有adb设备（用于修复异常模块）------------------------------
		if( bFind_Adb_Device == false )
		{
			//------------------------------ 正常，没有adb设备，则是正常下载 ------------------------------


			//刷新COM参数
			this->Load_Com_Port_Params();



			//------------------------------ 检查串口是否存在 ------------------------------ 
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port) == true)
			{
				//DM口已经存在，则说明模块已预先开机，无需特别延迟
			}
			else
			{
				//DM口还不存在，需要探测，并额外给开机延迟时间

				//探测DM口生成
				if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 60) == false)
				{
					this->Show_Status(this->m_csError_Code);

					m_iError_Code = 1000;
					throw(1);
				}


				//DM端口刚生成后，模块初始化未完成，模块无法下载
				Sleep(6500);
			}
			//------------------------------



			//------------------------------ 从模块中备份出QCN，FTM模式 ------------------------------ 
			if(this->m_bQCN_BACKUP == true)
			{
				if(this->BACKUP_QCN(this->m_str_Mbn_QCN_BU_RS) == false)
				{
					throw(2);
				}
			}
			//------------------------------


			//------------------------------ 把FW中的QCN文件导入模块 ------------------------------ 
			if(this->m_bQCN_DL == true)
			{
				if(this->RESTORE_QCN(this->m_str_Mbn_QCN_BU_RS, this->m_str_Mbn_QCN_DL) == false)
				{
					//紧急下载时，QDloader口无法下载QCN文件，所以可以忽略这个fail
					if(this->m_bFW_DL == true)
					{
						this->Show_Status(_T(""));
					}
					else
					{
						throw(5);
					}
				}
			}
			//------------------------------


			//------------------------------ 下载FW操作（包括假文件），下载模式 ------------------------------ 
			if(this->m_bFW_DL == true)
			{
				//第一阶段下载
				//第一次DM口下载“mbn和假文件”
				if(this->DL_FW_V3(false) != RTN_SUCCESS)
				{
					throw(3);
				}



				//第二阶段下载
				//准备重启，进入“fastboot”模式
				//并下载fastboot软件
				if(this->FB_DL_IN_LOCK_V1( true ) == false)
				{
					throw(4);
				}
			}
			//------------------------------
		}//if(this->FB_DEVICE_V1() == false
		else
		{
			//------------------------------ 异常，有adb设备 ------------------------------

			//最初下载时没有COM口
			this->m_iCom_Port = -1;


			//----------------------- 确定将下载的FW的byte总数 ----------------------- 
			int i;
			//清空发送Byte统计
			this->m_ul_Transmit_Bytes = 0;
			//计算下载文件的总大小
			this->m_ul_DL_All_Bytes = 0;

			for(i=0; i<MAX_MBN_FILE; i++)
			{
				if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
				}
			}

			//
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;

			//如果下载CEFS文件，就要增加CEFS文件的大小
			if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
			{
				this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
			}

			//Fastboot下载完成后，重新用协议下载的mbn文件
			this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[SBL2_MBN_FILE_I].ul_File_Size;

			//YAFFS2文件
			for(i=0; i<MAX_YAFFS2_FILE; i++)
			{
				if(this->m_strr_Yaffs2_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Yaffs2_File_List[i].ul_File_Size;
				}
			}

			//IMG文件
			for(i=0; i<MAX_IMG_FILE; i++)
			{
				if(this->m_strr_Img_File_List[i].b_Enable_DL == true)
				{
					this->m_ul_DL_All_Bytes += this->m_strr_Img_File_List[i].ul_File_Size;
				}
			}

			//yaffs_head.aa
			if(this->m_str_Yaffs_Head_aa.b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_aa.ul_File_Size;
			}

			//yaffs_head.ab
			if(this->m_str_Yaffs_Head_ab.b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_str_Yaffs_Head_ab.ul_File_Size;
			}
			//----------------------- 




			//直接进入“第二阶段下载”
			if(this->FB_DL_IN_LOCK_V1( false ) == false)
			{
				throw(6);
			}
		}
		//------------------------------




		//------------------------------ 在fastboot模式下载yaffs2和img文件 ------------------------------ 
		if(this->m_bFastboot_DL == true)
		{
			//第三阶段下载
			//下载最后的“真SBL2”文件
			if(this->DL_FW_SBL2() == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
		//------------------------------



		//------------------------------ 把先前备份的QCN导入模块 ------------------------------ 
		if(this->m_bQCN_RESTORE == true)
		{
			if(this->m_bFW_DL || this->m_bFastboot_DL)
			{
				//确认下载口
				if(this->Update_USB_DL_Port(this->m_iCom_Port, &this->m_iCom_Port) == false)
				{
					throw(6);
				}

				//刷新COM参数
				this->Load_Com_Port_Params();

				//模块下载重启后的初始化时间
				Sleep(3000);
			}

			//由于qcn操作无法重启模块，所以放在最后
			if(this->RESTORE_QCN(this->m_str_Mbn_QCN_BU_RS, this->m_str_Mbn_QCN_DL) == false)
			{
				throw(5);
			}
		}
		//------------------------------

	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

bool CARM_OP_QCM::FB_DL_IN_LOCK_V1(bool b_Reset_DUT)
{
	//1.发送“reset指令”使模块重启，进入fastboot模式。（有代码锁定）
	//2.在fastboot模式中，下载所有FW文件，并reboot重启
	//3.重新搜索新生成的DM下载口
	//注意，只有在fastboot软件下载结束后，在多通道同时下载时，有多少模块，就会反馈多少条“mdm9615   fastboot”关键词


	try
	{
		//显示
		this->Show_Status(_T("Wait for fastboot download ......"));


		//代码锁定
		::g_cla_Lock_DM_FB.Lock();
		//fastboot运行中
		::g_bFastboot_Runing = true;



		//------------------------------ 发送reset指令，切换到fastboot模式 ------------------------------
		if(b_Reset_DUT == true)
		{
			if(this->Switch_Fastboot_Mode_In_Reset_Cmd() == false)
			{
				throw(0);
			}
		}
		//------------------------------




		//------------------------------ 直接进入“第二阶段下载”------------------------------
		if(this->FB_DL_IN_LOCK_V2() == false)
		{
			throw(6);
		}
		//------------------------------
	}
	catch(...)
	{
		//fastboot运行结束
		::g_bFastboot_Runing = false;
		//代码解锁
		::g_cla_Lock_DM_FB.Unlock();

		//
		return false;
	}


	//fastboot运行结束
	::g_bFastboot_Runing = false;
	//代码解锁
	::g_cla_Lock_DM_FB.Unlock();

	//
	return true;
}

bool CARM_OP_QCM::FB_DL_IN_LOCK_V2(void)
{
	//1.已进入fastboot模式。（有代码锁定）
	//2.在fastboot模式中，下载所有FW文件，并reboot重启
	//3.重新搜索新生成的DM下载口
	//注意，只有在fastboot软件下载结束后，在多通道同时下载时，有多少模块，就会反馈多少条“mdm9615   fastboot”关键词


	try
	{
		//显示
		this->Show_Status(_T("Find fastboot mode ......"));


		//代码锁定
		::g_cla_Lock_FB_DM.Lock();



		//确认是否有“adb设备”
		if(this->FB_DEVICE_V1() == false)
		{
			this->m_csError_Code.Format(_T("ERROR, FB_DL_2, Detect adb fail!"));
			throw(0);
		}



		//fastboot模式时下载“几乎所有软件文件”
		if(this->DL_FB_V3(false, false) == false)
		{
			throw(0);
		}



		//准备reboot重启，再次进入“DM”模式
		if(this->Reboot_ADB_And_Enter_DM() == false)
		{
			throw(0);
		}

	}
	catch(...)
	{
		//代码解锁
		::g_cla_Lock_FB_DM.Unlock();

		//
		return false;
	}


	//代码解锁
	::g_cla_Lock_FB_DM.Unlock();

	//
	return true;
}

bool CARM_OP_QCM::Reboot_ADB_And_Enter_DM(void)
{
	//
	try
	{
		//显示
		this->Show_Status(_T("Switch dm mode ......"));


		//清空buff
		m_iCom_Quan_old = 0;
		memset(m_irCom_List_old, 0, sizeof(m_irCom_List_old));
		if(this->m_cla_GFC.Get_Reg_Com_Port_List(m_irCom_List_old, &m_iCom_Quan_old) == false)
		{		
			this->m_csError_Code.Format(_T("FAIL, Get_Reg_Com_Port_List, Read reg fail!"));
			throw(0);
		}

		//重启
		this->FB_REBOOT();




		//确认下载口（此处下载口会“无法预知的变号”）
		if(this->Update_USB_DL_Port(this->m_iCom_Port, &this->m_iCom_Port) == false)
		{
			throw(6);
		}



		//刷新COM参数
		this->Load_Com_Port_Params();



		//显示
		this->Show_Status(_T("Switch dm mode completely"));
	}
	catch(...)
	{
		return false;
	}


	//
	return true;
}

bool CARM_OP_QCM::FB_DEVICE_V2(int * ip_Adb_Quan)
{
	//使用fastboot.exe探测一次是否有“新adb设备”生成
	//先记录“老adb设别数量”，然后等到有“新adb设备”生成，否则超时报fail。

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	unsigned long ulActual_Read;
	CString csTotal_Info;
	int iTemp;
	bool bSuccess_Flag = false;
	int iAdb_Quan = 0;


	try
	{
		//
		csTotal_Info.Format(_T(""));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DEVICE, Create pipe fail!"));
			throw(0);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fastboot.exe devices"), '/', this->m_csCurr_Exe_Path, this->m_iClass_Idx);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, FB_DEVICE, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 


		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		//读info（若.exe运行已结束，还继续read的话，会死在这一步）
		memset(cpRead_Buff, 0, 2048);
		ulActual_Read = 0;
		//
		ReadFile(hRead_Pipe, cpRead_Buff, 2000, &ulActual_Read, NULL);

		//读到info数据了
		if(ulActual_Read > 0)
		{
			//字符转换
			memset(wcpData, 0, 2048);
			this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

			csTotal_Info.Format(_T("%s"), wcpData);
			csTotal_Info.Replace(_T('\r'), _T(' '));
			csTotal_Info.Replace(_T('\n'), _T(' '));

//			this->Save_Trace_Log(csTotal_Info);

			//汇总数据
			csTotal_Info.MakeLower();

			this->Show_Status(csTotal_Info);
		}//if(ulActual_Read > 0


		//检查是否pass
		if(wcsstr(csTotal_Info, _T("fastboot")) != NULL)
		{
			//pass
			bSuccess_Flag = true;

			//检索+统计，共有多少条关键词
			this->Count_Key_Word_Quan(csTotal_Info, _T("fastboot"), &iAdb_Quan);
		}
		else
		{
			//pass
			bSuccess_Flag = true;

			//当前没有adb设备
			iAdb_Quan = 0;			
		}
		//------------------------------


		/*
		CString cs;
		cs.Format(_T("[quan = %d],  %s"), iAdb_Quan, csTotal_Info);
		::AfxMessageBox(cs);
		*/


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//返回数据
		*ip_Adb_Quan = iAdb_Quan;
	}
	catch(...)
	{
		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		//
		*ip_Adb_Quan = 0;

		//
		return false;
	}

	//
	return bSuccess_Flag;
}

void CARM_OP_QCM::Count_Key_Word_Quan(const wchar_t * wcp_Src_Data, const wchar_t * wcp_Key_Word, int * ip_Key_Quan)
{
	wchar_t * wcpKey = NULL;
	wchar_t * wcpHead = NULL;
	wchar_t * wcpSrc_Buff = NULL;
	unsigned long ulBuff_Len = wcslen(wcp_Src_Data) + 8;//用于存放“源数据”的buff长度
	int iKey_Len = wcslen(wcp_Key_Word);
	int iQuan = 0;


	//分配内存
	this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpSrc_Buff, ulBuff_Len);

	//载入“源数据”
	swprintf(wcpSrc_Buff, _T("%s"), wcp_Src_Data);

	//初始地址赋值
	wcpHead = wcpSrc_Buff;

	//循环计数
	do
	{
		//检查是否有关键词
		wcpKey = wcsstr(wcpHead, wcp_Key_Word);
		//
		if(wcpKey != NULL)
		{
			//发现关键词
			//删除发现的关键词
			wcpKey += iKey_Len;

			//重新赋值
			wcpHead = wcpKey;

			//计数 +1
			iQuan++;
		}
		else
		{
			//无关键词
			break;
		}
	}
	while(true);


	//释放内存
	this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpSrc_Buff);


	//返回数量
	*ip_Key_Quan = iQuan;
}

bool CARM_OP_QCM::Switch_Fastboot_Mode_In_Reset_Cmd(void)
{
	//发送“reset指令”使模块重启，判断是否有adb设备生成，进入fastboot模式。
	//注意，只有在fastboot软件下载结束后，在多通道同时下载时，有多少模块，就会反馈多少条“mdm9615   fastboot”关键词

	int iTimeOut = 50;//探测adb设备的超时
	time_t t_Start, t_End;
	CString csData;
	int iTemp, iLast_Quan, iCurr_Quan;


	try
	{
		//显示
		this->Show_Status(_T("Switch fastboot mode ......"));



		//读初始“adb数量”
		if(this->FB_DEVICE_V2( &iLast_Quan ) == false)
		{
			this->m_csError_Code.Format(_T("ERROR, Switch_FB, Read adb quan 1st fail!"));
			throw(0);
		}



		//------------------------------ 发送reset指令 ------------------------------
		//打开DM下载口
		if(this->COM_PORT_OPEN() == false)
		{
			this->m_csError_Code.Format(_T("ERROR, Switch_FB, %s"), this->GET_COM_PORT_ERROR_INFO());
			throw(0);
		}


		//重启模块
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			this->Show_Status(this->m_csError_Code);
			throw(0);
		}


		//关闭串口
		this->COM_PORT_CLOSE();


		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);
		//------------------------------



		//------------------------------ 搜索、探测adb设备 ------------------------------ 
		//开始计时
		time(&t_Start);
		//
		do
		{
			//读当前“adb数量”
			if(this->FB_DEVICE_V2( &iCurr_Quan ) == false)
			{
				this->m_csError_Code.Format(_T("ERROR, Switch_FB, Read adb quan fail!"));
				throw(0);
			}


			//检查是否有新adb
			if(iCurr_Quan == (iLast_Quan + 1))// || (iCurr_Quan == 1))
			{
				//有新adb设备生成
				break;
			}



			//超时检测
			time(&t_End);
			iTemp = (int)difftime(t_End, t_Start);
			iTemp = iTimeOut - iTemp;
			//显示
			csData.Format(_T("Switch fastboot, detect adb (%d) ...... %d"), iCurr_Quan, iTemp);
			this->Show_Status(csData);
			//超时，报fail
			if(iTemp <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, Switch_FB, Detect adb device time out!"));
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}



			//保存上次数据
			iLast_Quan = iCurr_Quan;

			//
			Sleep(700);
		}
		while(true);
		//------------------------------ 



		//显示
		this->Show_Status(_T("Switch fastboot mode completely"));

	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//
		return false;
	}


	//
	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_V3(const wchar_t * wcp_FW_File_Path)
{
	//MSM8909
	//判定、加载8909的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .mbn 文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//挑出“prog_emmc_firehose_8909_ddr.mbn”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].b_Enable_DL = true;

						//保存全路径
						this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Path);
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();

		
		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::Switch_EDL_Sub(void)
{
	CString csData;
    try
    {  
		//----------------------- 打开串口（第一次）----------------------- 
		csData.Format(_T("Open Port%d ......"),this->m_iCom_Port);
		this->Show_Status(csData);
		this->Show_Out(csData);
		this->Save_Trace_Log(csData);

		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)  
		{
			time_t start,finish;
			int iTimeOut =9;//打开端口改为循环查找打开的方式
			try
			{
				//
				time( &start );
				do
				{
					Sleep( 200 );
					if(true == this->COM_PORT_OPEN())
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						break;
					}
					//
					time( &finish );
					//
					if( (int)difftime( finish, start ) >= iTimeOut )
					{
						throw(0);
					}
				}
				while( true );
			}
			catch(...)
			{
				csData.Format(_T("%s"), this->GET_COM_PORT_ERROR_INFO());
				this->Show_Status(csData);
				m_csError_Code = csData;
				this->Show_Out(csData);
				this->Save_Trace_Log(csData);
				throw(0);
			}

		}

		//发送指令之前保存注册表 HEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM 中的端口值
		if ((m_eu_BB_Chip == MSM8953)
			||(m_eu_BB_Chip == MSM8909)
			||(m_eu_BB_Chip == MSM8917)
			||(m_eu_BB_Chip == MDM9X40)
			||(m_eu_BB_Chip == SDX20)
			||(m_eu_BB_Chip == SDX55)
			||(m_eu_BB_Chip == MDM9X07)
			||(m_eu_BB_Chip == MDM9X06)
			||(m_eu_BB_Chip == MDM9X55)
			||(m_eu_BB_Chip == MDM9X05)
			||(m_eu_BB_Chip == SDM660)
			||(m_eu_BB_Chip == SDM845)
			||(m_eu_BB_Chip == QCM6125)
			|| (m_eu_BB_Chip == AG215S)
			|| (m_eu_BB_Chip == SM4350)
			)
		{			
			//清空buff
			m_iCom_Quan_old = 0;
			memset(m_irCom_List_old, 0, sizeof(m_irCom_List_old));
			if(this->m_cla_GFC.Get_Reg_Com_Port_List(m_irCom_List_old, &m_iCom_Quan_old) == false)
			{		
				this->m_csError_Code.Format(_T("FAIL, Get_Reg_Com_Port_List, Read reg fail!"));
				this->Show_Out(m_csError_Code);
				this->Show_Status(m_csError_Code);
				this->Save_Trace_Log(m_csError_Code);
				throw(0);
			}
		}


		//----------------------- 发送切换EDL模式的指令（4b 65 01 00 54 0f 7e）-----------------------
		if(this->Send_EDL_Mode_Cmd() == false)
		{
			//如果发送EDL失败，再发送一遍
			//Sleep(3000);
			//if(this->Send_EDL_Mode_Cmd() == false)
			//{
			//	this->Show_Out(_T("Send_EDL_Mode_Cmd Fail"));
				//throw(1);
			//}		
			//throw(1);

		}
		//----------------------- 关闭串口 -----------------------
		this->COM_PORT_CLOSE();
		this->Show_Status(_T("Close DM Port"));
		this->Show_Out(_T("Close DM Port"));
		this->Save_Trace_Log(_T("Close DM Port"));
		//-----------------------
		//-----------------------
		//检查DM口是否还存在
		Sleep(500);
		if (false ==  Confirm_Dynamic_Com_Port_N(this->m_iCom_Port, 30))
		{
			//如果DM存在认为是FAIL
			return false;
		} 
		else
		{
			return true;
		}
		

	}
	catch (...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();
		return false;
	}
	return true;
}

bool CARM_OP_QCM::Switch_EDL(int * ip_New_QDLoader_Port)
{
	//切换EDL模式，并探测、返回新下载用的QDLoader口
	int iNew_QDLoader_Port = 0;
	CString csData;

	int iQD_1(0),iQD_2(0),iQD_3(0),iQD_4(0);
	BOOL bFind=FALSE;


	//
	try
	{
		//显示
		
		csData.Format(_T("Switch EDL mode(Port%d) ......"),this->m_iCom_Port);
		this->Show_Status(csData);
		this->Show_Out(csData);
		this->Save_Trace_Log(csData);


		//代码锁定
		::g_cla_Lock_Enter_EDL.Lock();

		switch(m_iClass_Idx)
		{
			case 1:
				iQD_2 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);
				iQD_3 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);
				iQD_4 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);
				break;
			case 2:
				iQD_1 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);
				iQD_3 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);
				iQD_4 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);
				break;
			case 3:
				iQD_1 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);
				iQD_2 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);
				iQD_4 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);
				break;
			case 4:
				iQD_1 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);
				iQD_2 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);
				iQD_3 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);
				break;
		}

		
		//发送切换EDL模式的指令（4b 65 01 00 54 0f 7e）
		if (false == Switch_EDL_Sub())
		{
			//再进行一次
			if (false == Switch_EDL_Sub())
			{
				throw(0);
			}
		}

		if (true == m_bPCIE_DL)//PCIE场景下
		{
			// 启动Q_DL_QBhiServer
			if (Q_DL_QBhiServer() == false)
			{
				throw(4);
			}

			//20201230--增加下刷口的动作尝试
			//刷口操作
			if (false == this->Confirm_PCIE_UDE_EDL_Port(30))
			{
				//
				this->Show_Out(_T("[FAIL] Detect UDE EDL Port Fail-1"));
				throw(4);
			}
			else
			{
				//
				this->Show_Out(_T("Confirm_PCIE_Port PASS-1"));
			}
		}
		else
		{

		}

		//----------------------- 确认EDL用的“新生成的”QDLoader下载口（此处QDLoader下载口会“无法预知的变号”）-----------------------
		//60秒超时
		m_iCom_Quan_MSM8953 =0;
		memset(m_irCom_List_MSM8953, 0, sizeof(m_irCom_List_MSM8953));

		if(this->Update_USB_QDLoader_Port(this->m_iCom_Port, &iNew_QDLoader_Port) == false)
		{
			this->Show_Status(_T("Find QDLoader Port(Second)"));
			this->Show_Out(_T("Find QDLoader Port(Second)"));

			//MSM8953平台可能查询不到 COM口数量 由减少到 增加的这一瞬间的过程，但是QDload可能已经生成
			if ((m_eu_BB_Chip == MSM8953) 
				||(m_eu_BB_Chip == MSM8909)
				||(m_eu_BB_Chip == MSM8917)
				||(m_eu_BB_Chip == MDM9X40)
				||(m_eu_BB_Chip == SDX20)
				||(m_eu_BB_Chip == SDX55)
				||(m_eu_BB_Chip == MDM9X07)
				||(m_eu_BB_Chip == MDM9X06)
				||(m_eu_BB_Chip == MDM9X55)
				||(m_eu_BB_Chip == MDM9X05)
				||(m_eu_BB_Chip == SDM660)
				||(m_eu_BB_Chip == SDM845)
				||(m_eu_BB_Chip == SM6115)
				|| (m_eu_BB_Chip == QCM6125)
				|| (m_eu_BB_Chip == SM4350)
				) 
			{
				int i,j;
				int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
				bool bEDL_Now = false;//是否“已经是EDL模式”
				//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
				//清空
				iQDL_Port_Quan = 0;
				memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

				//读PC机存在的所有“QDLoader”口记录
				this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

				//核对“当前获取到注册表中的COM口”是不是已经是“8953的QDLoader口”
				iNew_QDLoader_Port =0;
				for(i=0; i<m_iCom_Quan_MSM8953;i++)
				{
					for(j=0; j<iQDL_Port_Quan; j++)
					{
						if(m_irCom_List_MSM8953[i] == irQDL_Port_List[j])
						{
							iNew_QDLoader_Port = irQDL_Port_List[j];
							int num=0;
							for(num=0; num<4; num++)
							{

// 								if (g_QDL_USE_Port_List[num] ==iNew_QDLoader_Port)
// 								{
// 									//继续找QDload口
// 									break;
// 								}

								switch(m_iClass_Idx)
								{
									case 1:
										if (((iQD_2 !=0)&&(iQD_2 ==iNew_QDLoader_Port))
											||((iQD_3 !=0)&&(iQD_3 ==iNew_QDLoader_Port))
											||((iQD_4 !=0)&&(iQD_4 ==iNew_QDLoader_Port)))
										{
											//继续找QDload口
											bFind =TRUE;
										}
										break;
									case 2:
										if (((iQD_1 !=0)&&(iQD_1 ==iNew_QDLoader_Port))
											||((iQD_3 !=0)&&(iQD_3 ==iNew_QDLoader_Port))
											||((iQD_4 !=0)&&(iQD_4 ==iNew_QDLoader_Port)))
										{
											//继续找QDload口
											bFind =TRUE;
										}
										break;
									case 3:
										if (((iQD_1 !=0)&&(iQD_1 ==iNew_QDLoader_Port))
											||((iQD_2 !=0)&&(iQD_2 ==iNew_QDLoader_Port))
											||((iQD_4 !=0)&&(iQD_4 ==iNew_QDLoader_Port)))										
										{
											//继续找QDload口
											bFind =TRUE;
										}
										break;
									case 4:
										if (((iQD_1 !=0)&&(iQD_1 ==iNew_QDLoader_Port))
											||((iQD_2 !=0)&&(iQD_2 ==iNew_QDLoader_Port))
											||((iQD_3 !=0)&&(iQD_3 ==iNew_QDLoader_Port)))											
										{
											//继续找QDload口
											bFind =TRUE;
										}
										break;
								}
								if (bFind ==TRUE)
								{
									//继续找QDload口
									break;
								}

							}
							if (num<4)//说明已经存在
							{
								//继续找QDload口
								continue;
							}
													
						}
						
					}//for(j=0; j<iQDL_Port_Quan; j++
				}
				if (iNew_QDLoader_Port ==0)
				{
					//做一次补救
					switch(m_iClass_Idx)
					{
						case 1:
							iNew_QDLoader_Port=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);break;
							break;
						case 2:
							iNew_QDLoader_Port=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);break;
							break;
						case 3:
							iNew_QDLoader_Port=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);break;
							break;
						case 4:
							iNew_QDLoader_Port=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);break;
							break;
					}
					//依旧为空
					if (iNew_QDLoader_Port ==0)
					{
						throw(2);
					}
					//检查端口
					//检查获取到的QDloader口是否正常
					if(this->Confirm_Dynamic_Com_Port(iNew_QDLoader_Port, 15) == false)
					{
						throw(2);
					}
				}
			}
			else
			{
				throw(2);
			}
			//正常的
			this->Show_Status(_T("Find QDLoader Port Success(Second)"));
			this->Show_Out(_T("Find QDLoader Port Success(Second)"));

			
		}
		else
		{
		   //正常的
			this->Show_Status(_T("Find QDLoader Port Success(First)"));
			this->Show_Out(_T("Find QDLoader Port Success(First)"));
		}

		//-----------------------

       //保存当前使用QDLoader的COM口
		if (m_eu_BB_Chip == MSM8953) 
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = iNew_QDLoader_Port;
		}
		csData.Format(_T("check port(QDLoader%d) ......"),iNew_QDLoader_Port);
		this->Show_Status(csData);

		//20180913 优化
		int iCH_NUM=1;
		int iQDLoader_Port[5];
		memset(iQDLoader_Port,0,sizeof(int)*5);

		for (iCH_NUM=1;iCH_NUM<=4;iCH_NUM++)
		{
			iQDLoader_Port[iCH_NUM]=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);break;
			iQDLoader_Port[iCH_NUM]=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);break;
			iQDLoader_Port[iCH_NUM]=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);break;
			iQDLoader_Port[iCH_NUM]=this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);break;
		}
		for (iCH_NUM=1;iCH_NUM<=4;iCH_NUM++)
		{
			if(iCH_NUM != m_iClass_Idx)
			{
				if ((iNew_QDLoader_Port == iQDLoader_Port[iCH_NUM])&&(iNew_QDLoader_Port>0))
				{
					break;
				}			
			}		
		}
		
		if (iCH_NUM<=4)//有判断重口情况
		{
			iNew_QDLoader_Port= iQDLoader_Port[m_iClass_Idx];
		}

		switch(m_iClass_Idx)
		{
		case 1:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), iNew_QDLoader_Port);
			break;
		case 2:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), iNew_QDLoader_Port);
			break;
		case 3:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), iNew_QDLoader_Port);
			break;
		case 4:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), iNew_QDLoader_Port);
			break;
		}

// 		//4个QDloader口做个核对，如果有重号的，直接弹出对话框
// 		iQD_1 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_1"), 0);
// 		iQD_2 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_2"), 0);
// 		iQD_3 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_3"), 0);
// 		iQD_4 = this->m_cla_iniQD_Params.ReadInt(_T("FIREHOSE"), _T("QD_4"), 0);
// 		if((iQD_1!=0)&&(iQD_2!=0)&&(iQD_1==iQD_2)
// 			||(iQD_1!=0)&&(iQD_3!=0)&&(iQD_1==iQD_3)
// 			||(iQD_1!=0)&&(iQD_4!=0)&&(iQD_1==iQD_4)
// 			||(iQD_2!=0)&&(iQD_3!=0)&&(iQD_2==iQD_3)
// 			||(iQD_2!=0)&&(iQD_4!=0)&&(iQD_2==iQD_4)
// 			||(iQD_3!=0)&&(iQD_4!=0)&&(iQD_3==iQD_4))
// 		{
// 			CString info;
// 			info.Format(_T("QD_1(%d);QD_2(%d);QD_3(%d);QD_4(%d);"),iQD_1,iQD_2,iQD_3,iQD_4);
// 			this->m_csError_Code.Format(_T("%s"),info);
// 			throw(0);
// 		}


		//返回数据
		*ip_New_QDLoader_Port = iNew_QDLoader_Port;


		//显示
		this->Show_Status(_T("Switch EDL mode completely"));
		this->Show_Out(_T("Switch EDL mode completely"));
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//代码解锁
		::g_cla_Lock_Enter_EDL.Unlock();
		//
		return false;
	}

	this->m_csError_Code.Format(_T(""));

	//代码解锁
	::g_cla_Lock_Enter_EDL.Unlock();
	//
	return true;
}
bool CARM_OP_QCM::Update_USB_QDLoader_Port(int i_Old_Port, int * ip_New_QDLoader_Port)
{
	int irNew_Port[64], iNew_Quan, i, j,index(0);
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录


	try
	{
		iNew_Quan = 0;
		memset(irNew_Port, 0, sizeof(irNew_Port));

		//读取“新生成”的com port口列表
		if ((m_eu_BB_Chip == MSM8953) 
			||(m_eu_BB_Chip == MSM8917)
			||(m_eu_BB_Chip == MDM9X40)
			||(m_eu_BB_Chip == SDX20)
			||(m_eu_BB_Chip == SDX55)
			||(m_eu_BB_Chip == MSM8909)//
			||(m_eu_BB_Chip == MDM9X07)
			||(m_eu_BB_Chip == MDM9X06)
			||(m_eu_BB_Chip == MDM9X55)
			||(m_eu_BB_Chip == MDM9X05)
			||(m_eu_BB_Chip == SM6115)
			|| (m_eu_BB_Chip == QCM6125)
			|| (m_eu_BB_Chip == AG215S)
			|| (m_eu_BB_Chip == SM4350)
			/*||(m_eu_BB_Chip == SDM660)*/) 
		{
			//if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 25) == false)
			if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 60) == false)//add 20180509
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}

		}
		else
		{
			if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 90) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(0);
			}
		}
//20180514 统一确认是否是高通下载口，防止有DM口混入
#if 0
		//
		if(iNew_Quan == 1)
		{
			//唯一的生成口
			*ip_New_QDLoader_Port = irNew_Port[0];
			//
			return true;
		}
		//检查最初的下载口是否在新生成的口之列
		for(i=0; i<iNew_Quan; i++)
		{
			if(irNew_Port[i] == i_Old_Port)
			{
				//最初的下载口未变
				//不改变下载口值
				*ip_New_QDLoader_Port = i_Old_Port;
				//
				return true;
			}
		}
#endif

		//最初的下载口消失了，需要重新确定可能的下载口
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));


		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);


		//核对“新生成的COM口”是不是“8909的QDLoader口”
		for(i=0; i<iNew_Quan; i++)
		{
			for(j=0; j<iQDL_Port_Quan; j++)
			{
				if(irNew_Port[i] == irQDL_Port_List[j])
				{
					//新生成口与某个DM口一致
					//--------------------------------------------------------
					//20180525
					//检查获取到的QDloader口是否正常
					if(this->Confirm_Dynamic_Com_Port(irNew_Port[i], 15) == false)
					{
						this->Show_Status(_T("Find QLoader Port Second"));
						this->Save_Trace_Log(_T("二次找QLoader口"));

						//如果不正常，重新获取
						if(this->Get_New_Dynamic_Com_Port(irNew_Port, &iNew_Quan, 20) == false)//
						{
							this->Show_Status(this->m_csError_Code);
							throw(0);
						}
						//再重复检查下
						//最初的下载口消失了，需要重新确定可能的下载口
						iQDL_Port_Quan = 0;
						memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

						//读PC机存在的所有“QDLoader”口记录
						this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);
						//核对“新生成的COM口”是不是“8909的QDLoader口”
						for(i=0; i<iNew_Quan; i++)
						{
							for(j=0; j<iQDL_Port_Quan; j++)
							{
								if(irNew_Port[i] == irQDL_Port_List[j])
								{
									*ip_New_QDLoader_Port = irNew_Port[i];
									this->Show_Status(_T("Find QLoader Port Second Success"));
								}
							}
						}
					}
					else
					{
						*ip_New_QDLoader_Port = irNew_Port[i];
					}
					//
					//检查当前使用QDLoader口和其他的通道的QDLoader口是否冲突
					for (index=0;index<4;index++)
					{
						if (index == (m_iClass_Idx-1))
						{
							continue;
						}
						if (*ip_New_QDLoader_Port==g_QDL_USE_Port_List[index])
						{
							break;
						}					
					}
					if (index ==4)
					{
						//
						return true;
					}
					else
					{
						continue;
					}				
				}
			}//for(j=0; j<iQDL_Port_Quan; j++
		}//for(i=0; i<iNew_Quan; i++
	}
	catch(...)
	{
		return false;
	}

	this->m_csError_Code.Format(_T("FAIL, Update_USB_QDLoader_Port, No right port!"));
	return false;
}


bool CARM_OP_QCM::Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(int * ip_QDLoader_Port_List, int * ip_Port_Quan)
{
	//从注册表读取“QDLoader下载设备”列表
	/*
	//8909平台
	USB\VID_05C6&PID_9008&REV_0000
	USB\VID_05C6&PID_9008
	Qualcomm HS-USB QDLoader 9008 (COM11)
	*/

	wchar_t wcrUSB_PID_VID[64];//DM口
	CString csrUsb_Dev_List[64], csFriendly_Name;
	int iUsb_Dev_Quan, i, iCnt;
	wchar_t wcrData[128];
	wchar_t * wcpPoint = NULL;

	g_cla_Lock_QDLoader_Port.Lock();
	try
	{
		//不同平台USB的驱动关键词不同
		if (true == m_bPCIE_DL)
		{
			if (SDX55 == this->m_eu_BB_Chip)
			{
				//SDX55
				this->Save_Trace_Log(_T("VID_2C7C&PID_0601&MI_0c"));

				swprintf_s(wcrUSB_PID_VID, _T("VID_2C7C&PID_0601&MI_0c"));//PCIE的QDLoader口
			}
			else
			{
				//SDX24的
				this->Save_Trace_Log(_T("VID_2C7C&PID_0600&MI_0c"));

				swprintf_s(wcrUSB_PID_VID, _T("VID_2C7C&PID_0600&MI_0c"));//PCIE的QDLoader口
			}	
		}
		else
		{
			switch (this->m_eu_BB_Chip)
			{
			case MSM8909:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//8909的QDLoader口
				break;
			case MSM8937:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//8937的QDLoader口
				break;
			case MSM8953:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//8953的QDLoader口
				break;
			case MSM8917:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//8917的QDLoader口
				break;
			case MDM9X07:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//9X07的QDLoader口 ??
				break;
			case MDM9X40:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//9X07的QDLoader口 ??
				break;
			case SDX20:
			case SDX55:
			case AG215S:

				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//SDX20/SDX24/SDX55的QDLoader口 ??
				break;
			case MDM9X06:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//9X06的QDLoader口
				break;
			case SDM660:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//SDM660的QDLoader口
				break;
			case MDM9X55:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//MDM9X55的QDLoader口
				break;
			case MDM9X05:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//MDM9X05的QDLoader口
				break;

			case SDM845:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//SDM845的QDLoader口
				break;

			case SM6115:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//SM6115的QDLoader口
				break;

			case QCM6125:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//QCM6125的QDLoader口
				break;

			case SM4350:
				swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_9008"));//SM4350的QDLoader口
				break;

			default:
				throw(0);
			}

		}


		//
		*ip_Port_Quan = 0;
		iUsb_Dev_Quan = 0;
		iCnt = 0;

		//读PC上可能多个QDLoader下载设备列表
		this->m_cla_GFC.Get_Reg_Usb_Dev_List(wcrUSB_PID_VID, csrUsb_Dev_List, &iUsb_Dev_Quan);

		//
		for(i=0; i<iUsb_Dev_Quan; i++)
		{
			csFriendly_Name.Format(_T(""));
			
			//读取设备的“FriendlyName”（例如：Qualcomm HS-USB QDLoader 9008 (COM11)）
			if(this->m_cla_GFC.Get_Reg_Usb_Dev_Friendly_Name(wcrUSB_PID_VID, csrUsb_Dev_List[i], &csFriendly_Name) == false)
			{
				if((MSM8953 == this->m_eu_BB_Chip)
					||(MSM8909 == this->m_eu_BB_Chip)
					||(MSM8917 == this->m_eu_BB_Chip)
					||(MDM9X40 == this->m_eu_BB_Chip)
					||(SDX20 == this->m_eu_BB_Chip)
					||(SDX55 == this->m_eu_BB_Chip)
					||(MDM9X07 == this->m_eu_BB_Chip)
					||(MDM9X06 == this->m_eu_BB_Chip)
					||(MDM9X55 == this->m_eu_BB_Chip)
					||(MDM9X05 == this->m_eu_BB_Chip)
					||(SDM660 == this->m_eu_BB_Chip)
					||(SDM845 == this->m_eu_BB_Chip)
					||(SM6115 == this->m_eu_BB_Chip)
					|| (QCM6125 == this->m_eu_BB_Chip)
					|| (AG215S == this->m_eu_BB_Chip)
					|| (SM4350 == this->m_eu_BB_Chip)

					)
				{
					//不连续，可能其中没有FriendlyName
					continue;
				}
				else
				{
					::AfxMessageBox(_T("ERROR, Read_Reg_QDLoader_Of_QUD, Fail!"));
					throw(0);
				}
			}


			//数值转换（提取COM口号码）
			csFriendly_Name.MakeUpper();
			csFriendly_Name.Replace(')', '\0');

			swprintf_s(wcrData, _T("%s"), csFriendly_Name);

			wcpPoint = wcsstr(wcrData, _T("(COM"));
			if (NULL != wcpPoint)
			{
				wcpPoint += 4;
				*(ip_QDLoader_Port_List + iCnt) = _wtoi(wcpPoint);
			}
			else
			{
				::AfxMessageBox(_T("COM NULL, Fail!"));
				throw(0);
			}
			


			//累加
			iCnt++;
		}//for(i=0; i<iUsb_Dev_Quan; i++

		//--------------------------------------------------------
		//SDX55 高通端口的场景
		//20210204  遍历完了没成功，继续换个VPI找 
		if ((iUsb_Dev_Quan == i) && (true == m_bPCIE_DL))
		{
			swprintf_s(wcrUSB_PID_VID, _T("VID_05C6&PID_90E2&MI_0c"));//PCIE的QDLoader口
			//
			*ip_Port_Quan = 0;
			iUsb_Dev_Quan = 0;
			//iCnt = 0;

			//读PC上可能多个QDLoader下载设备列表
			this->m_cla_GFC.Get_Reg_Usb_Dev_List(wcrUSB_PID_VID, csrUsb_Dev_List, &iUsb_Dev_Quan);
			//
			for (i = 0; i<iUsb_Dev_Quan; i++)
			{
				csFriendly_Name.Format(_T(""));

				//读取设备的“FriendlyName”（例如：Quectel UDE Port (COM11)）
				if (this->m_cla_GFC.Get_Reg_Usb_Dev_Friendly_Name(wcrUSB_PID_VID, csrUsb_Dev_List[i], &csFriendly_Name) == false)
				{
					if ((MSM8953 == this->m_eu_BB_Chip)
						|| (MSM8909 == this->m_eu_BB_Chip)
						|| (MSM8917 == this->m_eu_BB_Chip)
						|| (MDM9X40 == this->m_eu_BB_Chip)
						|| (SDX20 == this->m_eu_BB_Chip)
						|| (SDX55 == this->m_eu_BB_Chip)
						|| (MDM9X07 == this->m_eu_BB_Chip)
						|| (MDM9X06 == this->m_eu_BB_Chip)
						|| (MDM9X55 == this->m_eu_BB_Chip)
						|| (MDM9X05 == this->m_eu_BB_Chip)
						|| (SDM660 == this->m_eu_BB_Chip)
						|| (SDM845 == this->m_eu_BB_Chip)
						|| (AG215S == this->m_eu_BB_Chip)
						)
					{
						//不连续，可能其中没有FriendlyName
						continue;
					}
					else
					{
						::AfxMessageBox(_T("ERROR, Read_Reg_QDLoader_Of_QUD, Fail!"));
						throw(0);
					}
				}
				//数值转换（提取COM口号码）
				csFriendly_Name.MakeUpper();
				csFriendly_Name.Replace(')', '\0');

				swprintf_s(wcrData, _T("%s"), csFriendly_Name);

				wcpPoint = wcsstr(wcrData, _T("(COM"));
				if (NULL != wcpPoint)
				{
					wcpPoint += 4;
					*(ip_QDLoader_Port_List + iCnt) = _wtoi(wcpPoint);
				}
				else
				{
					::AfxMessageBox(_T("COM NULL, Fail!"));
					throw(0);
				}

				//累加
				iCnt++;
			}//for(i=0; i<iUsb_Dev_Quan; i++
		}
		//--------------------------------------------------------
		//
		*ip_Port_Quan = iCnt;
	}
	catch(...)
	{
		g_cla_Lock_QDLoader_Port.Unlock();
		return false;
	}
	g_cla_Lock_QDLoader_Port.Unlock();
	return true;
}

int CARM_OP_QCM::Execute_MSM8909(void)
{
	CString csData,csReditInfo;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	//
	bool bOpenFlag =false,bFindComFlag =false;

	bool bDL_Flag = true;



	int iQDloadPort=0;

	iQDloadPort = this->m_iCom_Port;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------
		bFindComFlag = this->m_cla_GFC.Confirm_Reg_Com_Port(this->m_iCom_Port);

		if( bFindComFlag== true)
		{
			//COM口已经存在，则说明模块已预先开机，无需特别延迟
			csData.Format(_T("Find Port(%d) Pass"),this->m_iCom_Port);
			this->Show_Out(csData);
		}
		else 
		{
			//COM口还不存在，需要探测，并额外给开机延迟时间
			// check port 是否存在
			//---------------------------------------------------------------------------------
			if (this->m_iCom_Port_Auto_Sec>0)//
			{
				//成功找到端口1
				int iFlag = 0;
				iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,90);
				//成功找到端口1
				if(1 == iFlag)
				{
					bDL_Flag = true;
				}
				//成功找到端口2
				else if(2 == iFlag)
				{
					this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
					this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
					bDL_Flag = true;
				}
				else //两个端口都没找到
				{
					bDL_Flag = false;
				}
			}
			else
			{
				if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,90) == false)
				{
					bDL_Flag = false;
				}
				else
				{
					bDL_Flag = true;
				}
			}
			//---------------------------------------------------------------------------------

			if (false == bDL_Flag)
			{
#if 1
				if(this->m_iOP_Robot == LOAD_AUTO_ROBOT)//全自动机器人
				{
					this->Show_Status(_T("Reload Fixture......"));
					Save_Trace_Log(_T("Reload Fixture......"));
					bool bReload = false;
					bReload = ::TS_LAN_SEND_RELOAD_FIXTURE_LAN_CMD_TO_MC_PC(m_Ts_Num);
					Sleep(2000);
					if (bReload == true)
					{
						//重新搞一遍				
						this->m_iCom_Port = iQDloadPort;

						// check port 是否存在
						//---------------------------------------------------------------------------------
						if (this->m_iCom_Port_Auto_Sec>0)//
						{
							//成功找到端口1
							int iFlag = 0;
							iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
							//成功找到端口1
							if(1 == iFlag)
							{
								bDL_Flag = true;
							}
							//成功找到端口2
							else if(2 == iFlag)
							{
								this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
								this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
								bDL_Flag = true;
							}
							else //两个端口都没找到
							{
								bDL_Flag = false;
							}
						}
						else
						{
							if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
							{
								bDL_Flag = false;
							}
							else
							{
								bDL_Flag = true;
							}
						}
						//---------------------------------------------------------------------------------

					}
					else
					{
						this->m_iError_Code=0x00000071;
						this->m_csError_Code.Format(_T("Reload Fixture Fail"));
						this->Show_Status(this->m_csError_Code);
						//					g_cla_Lock_Port.Lock();
						throw(1);
					}
				}
				else
#endif
				{
					this->Show_Status(this->m_csError_Code);
					this->Show_Out(this->m_csError_Code);
					//				g_cla_Lock_Port.Lock();
					throw(1);
				}
			}	
		}
		//------------------------------

		//刷新COM参数
		this->Load_Com_Port_Params();

		if (1 != m_iMDM9X07_NEW_FLAG)//Sahara
		{
			//------------------------------ 下载FW操作 ------------------------------ 
			if (this->DL_FW_V4_MDM9x07() == false)//沿用9X07的sahara方式
			{
				throw(2);
			}
		}
		else //原先的firehose方式
		{
			//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
			//清空
			iQDL_Port_Quan = 0;
			memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

			//读PC机存在的所有“QDLoader”口记录
			this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

			//核对“当前串口”是不是已经是“8909的QDLoader口”
			for (i = 0; i<iQDL_Port_Quan; i++)
			{
				if (this->m_iCom_Port == irQDL_Port_List[i])
				{
					//“当前串口”已经是“8909的QDLoader口”
					bEDL_Now = true;
					break;//已经是EDL模式
				}
			}//for(j=0; j<iQDL_Port_Quan; j++



			//确定下载用的“QDLoader口”
			if (bEDL_Now == true)
			{
				//已经是EDL模式
				iQDLoader_Port = this->m_iCom_Port;

				csData.Format(_T("QDLoader Port(%d)..."), this->m_iCom_Port);
				this->Show_Out(csData);

				//保存当前使用QDLoader的COM口
				if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
				{
					g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
				}
			}
			else
			{
				//切换到EDL模式
				if (this->Switch_EDL(&iQDLoader_Port) == false)
				{
					this->Show_Out(m_csError_Code);
					this->Show_Status(this->m_csError_Code);
					throw(2);
				}
				//保存当前使用QDLoader的COM口
				if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
				{
					g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
				}

			}


			//显示进度条 10%
			this->Show_Progress(0.1);

			//显示
			csData.Format(_T("EDL port %d"), iQDLoader_Port);
			this->Show_Status(csData);
			this->Show_Out(csData);

			csData.Format(_T("QDLoader %d"), iQDLoader_Port);
			this->Show_COMPORT(csData);
			//
			Sleep(1500);
			//------------------------------



			//------------------------------ EDL下载FW操作 ------------------------------ 
			if (this->DL_FW_V5_MSM8909(iQDLoader_Port) == false)
			{
				throw(3);
			}
			//------------------------------



			//显示进度条 100%
			this->Show_Progress(1.0);
			//下载完成后去除当前使用QDLoader的COM口
			if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx - 1] = 0;
			}


			//PASS信息显示
			if (this->m_bCEFS_DL == true)
			{
				this->Show_Status(_T("FW download success."));
			}
			else
			{
				this->Show_Status(_T("FW upgrade success."));
			}

		}


	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::Send_EDL_Mode_Cmd(void)
{
	PKT_BUFF_V2_S str_Pkt_Cmd;
	RSP_INFO_V2_S str_Rsp_Info;
	CString strData;


	try
	{
		//20180523	
		strData.Format(_T("Send edl mode cmd(Port%d) ....."),this->m_iCom_Port);
		this->Show_Status(strData);
		this->Show_Out(strData);
		this->Save_Trace_Log(strData);

		//打包命令（4b 65 01 00 54 0f 7e）
		str_Pkt_Cmd.ucr_Buff[0] = 0x4B;
		str_Pkt_Cmd.ucr_Buff[1] = 0x65;
		str_Pkt_Cmd.ucr_Buff[2] = 0x01;
		str_Pkt_Cmd.ucr_Buff[3] = 0x00;
		str_Pkt_Cmd.ucr_Buff[4] = 0x54;
		str_Pkt_Cmd.ucr_Buff[5] = 0x0F;
		str_Pkt_Cmd.ucr_Buff[6] = 0x7E;
		str_Pkt_Cmd.ucr_Buff[7] = NULL;
		//
		str_Pkt_Cmd.ul_Data_Length = 7;

		//设定预计回复
		str_Rsp_Info.ucr_Expect_Rsp[0] = 0x4B;
		str_Rsp_Info.ucr_Expect_Rsp[1] = 0x65;
		str_Rsp_Info.ucr_Expect_Rsp[2] = 0x01;
		str_Rsp_Info.ucr_Expect_Rsp[3] = 0x00;
		str_Rsp_Info.ucr_Expect_Rsp[4] = 0x54;
		str_Rsp_Info.ucr_Expect_Rsp[5] = 0x0F;
		str_Rsp_Info.ucr_Expect_Rsp[6] = 0x7E;
		str_Rsp_Info.ucr_Expect_Rsp[7] = NULL;
		//
		str_Rsp_Info.ui_Rsp_Data_Length = 7;
		str_Rsp_Info.ui_Rsp_Pkt_Quan = 1;


		//发送
		if (( m_eu_BB_Chip == MSM8953)
			||( m_eu_BB_Chip == MSM8909)
			||( m_eu_BB_Chip == MSM8917)
			||( m_eu_BB_Chip == SM6115)
			|| (m_eu_BB_Chip == QCM6125)
			|| (SM4350 == this->m_eu_BB_Chip)
			
			)
		{
			if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, 4) == false)
			{
				throw(0);
			}
		} 
		else
		{
			//if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, 4) == false)
			if(this->QUERY_PKT(str_Pkt_Cmd, str_Rsp_Info, 10) == false)
			{
				throw(0);
			}
		}

	}
	catch(...)
	{
		this->m_csError_Code += _T(" [Send_EDL_Mode]");
		this->Show_Out(_T("Send_EDL_Mode Fail"));
		this->Save_Trace_Log(_T("Send_EDL_Mode Fail"));
		return false;
	}

	this->Show_Status(_T("Send_EDL_Mode Pass"));
	this->Show_Out(_T("Send_EDL_Mode Pass"));
	this->Save_Trace_Log(_T("Send_EDL_Mode Pass"));
	return true;
}

bool CARM_OP_QCM::DL_FW_SDM845(int i_QDLoader_Port)
{
	CString  csData;
	try
	{
		//如果m_bDL_Provision 开关打开就下载UFS Provision
		if ( true == m_bDL_Provision)
		{
			//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
			if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I]) == false)
			{
				throw(1);
			}
			//显示进度条 20%
			this->Show_Progress(0.2);
			//
			if(this->QFIL_DL_UFS_Provision(i_QDLoader_Port, this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I]) == false)
			{
				throw(2);
			}
			//显示进度条 80%
			this->Show_Progress(0.4);

			if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
			{
				throw(4);
			}

			//下载完成后延时20秒
			Sleep(20000);

		} 
		//正常下载Firmware
		{
			//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
			if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I]) == false)
			{
				this->Save_Trace_Log(_T("QFIL_DL_Firehose_Programmer FAIL"));
				this->Show_Out(_T("QFIL_DL_Firehose_Programmer FAIL"));
				throw(1);
			}

#ifdef FW_MULTI
#ifndef FW_UPGRADE

			if (PRODU_TYPE_MOB != this->m_iProdu_Type)
			{
				//fh_loader.exe --port=\\.\COM14 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
				if(this->QFIL_DL_FHLoaderErase_Proc_1(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_FHLoaderErase_Proc_1 FAIL"));
					this->Show_Out(_T("QFIL_DL_FHLoaderErase_Proc_1 FAIL"));
					throw(1);
				}
				//显示进度条 30%
				this->Show_Progress(0.3);

				//fh_loader.exe --port=\\.\COM14 --erase=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
				if(this->QFIL_DL_FHLoaderErase_Proc_2(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_FHLoaderErase_Proc_2 FAIL"));
					this->Show_Out(_T("QFIL_DL_FHLoaderErase_Proc_2 FAIL"));

					throw(1);
				}
				//显示进度条 40%
				this->Show_Progress(0.4);

				//fh_loader.exe --port=\\.\COM14 --erase=2 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
				if(this->QFIL_DL_FHLoaderErase_Proc_3(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_FHLoaderErase_Proc_3 FAIL"));
					this->Show_Out(_T("QFIL_DL_FHLoaderErase_Proc_3 FAIL"));
					throw(1);
				}
				//显示进度条 50%
				this->Show_Progress(0.5);

				//fh_loader.exe --port=\\.\COM14 --erase=4 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
				if(this->QFIL_DL_FHLoaderErase_Proc_4(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_FHLoaderErase_Proc_4 FAIL"));
					this->Show_Out(_T("QFIL_DL_FHLoaderErase_Proc_4 FAIL"));

					throw(1);
				}
				//显示进度条 60%
				this->Show_Progress(0.6);
				//fh_loader.exe --port=\\.\COM14 --erase=5 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
				if(this->QFIL_DL_FHLoaderErase_Proc_5(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_FHLoaderErase_Proc_5 FAIL"));
					this->Show_Out(_T("QFIL_DL_FHLoaderErase_Proc_5 FAIL"));
					throw(1);
				}

			}

#endif
#endif

			//显示进度条 20%
			this->Show_Progress(0.7);

			//2. Download the flat build to the eMMC flash of device
			if(this->QFIL_DL_Rawprogram_Ext(i_QDLoader_Port, 
				this->m_strr_Mbn_File_List[RAWPROG_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[RAWPROG4_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[RAWPROG1_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[RAWPROG2_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[RAWPROG3_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[RAWPROG5_SDM845_XML_FILE_I]) == false)
			{
				this->Save_Trace_Log(_T("QFIL_DL_Rawprogram_Ext FAIL"));
				this->Show_Out(_T("QFIL_DL_Rawprogram_Ext FAIL"));

				throw(2);
			}
			//显示进度条 80%
			this->Show_Progress(0.8);

			//3. Apply the patch
			if(this->QFIL_DL_Patch_Ext(i_QDLoader_Port, 
				this->m_strr_Mbn_File_List[PATCH0_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[PATCH1_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[PATCH2_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[PATCH3_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[PATCH4_SDM845_XML_FILE_I],
				this->m_strr_Mbn_File_List[PATCH5_SDM845_XML_FILE_I]) == false)
			{
				this->Save_Trace_Log(_T("QFIL_DL_Patch_Ext FAIL"));
				this->Show_Out(_T("QFIL_DL_Patch_Ext FAIL"));
				throw(3);
			}

			//fh_loader.exe --port=\\.\COM129 --setactivepartition=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
			if(this->QFIL_DL_SetactivePartition(i_QDLoader_Port) == false)
			{
				this->Save_Trace_Log(_T("QFIL_DL_SetactivePartition FAIL"));
				this->Show_Out(_T("QFIL_DL_SetactivePartition FAIL"));

				throw(4);
			}
#if 0
			//
			if (true == this->m_bAT_UseFlag_QDM)//20210222
			{
				//显示进度条 90%
				this->Show_Progress(0.9);

				//20180502
				//4-1. Reset the device if necessary
				//if (this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
				//{
				//	this->Save_Trace_Log(_T("QFIL_DL_Reset_Prepare FAIL"));
				//	this->Show_Out(_T("QFIL_DL_Reset_Prepare FAIL"));

				//	throw(5);
				//}

				//4. Reset the device if necessary
				if (this->QFIL_DL_Reset(i_QDLoader_Port) == false)
				{
					this->Save_Trace_Log(_T("QFIL_DL_Reset FAIL"));
					this->Show_Out(_T("QFIL_DL_Reset FAIL"));
					throw(4);
				}
				//重启等待
				//不断检测是否有AT口出现
				if (false == this->Confirm_Dynamic_Com_Port(this->m_iAT_Port, 60))
				{
					csData.Format(_T("AT Port %d Find Fail"), this->m_iAT_Port);
					this->Show_Status(csData);
					this->Show_Out(csData);
					this->Save_Trace_Log(csData);
					throw(4);
				}
				else
				{
					Sleep(5000);

					csData.Format(_T("AT Port %d Find Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}

				this->m_cla_AT_Com_Port.m_iBaudRate = 115200;
				this->m_cla_AT_Com_Port.m_iPort = m_iAT_Port;
				this->m_cla_AT_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
				this->m_cla_AT_Com_Port.m_dwRTS_CTRL = DTR_CONTROL_ENABLE;

				if (!this->m_cla_AT_Com_Port.Port_Open(500))
				{
					csData.Format(_T("AT Port %d Open Fail"), this->m_iAT_Port);
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
					throw(10);
				}
				else
				{
					//...
				}
				//------------------------------------------------------------------
				//AT+QWSETMAC="xxxxxx"
				if (false == this->Set_QWSETMAC())
				{
					csData.Format(_T("Set_QWSETMAC Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(5);
				}
				else
				{
					csData.Format(_T("Set_QWSETMAC Pass"));
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
				}

				//AT+QWSETMAC?
				if (false == this->Get_QWSETMAC())
				{
					csData.Format(_T("Get_QWSETMAC Fail"));
					this->Show_Status(csData);
					this->Save_Trace_Log(csData);
					this->m_cla_AT_Com_Port.Port_Close();
					this->Show_Out(csData);
					throw(6);
				}
				else
				{
					csData.Format(_T("Get_QWSETMAC Pass"), this->m_iAT_Port);
					this->Save_Trace_Log(csData);
					this->Show_Out(csData);
					this->m_cla_AT_Com_Port.Port_Close();
				}

			}
#endif

		}

	
		//20180507 不需要reset
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}
bool CARM_OP_QCM::DL_FW_SDX660(int i_QDLoader_Port)
{
	try
	{

		if (true == mQCM_SC662NCE_Flag)
		{
			//如果m_bDL_Provision 开关打开就下载UFS Provision
			if ( true == m_bDL_Provision)
			{
				//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
				if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I]) == false)
				{
					throw(1);
				}
				//显示进度条 20%
				this->Show_Progress(0.2);
				//
				if(this->QFIL_DL_UFS_Provision(i_QDLoader_Port, this->m_strr_Mbn_File_List[PROVISION_SDM660_XML_FILE_I]) == false)
	 			{
	 				throw(2);
				}
				//显示进度条 80%
				this->Show_Progress(0.4);

				if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
				{
					throw(4);
				}

				//下载完成后延时20秒
				Sleep(20000);



			} 
			//正常下载Firmware
			{
				//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
				if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I]) == false)
				{
					throw(1);
				}

				//显示进度条 20%
				this->Show_Progress(0.2);

				//2. Download the flat build to the eMMC flash of device
				if(this->QFIL_DL_Rawprogram_Ext(i_QDLoader_Port, 
					this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[RAWPROG1_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[RAWPROG2_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[RAWPROG3_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[RAWPROG4_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[RAWPROG5_SDM660_XML_FILE_I]) == false)
				{
					throw(2);
				}
				//显示进度条 80%
				this->Show_Progress(0.8);

				//3. Apply the patch
				if(this->QFIL_DL_Patch_Ext(i_QDLoader_Port, 
					this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[PATCH1_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[PATCH2_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[PATCH3_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[PATCH4_SDM660_XML_FILE_I],
					this->m_strr_Mbn_File_List[PATCH5_SDM660_XML_FILE_I]) == false)
				{
					throw(3);
				}
			}

		} 
		else
		{
			//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
			if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I]) == false)
			{
				throw(1);
			}

			//显示进度条 20%
			this->Show_Progress(0.2);
  
			//2. Download the flat build to the eMMC flash of device
			if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I]) == false)
			{
				throw(2);
			}
			//显示进度条 80%
			this->Show_Progress(0.8);

			//3. Apply the patch
			if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I]) == false)
			{
				throw(3);
			}
		}
	
		//20180507 不需要reset
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}
bool CARM_OP_QCM::DL_FW_V5_MSM8909(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I]) == false)
		{
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I]) == false)
		{
			throw(3);
		}
//20180507 不需要reset
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::QFIL_DL_Firehose_Programmer(int i_QDLoader_Port, const MBN_FILE_S str_Firehose_File)
{
	//使用“QSaharaServer.exe”下载“Firehose”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//延时20,秒 20170608


	try
	{
		//显示
		this->Show_Status(_T("Download firehose file ......"));
		this->Save_Trace_Log(_T("Download firehose file ......"));
		this->Show_Out(_T("Download firehose file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Firehose, Create pipe fail!"));
			this->m_iError_Code  = DL_Firehose_fail1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + str_Firehose_File.cs_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 1024);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 1024);



		//------------------------------ 打包dos指令 ------------------------------ 
// 		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\QSaharaServer.exe -p \\\\.\\COM%d -s 13:\"%s\""),
// 			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Firehose_File.cs_Path);
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\QSaharaServer.exe -p \\\\.\\COM%d -s 13:\"%s\""),
			'/',this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Firehose_File.cs_Path);
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Firehose, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 1024);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 512, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;
				

				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Firehose "));
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Firehose error!"));
				this->m_iError_Code  = DL_Firehose_fail2;
				throw(3);
			}


			//检查是否pass
			if((wcsstr(csTotal_Info, _T("file transferred successfully")) != NULL) &&
				(wcsstr(csTotal_Info, _T("sahara protocol completed")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Firehose, Time out!"));
				this->m_iError_Code  = DL_Firehose_fail3;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟3秒
		for(iTemp=1; iTemp<=3; iTemp++)
		{
			csData.Format(_T("DL-Firehose, wait for %d seconds ......"), (4 - iTemp));
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);

			//
			Sleep(1200);

			//显示进度条
			this->Show_Progress( (0.1 + 0.1 * (iTemp / 3.0)) );
		}
		
	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::QFIL_DL_Rawprogram(int i_QDLoader_Port, const MBN_FILE_S str_Rawprogram_File)
{
	//使用“fh_loader.exe”下载“rawprogram_unsparse.xml”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 10;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download rawprogram file ......"));
		this->Save_Trace_Log(_T("Download rawprogram file ......"));
		this->Show_Out(_T("Download rawprogram file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create pipe fail!"));
			this->m_iError_Code  = DL_Rawprogram_fail3;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);

		if (NAND == this->m_eu_Memory_Type)
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=rawprogram_unsparse.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			//				
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path);

				
			if (SDX55 == this->m_eu_BB_Chip)
			{
				iTimeout = 360;//
			}
			else
			{
				//...
			}
		} 
// 		else if (UFS == this->m_eu_Memory_Type)
// 		{
// 			swprintf(wcpCmd, _T("cmd.exe cd \"%s\" %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=\"%s\" --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS"),
// 				this->m_csCurr_Exe_Path, '/', m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path);
// 
// 		}
		else //默认EMMC
		{
			swprintf(wcpCmd, _T("cmd.exe cd \"%s\" %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=\"%s\" --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=eMMC"),
				this->m_csCurr_Exe_Path, '/', m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path);

		}
		 
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

//				csData.Replace(_T('\r'), _T(' '));
//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//提取重要的“进度百分比信息”
				//提取第一个值(0)
				wcpEach = wcstok(wcpData, _T("\r\n"));
				//
				while(wcpEach != NULL)
				{
					//是否有“percent 开始”关键词
					wcpPercent = wcsstr(wcpEach, _T("{percent files transferred"));
					//
					if(wcpPercent != NULL)
					{
						//备份单条数据
						csEach.Format(_T("%s"), wcpPercent);

						//提取百分比数据
						wcpPercent += 26;

						//是否有“percent 结束”关键词
						if(wcsstr(wcpPercent, _T("%")) != NULL)
						{
							//发现百分比数据的“结尾”
							csTemp.Format(_T("%s"), wcpPercent);
							csTemp.Replace('%', '\0');//去掉结尾

							//字符转数字
							dNew_Percent = _wtof(csTemp);

							//刷新百分比数据
							if(dNew_Percent > dCurr_Percent)
							{
								//赋值新百分比数据
								dCurr_Percent = dNew_Percent;


// 								//显示“单条信息数据”
// 								csEach.Replace('{', ' ');//去掉不想显示的字符
// 								csEach.Replace('}', ' ');//去掉不想显示的字符
// 								csEach.Replace('\r', ' ');//去掉不想显示的字符
// 								csEach.Replace('\n', ' ');//去掉不想显示的字符
// 								csTemp.Format(_T("DL-Rawprogram( %.2f%% ), %s"), dCurr_Percent, csEach);

								csTemp.Format(_T("DL-Rawprogram( %.2f%% )"), dCurr_Percent);
								this->Show_Status(csTemp);
								//this->Save_Trace_Log(csTemp);
								//无延迟，则看不出显示信息的变化
								Sleep(20);


								//显示进度条
								this->Show_Progress( (0.2 + 0.6 * (dCurr_Percent / 100.0)) );
							}
						}//if(wcsstr(wcpPercent, _T("%")) != NULL
					}//if(wcpPercent != NULL


					//提取下一个值
					wcpEach = wcstok(NULL, _T("\r\n"));
				}//while(wcpEach != NULL



				//汇总数据
				if((dCurr_Percent > 98.0)
					|| (dCurr_Percent<1.0))//20201106
				{
					csTotal_Info += csData;
				}
				else
				{
					csTotal_Info.Format(_T("%s"), csData);
				}


				//有数据的话就重新开始计时
				time(&t_Start);
			}//if(ulActual_Read > 0


			//检查是否有错误报出
			if ((SDX20 == this->m_eu_BB_Chip)
				|| (MDM9X05 == this->m_eu_BB_Chip)
				|| (SDX55 == this->m_eu_BB_Chip))
			{
				//ERROR: [1318] error : 9
				if((wcsstr(csTotal_Info, _T("error: [1318]")) != NULL)
// 					||(wcsstr(csTotal_Info, _T("error: [348]")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
// 					||(wcsstr(csTotal_Info, _T("error: [849]")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
 					||(wcsstr(csTotal_Info, _T("error: [1320]")) != NULL)//20200602 软件已经确认
 					||(wcsstr(csTotal_Info, _T("error: set bootable fail")) != NULL)//20200602 软件已经确认
// 
// 					||((wcsstr(csTotal_Info, _T("devprg_storage_read")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
// 						&&(wcsstr(csTotal_Info, _T("error:")) != NULL))
					
					||((wcsstr(csTotal_Info, _T("erasing")) != NULL)
						&&(wcsstr(csTotal_Info, _T("error:")) != NULL))
					||((wcsstr(csTotal_Info, _T("erase")) != NULL)
						&&(wcsstr(csTotal_Info, _T("error:")) != NULL))
						)					
				{
					this->Save_Trace_Log(csTotal_Info);
				}
				else
				{
					if(wcsstr(csTotal_Info, _T("error:")) != NULL)
					{	
						this->Save_Trace_Log(csTotal_Info);

						this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
						this->m_iError_Code  = DL_Rawprogram_fail1;
						throw(3);
					}
				}

			}
			else
			{
				if(wcsstr(csTotal_Info, _T("error:")) != NULL)
				{
					this->Save_Trace_Log(csTotal_Info);

					this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
					this->m_iError_Code  = DL_Rawprogram_fail1;
					throw(3);
				}
			}


			//检查是否pass
			//20200711 EG91机型下载中发现有部分没有100%的场景
			if(wcsstr(csTotal_Info, _T("all finished successfully")) != NULL) 
				//||
				//(wcsstr(csTotal_Info, _T("percent files transferred 100.00")) != NULL))
			{
//				::AfxMessageBox(csTotal_Info);

				this->Save_Trace_Log(csTotal_Info);

				bSuccess_Flag = true;//pass
				break;//退出while
			}
			//兼容AG550Q的出现进度只有96%，但有all finished successfully 信息的场景
			else if (SDX55 == this->m_eu_BB_Chip)
			{
				if(wcsstr(csTotal_Info, _T("all finished successfully")) != NULL)
				{
					this->Save_Trace_Log(csTotal_Info);

					bSuccess_Flag = true;//pass
					break;//退出while
				}
			}



			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Time out!"));
				this->Save_Trace_Log(_T("FAIL, DL_Rawprogram, Time out!"));
				this->m_iError_Code  = DL_Rawprogram_fail2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for(iTemp=1; iTemp>=0; iTemp--)
		{
			csData.Format(_T("DL-Rawprogram, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			//this->Save_Trace_Log(csData);
			//
			Sleep(800);
		}
		
	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::QFIL_DL_Patch(int i_QDLoader_Port, const MBN_FILE_S str_Patch_File)
{
	//使用“fh_loader.exe”下载“patch0.xml”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	//int iTimeout = 10; //20170527
	int iTimeout = 60; //20180226


	try
	{
		//显示
		this->Show_Status(_T("Download patch file ......"));
		this->Save_Trace_Log(_T("Download patch file ......"));
		this->Show_Out(_T("Download patch file ..."));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Patch, Create pipe fail!"));
			this->m_iError_Code  = DL_Patch_fail1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		if (NAND == this->m_eu_Memory_Type)
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path);

		}
// 		else if (UFS == this->m_eu_Memory_Type)
// 		{
// 			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
// 			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS"),
// 				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path);
// 
// 		}
		else
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			swprintf(wcpCmd, _T("cmd.exe cd %s %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=eMMC"),
				this->m_csCurr_Exe_Path, '/',  m_iClass_Idx,i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path);

		}
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Patch, Create process fail!"));
			this->m_iError_Code  = DL_Patch_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
//				csData.Replace(_T('\r'), _T(' '));
//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;
				

				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Patch "));
				//20180425
				//this->Save_Trace_Log(wcpData);

			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{

				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(_T("FAIL, DL_Patch error!"));
				this->m_iError_Code  = DL_Patch_fail4;
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				this->Save_Trace_Log( _T("{all finished successfully}"));

				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->Save_Trace_Log( _T("FAIL, DL_Patch, Time out!"));

				this->m_csError_Code.Format(_T("FAIL, DL_Patch, Time out!"));
				this->m_iError_Code  = DL_Patch_fail3;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for(iTemp=1; iTemp>=0; iTemp--)
		{
			csData.Format(_T("DL-Patch, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(500);
		}
		
	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

//fh_loader.exe --port=\\.\COM129 --setactivepartition=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 

bool CARM_OP_QCM::QFIL_DL_SetactivePartition(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“SetactivePartition”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download SetactivePartition Prepare......"));
		this->Save_Trace_Log(_T("Download SetactivePartition Prepare......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, QFIL_DL_SetactivePartition, Create pipe fail!"));
			this->m_iError_Code  = DL_Reset_fail1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------  
		//fh_loader.exe --port=\\.\COM129 --setactivepartition=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --setactivepartition=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port);
	
		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, QFIL_DL_SetactivePartition, Create process fail!"));
			this->m_iError_Code  = DL_Reset_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("QFIL_DL_SetactivePartition "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, QFIL_DL_SetactivePartition error!"));
				this->m_iError_Code  = DL_Reset_fail3;
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, QFIL_DL_SetactivePartition, Time out!"));
				this->m_iError_Code  = DL_Reset_fail4;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}


//20180502
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM59 --setactivepartition=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
bool CARM_OP_QCM::QFIL_DL_Reset_Prepare(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“Boot partition setting”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download reset Prepare......"));
		this->Save_Trace_Log(_T("Download reset Prepare......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Reset, Create pipe fail!"));
			this->m_iError_Code  = DL_Reset_fail1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------  --setactivepartition=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 

		if (NAND == this->m_eu_Memory_Type)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d --setactivepartition=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, i_QDLoader_Port);
		}
 		else if (UFS == this->m_eu_Memory_Type)
 		{
 			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d  --setactivepartition=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
 				'/', this->m_csCurr_Exe_Path, i_QDLoader_Port);
 
 		}
		else
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d --setactivepartition=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc"),
				'/', this->m_csCurr_Exe_Path, i_QDLoader_Port);
		}

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Reset, Create process fail!"));
			this->m_iError_Code  = DL_Reset_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Reset "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Reset Prepare error!"));
				this->m_iError_Code  = DL_Reset_fail3;
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Reset Prepare, Time out!"));
				this->m_iError_Code  = DL_Reset_fail4;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::QFIL_DL_Reset(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“Boot partition setting”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download reset ......"));
		this->Save_Trace_Log(_T("Download reset ......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Reset, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------  --reset --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
//		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=eMMC --setactivepartition=0"),
//			'/', this->m_csCurr_Exe_Path, i_QDLoader_Port);

		if (NAND == this->m_eu_Memory_Type)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --reset --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);
		}
 		else if (UFS == this->m_eu_Memory_Type)
 		{
 			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --reset --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
 				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);
 
 		}
		else
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --reset --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);
		}



		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Reset, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
//				csData.Replace(_T('\r'), _T(' '));
//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;
				

				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Reset "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Reset error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Reset, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		
	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::QFIL_DL_Getstorageinfo(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“getstorageinfo”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download Getstorageinfo ......"));
		this->Save_Trace_Log(_T("Download Getstorageinfo ......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Getstorageinfo, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------  
		//fh_loader.exe --port = \\.\COM7 --getstorageinfo = 0 --noprompt --showpercentagecomplete --zlpawarehost = 1 --memoryname = nand

		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --getstorageinfo = 0 --noprompt --showpercentagecomplete --zlpawarehost = 1 --memoryname = nand"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port);
		
	

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Getstorageinfo, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Getstorageinfo "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Getstorageinfo error!"));
				throw(3);
			}


			//检查是否pass
			if (wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Getstorageinfo, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}



bool CARM_OP_QCM::LOAD_FW_FILE_V4(const wchar_t * wcp_FW_File_Path)
{
	//MSM8937
	//判定、加载8937的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .mbn 文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//挑出“prog_emmc_firehose_8937_ddr.mbn”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_8937_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8937_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8937_MBN_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_8937_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8937_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8937_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_8937_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8937_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8937_XML_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
					//8937工厂版有fs_image.tar.gz.mbn.img
						this->m_strr_Mbn_File_List[FS_IMAGE_8937_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8937_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8937_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						//8937工厂版有zero.bin
						this->m_strr_Mbn_File_List[ZERO_8937_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8937_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8937_BIN_FILE_I].b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_8937_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_8937_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_8937_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_V5(const wchar_t * wcp_FW_File_Path)
{
	//MSM8953
	//判定、加载8953的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .mbn 文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//挑出“prog_emmc_firehose_8953_ddr.mbn”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_8953_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8953_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8953_MBN_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_8953_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8953_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8953_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_8953_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8953_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8953_XML_FILE_I].b_Enable_DL = true;
					}
				}

#if  1
				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_8953_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8953_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8953_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_8953_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8953_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8953_BIN_FILE_I].b_Enable_DL = true;
					}
				}
#endif

				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_8953_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_8953_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_8953_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}


int CARM_OP_QCM::Execute_MSM8953(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	bool bDL_Flag = true;


	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8953的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8953的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
	
		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V5_MSM8953( iQDLoader_Port ) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);

		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}


		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V5_MSM8953(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_8953_MBN_FILE_I]) == false)
		{
			//第一步是必须的
		 	throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_8953_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_8953_XML_FILE_I]) == false)
		{
			throw(3);
		}
//20180507 del
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
       //下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}

int CARM_OP_QCM::Execute_MSM8937(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	bool bDL_Flag = true;


	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}

		//刷新COM参数
		this->Load_Com_Port_Params();

		



		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8937的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8937的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;
		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);

		this->Save_Trace_Log(csData);

		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V5_MSM8937( iQDLoader_Port ) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);


		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V5_MSM8937(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_8937_MBN_FILE_I]) == false)
		{
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_8937_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_8937_XML_FILE_I]) == false)
		{
			throw(3);
		}
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}

void CARM_OP_QCM::Save_Trace_Log(const wchar_t * wcp_Trace_Log)
{
#ifdef FW_MULTI
	if (1 == m_iAutoSaveLog)
	{
		::SendMessage(this->m_hWnd_View, WM_TRACE_LOG_MSG, (WPARAM)wcp_Trace_Log, (LPARAM)this->m_iClass_Idx);
	} 
	else
	{
		//...
	}
#else
	::SendMessage(this->m_hWnd_View, WM_TRACE_LOG_MSG, (WPARAM)wcp_Trace_Log, (LPARAM)this->m_iClass_Idx);

#endif	
	
}


bool CARM_OP_QCM::LOAD_FW_FILE_V7(const wchar_t * wcp_FW_File_Path)
{
	//MSM8917
	//判定、加载8917的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .mbn 文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//挑出“prog_emmc_firehose_8917_ddr.mbn”文件prog_emmc_firehose_8917_ddr
					if(wcsstr(cs_FW_Name, _T("PROG_EMMC_FIREHOSE_8917_DDR")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_8917_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8917_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8917_MBN_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_8917_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8917_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8917_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_8917_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8917_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8917_XML_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_8917_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8917_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8917_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_8917_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8917_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8917_BIN_FILE_I].b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_8917_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_8917_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_8917_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}
int CARM_OP_QCM::Execute_MSM8917(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”
	bool bDL_Flag = true;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();
		

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8917的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8917的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++

		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			g_QDL_USE_Port_List[g_QDL_USE_Port_num%10] = iQDLoader_Port;
			g_QDL_USE_Port_num++;
		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);

		//
		Sleep(1500);
		//------------------------------
		
		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V7_MSM8917( iQDLoader_Port ) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);
		//下载完成后去除当前使用QDLoader的COM口
		for(int i=0;i<10;i++)
		{
			if (g_QDL_USE_Port_List[i] == iQDLoader_Port)
			{
				g_QDL_USE_Port_List[i] =0;
				if (g_QDL_USE_Port_num>0)
				{
					g_QDL_USE_Port_num--;
				}

			}
		}

		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		for(int i=0;i<10;i++)
		{
			if (g_QDL_USE_Port_List[i] == iQDLoader_Port)
			{
				g_QDL_USE_Port_List[i] =0;
				if (g_QDL_USE_Port_num>0)
				{
					g_QDL_USE_Port_num--;
				}

			}
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}
bool CARM_OP_QCM::DL_FW_V7_MSM8917(int i_QDLoader_Port)
{
	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_8917_MBN_FILE_I]) == false)
		{
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);
		Sleep(5000);

		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_8917_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);
		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_8917_XML_FILE_I]) == false)
		{
			throw(3);
		}
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::DL_FW_V2_MSM9X07(int i_QDLoader_Port)
{
	try
	{
		if (false == m_bPCIE_DL)//USB场景下
		{
			//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
			if (this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I]) == false)
			{
				this->m_iError_Code = 0x00000073;
				throw(1);
			}

			//显示进度条 20%
			this->Show_Progress(0.2);
		}

#ifdef FW_MULTI
#ifndef FW_UPGRADE

		if (PRODU_TYPE_MOB != this->m_iProdu_Type)
		{
			//全擦后下载--
			// 		if (MDM9X07 == this->m_eu_BB_Chip)
			// 		{	
			// 			//fh_loader.exe --port=\\.\COM66 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			// 			if(this->QFIL_DL_FHLoaderErase_CMD(i_QDLoader_Port) == false)
			// 			{
			// 				throw(1);
			// 			}
			// 		}

			if (MDM9X07 == this->m_eu_BB_Chip)
			{					
				//尝试全擦FHLoaderErase.xml
				if(this->QFIL_DL_FHLoaderErase(i_QDLoader_Port) == false)
				{
					throw(1);
				}
				this->Show_Progress(0.3);

				if(this->QFIL_DL_FHLoaderErase_Proc(i_QDLoader_Port) == false)
				{
					throw(1);
				}
				this->Show_Progress(0.4);
			}
			else  if (SDX55 == this->m_eu_BB_Chip)
			{
				//fh_loader.exe --port = \\.\COM7 --getstorageinfo = 0 --noprompt --showpercentagecomplete --zlpawarehost = 1 --memoryname = nand
				//if (this->QFIL_DL_Getstorageinfo(i_QDLoader_Port) == false)
				//{
				//	throw(1);
				//}
				//this->Show_Progress(0.2);
				//尝试全擦FHLoaderErase.xml
				if (this->QFIL_DL_FHLoaderErase(i_QDLoader_Port) == false)
				{
					throw(1);
				}
				this->Show_Progress(0.3);

				if (this->QFIL_DL_FHLoaderErase_Proc(i_QDLoader_Port) == false)
				{
					throw(1);
				}
				this->Show_Progress(0.4);
			}
		}
		 
#endif
#endif

		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_9X07_XML_FILE_I]) == false)
		{
			this->m_iError_Code=0x00000074;
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);

		//20180716
		if ((SDX20 == this->m_eu_BB_Chip)
			||(SDX55 == this->m_eu_BB_Chip))
		{
			//3. Apply the patch
			if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_9X07_XML_FILE_I]) == false)
			{
				throw(3);
			}
			//4-1. Reset the device if necessary
// 			if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
// 			{
// 				throw(5);
// 			}
		}

		//显示进度条 90%
		this->Show_Progress(0.9);

		if((TRUE == m_bFirehose_Reset_after_DL)
			|| (true  ==  this->m_bAT_UseFlag))//20200904  EM120/EM160 7个OC需要软重启后读EID 
		{
			//4. Reset the device if necessary
			if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
			{
				throw(4);
			}
		}

		//
	}
	catch(...)
	{
		return false;
	}

	return true;
}

int CARM_OP_QCM::DL_FW_V4_MDM9x05_Firehose(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”
	CString csCOM;

	int iQDloadPort=0;

	bool bDL_Flag = true;
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		iQDloadPort = this->m_iCom_Port;

		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}
		//---------------------------------------------------------------------------------

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}

		//COM口刚生成后，模块初始化未完成，模块无法下载
		//代码锁定
		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------

		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));


		this->Show_Status(_T("Check QDLoader Port..."));
		this->Show_Out(_T("Check QDLoader Port..."));
		Save_Trace_Log(_T("Check QDLoader Port..."));


		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“9x05的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“9x07的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++
		//g_cla_Lock_Port.Unlock();
		m_iCom_Old_Port =0;

		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			csCOM.Format(_T("QDLoader %d"), this->m_iCom_Port);
			Save_Trace_Log(csCOM);
			this->Show_Status(csCOM);
			this->Show_Out(csCOM);


			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
		}
		else
		{
			csCOM.Format(_T("DM %d"), this->m_iCom_Port);
			Show_COMPORT(csCOM);
			Save_Trace_Log(csCOM);

			this->Show_Status(csCOM);
			this->Show_Out(csCOM);
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				//				g_cla_Lock_Port.Unlock();
				this->m_iError_Code=0x00000072;
				throw(2);
			}
			else
			{
				//虽找到后Qloader口可能还没准备好 20180508
				Sleep(3000);
			}
			//刷新端口的显示

			//csCOM.Format(_T("Start %d"), iQDLoader_Port);
			csCOM.Format(_T("QDLoader %d"), iQDLoader_Port);
			Show_COMPORT(csCOM);
			m_iCom_Old_Port=m_iCom_Port;
			Save_Trace_Log(csCOM);
		}

		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);
		Save_Trace_Log(csData);
		//		g_cla_Lock_Port.Unlock();

		//------------------------------

		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V2_MSM9X07( iQDLoader_Port ) == false)
		{
			throw(3);
		}

		if (TRUE == m_bFirehose_Reset_after_DL)
		{
			//重启成功后再向后延迟30秒
			this->Show_Status(_T("Reset..."));
			Sleep(30000);
		}
		
		//-------------

		//显示进度条 100%
		this->Show_Progress(1.0);

		//保存当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
		}
		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
		}

		//刷新端口的显示
		if (m_iCom_Old_Port != 0)
		{
			csCOM.Format(_T("%d"), m_iCom_Old_Port);
			Show_COMPORT(csCOM);
		}

	}
	catch(...)
	{

		//对应的置零
		switch(m_iClass_Idx)
		{
		case 1:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
			break;
		case 2:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
			break;
		case 3:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
			break;
		case 4:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
			break;
		}
		return RTN_FAIL;
	}

	//对应的置零
	//下载完成后去除当前使用QDLoader的COM口
	// 	if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
	// 	{
	// 		g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
	// 	}
	switch(m_iClass_Idx)
	{
	case 1:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
		break;
	case 2:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
		break;
	case 3:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
		break;
	case 4:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
		break;
	}
	return RTN_SUCCESS;
}

int CARM_OP_QCM::DL_FW_V4_MDM9x06_Firehose(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”
	CString csCOM;

	int iQDloadPort=0;

	bool bDL_Flag = true;
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		iQDloadPort = this->m_iCom_Port;

		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}
		//---------------------------------------------------------------------------------

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------

		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));


		this->Show_Status(_T("Check QDLoader Port..."));
		this->Show_Out(_T("Check QDLoader Port..."));
		Save_Trace_Log(_T("Check QDLoader Port..."));


		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“9x07的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“9x07的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++
		//g_cla_Lock_Port.Unlock();
		m_iCom_Old_Port =0;

		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			csCOM.Format(_T("QDLoader %d"), this->m_iCom_Port);
			Save_Trace_Log(csCOM);
			this->Show_Status(csCOM);
			this->Show_Out(csCOM);


			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}

		}
		else
		{
			csCOM.Format(_T("DM %d"), this->m_iCom_Port);
			Show_COMPORT(csCOM);
			Save_Trace_Log(csCOM);

			this->Show_Status(csCOM);
			this->Show_Out(csCOM);
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				//				g_cla_Lock_Port.Unlock();
				this->m_iError_Code=0x00000072;
				throw(2);
			}
			else
			{
				//虽找到后Qloader口可能还没准备好 20180508
				Sleep(3000);
			}
			//刷新端口的显示

			//csCOM.Format(_T("Start %d"), iQDLoader_Port);
			csCOM.Format(_T("QDLoader %d"), iQDLoader_Port);
			Show_COMPORT(csCOM);
			m_iCom_Old_Port=m_iCom_Port;
			Save_Trace_Log(csCOM);
		}

		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);
		Save_Trace_Log(csData);
		//		g_cla_Lock_Port.Unlock();

		//------------------------------

		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V2_MSM9X07( iQDLoader_Port ) == false)
		{
			throw(3);
		}
		if (TRUE == m_bFirehose_Reset_after_DL)
		{
			//重启成功后再向后延迟30秒
			this->Show_Status(_T("Reset..."));
			Sleep(30000);
		}
		//-------------


		//-----------------
#if 0
		if(this->m_iOP_Robot == LOAD_AUTO_ROBOT)//全自动机器人
		{
			//下载完重启
			//向总控PC发送DC重启指令
			bool bDC_Reset =false;
			csData.Format(_T("Reset......%d OFF"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);


			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("OFF") );
			Sleep(5000);
			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("ON") );

			csData.Format(_T("Reset......%d ON"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);
			Sleep(8000);

			// 			if (this->m_DM_Port >0)
			// 			{
			// 				if(this->Confirm_Dynamic_Com_Port(this->m_DM_Port, 30) == false)
			// 				{
			// 					this->m_csError_Code.Format(_T("Reset Fail(DM(%d) Find Fail)"),this->m_DM_Port);
			// 					this->Show_Status(this->m_csError_Code);
			// 					throw(1);
			// 				}
			// 			}
			this->Show_Status(_T("Reset Suecess"));
			Save_Trace_Log(_T("Reset Suecess"));

		}
#endif

		//显示进度条 100%
		this->Show_Progress(1.0);

		//保存当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
		}
		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
		}

		//刷新端口的显示
		if (m_iCom_Old_Port != 0)
		{
			csCOM.Format(_T("%d"), m_iCom_Old_Port);
			Show_COMPORT(csCOM);
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		// 		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		// 		{
		// 			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		// 		}

		//对应的置零
		switch(m_iClass_Idx)
		{
		case 1:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
			break;
		case 2:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
			break;
		case 3:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
			break;
		case 4:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
			break;
		}
		return RTN_FAIL;
	}

	//对应的置零
	//下载完成后去除当前使用QDLoader的COM口
	// 	if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
	// 	{
	// 		g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
	// 	}
	switch(m_iClass_Idx)
	{
	case 1:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
		break;
	case 2:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
		break;
	case 3:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
		break;
	case 4:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
		break;
	}
	return RTN_SUCCESS;
}
bool CARM_OP_QCM::LOAD_FW_FILE_Sdm845(const wchar_t * wcp_FW_File_Path)
{
	//Sdm845---SA800UWFPA
	//判定、加载Sdm845的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;

	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .ELF 文件
				if(wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//挑出“prog_emmc_ufs_firehose_Sdm845_ddr.elf”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse0.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_UNSPARSE0")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SDM845_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//
					//
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM1")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG1_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG1_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG1_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM2")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG2_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG2_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG2_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM3")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG3_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG3_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG3_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//rawprogram_unsparse4.xml
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_UNSPARSE4")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG4_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG4_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG4_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM5")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG5_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG5_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG5_SDM845_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch1.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH1")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH1_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH1_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH1_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch2.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH2")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH2_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH2_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH2_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch3.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH3")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH3_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH3_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH3_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch4.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH4")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH4_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH4_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH4_SDM845_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch5.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH5")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH5_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH5_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH5_SDM845_XML_FILE_I].b_Enable_DL = true;
					}

					//provision_samsung.xml
					//provision_toshiba.xml
					//provision_hynix.xml
					if (wcsstr(cs_FW_Name, _T("PROVISION_")) != NULL)
					{
						switch (m_iProvision_Type)
						{
							case PROVISION_SAMSUNG:
							{
								if (wcsstr(cs_FW_Name, _T("PROVISION_SAMSUNG")) != NULL)
								{
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].b_Enable_DL = true;

									this->Show_Out(_T("provision_samsung.xml"));
								}
							}						
							break;

							case PROVISION_TOSHIBA:
							{
								if (wcsstr(cs_FW_Name, _T("PROVISION_TOSHIBA")) != NULL)
								{
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].b_Enable_DL = true;

									this->Show_Out(_T("provision_toshiba.xml"));
								}
							}
							break;

							case PROVISION_HYNIX:
							{
								if (wcsstr(cs_FW_Name, _T("PROVISION_HYNIX")) != NULL)
								{
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].b_Enable_DL = true;

									this->Show_Out(_T("provision_hynix.xml"));
								}
							}
							break;
							default:
							{
								if (wcsstr(cs_FW_Name, _T("PROVISION_SAMSUNG")) != NULL)
								{
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
									this->m_strr_Mbn_File_List[PROVISION_SDM845_XML_FILE_I].b_Enable_DL = true;

									this->Show_Out(_T("--->provision_samsung.xml"));
								}
							}
							break;

						}
					}
					
					


					

				}


				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM845_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM845_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM845_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_SDM845_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SDM845_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SDM845_BIN_FILE_I].b_Enable_DL = true;
					}
				}	
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_SDM845_ELF_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_SDM845_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_SDM845_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_HONEYWELL(const wchar_t * wcp_FW_File_Path)
{
	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int iHex_Quan = 0;
	int j;

	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Hex_E.cs_Name.Format(_T("hex_e"));
		this->m_str_Hex_E.cs_Path.Format(_T(""));


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get HEX file directory fail!"));
			throw(0);
		}

		//把Hex文件放入临时BUFF中t
		cs_FW_Path.Format(_T("%s"), wcp_FW_File_Path); 
		cs_FW_Name = cs_FW_Path.Right(cs_FW_Path.GetLength()-cs_FW_Path.ReverseFind(_T('\\'))-1);
		this->m_str_Hex_E.cs_Name.Format(_T("%s"), cs_FW_Name);
		this->m_str_Hex_E.cs_Path.Format(_T("%s"), wcp_FW_File_Path);


// 		//寻找文件开始
// 		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);
// 
// 		b_Found = cla_Finder.FindFile(cs_Finder_Dir);
// 
// 		while(b_Found) 
// 		{
// 			b_Found = cla_Finder.FindNextFile();
// 
// 			if(cla_Finder.IsDots())
// 			{
// 				continue;//找到的是当前目录或上级目录则跳过
// 			}
// 
// 			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
// 			{
// 				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
// 
// 				cs_FW_Name.MakeUpper();
// 
// 				//判定文件类型，载入.hex文件
// 				if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL)
// 				{
// 					//去掉文件类型显示
// 					cs_FW_Name.Replace(_T(".HEX"), _T("\0"));
// 					//把Hex文件放入临时BUFF中
// 					this->m_str_Hex_E.cs_Name.Format(_T("%s"), cs_FW_Name);
// 					this->m_str_Hex_E.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
// 					
// 				}//if(wcsstr(cs_FW_Name, _T(".HEX")) != NULL
// 			}
// 		}//while(b_Found
// 
// 		//关闭find
// 		cla_Finder.Close();

		//生成eraseAndFlash.jlink 文件
// 		device EFR32FG12PXXXF1024
// 		usb 0
// 		si 1
// 		speed 9600
// 		erase
// 
// 		sleep 400
// 
// 		loadfile "D:\24_FW_2\Honeywell-A4\A4_Test\A4_Test\a4cell_flash_script\A4CellMfg_0_1.hex"
// 		sleep 100
// 		r
// 		g
//		q

		CStdioFile Cmd_File;
		CString   strCmd_file_name,csData;
		unsigned long ul_File_Size;

		strCmd_file_name.Format(_T("%s\\Honeywell_A4\\%d\\eraseAndFlash.jlink"),this->m_csCurr_Exe_Path,m_iClass_Idx);

		if(this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);  
		
			::DeleteFile(strCmd_file_name); 

			Sleep(2000);
		}

		if(Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			

			Cmd_File.SeekToEnd();

			csData.Format(_T("device EFR32FG12PXXXF1024\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("usb 0\n"));
			Cmd_File.WriteString(csData);
	
			csData.Format(_T("si 1\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("speed 9600\n"));
			Cmd_File.WriteString(csData);

			//csData.Format(_T("erase\n"));
			//Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 400\n"));
			Cmd_File.WriteString(csData);			

			csData.Format(_T("loadfile \"%s\"\n"),this->m_str_Hex_E.cs_Path);
			Cmd_File.WriteString(csData);	

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("loadfile \"%s\"\n"), this->m_str_Hex_E.cs_Path);
			Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);
			csData.Format(_T("r\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("g\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("q\n"));
			Cmd_File.WriteString(csData);


			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));
	
		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"),strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			//throw(1);
			
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);

		return false;
	}

	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_QDM002(const wchar_t * wcp_FW_File_Path)
{
	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CString strData;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;

	try
	{
		//--------------------------------------- 开始解析信息，载入下载文件 --------------------------------------- 
		//提取软件路径
		if (this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("ERROR, Get fls file directory fail!"));
			throw(0);
		}

		//20210511
		int iAd = cs_FW_Dir.ReverseFind('\\');
		cs_FW_Dir = cs_FW_Dir.Left(iAd);


		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while (b_Found)
		{
			b_Found = cla_Finder.FindNextFile();

			if (cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if (!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();
				//Bootloader 名称为：QDM002_NC_BL_V1.0.bin
				//QDM002_MCU_NC_SBL_V1.0.bin
				//QDM002_MCU_NC_FBL_V1.0.bin
				if (wcsstr(cs_FW_Name, _T("QDM002_MCU_NC")) != NULL)
				{
					if (wcsstr(cs_FW_Name, _T("BL_")) != NULL)
					{
						this->m_str_Hex_N.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Hex_N.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					// 应用名称：QDM002_NC_CAN_V1.0.bin
					//QDM002_MCU_NC_SCAN_V1.1.bin
					//QDM002_MCU_NC_FCAN_V1.1.bin
					if (wcsstr(cs_FW_Name, _T("CAN_")) != NULL)
					{
						this->m_str_Hex_E.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Hex_E.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
				}
			}
		}//while(b_Found

		//
		cla_Finder.Close();
		//
		if (this->m_str_Hex_N.cs_Name.IsEmpty() == true)
		{
			this->m_csError_Code.Format(_T("_BL_(Bootloader bin not find"));
			throw(0);
		}
		if (this->m_str_Hex_E.cs_Name.IsEmpty() == true)
		{
			this->m_csError_Code.Format(_T("_BL_(Bootloader bin not find"));
			throw(0);
		}

		//20210323
		//\QDM002\1
		//生成eraseAndFlash.jlink 文件
//		device TM32F302K8U6		//选择MCU型号
//			usb 0
//			si 1				//选择swd接口
//			speed 4000			//选择速度
//			erase				//擦除
//			sleep 400
//			loadfile "D:\48-QDE002-jLINK\Segger\Segger\QDM002_MCU_NC_SBL_V1.0.bin"	0x08000000// Bootloader 名称为：QDM002_NC_SBL_V1.0.bin
//			sleep 400
//			loadfile "D:\48-QDE002-jLINK\Segger\Segger\QDM002_MCU_NC_SCAN_V1.1.bin"	 0x08007800//  烧录CAN232应用
//			sleep 100
//			r
//			g
//			q

		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;

		strCmd_file_name.Format(_T("%s\\QDM002\\%d\\eraseAndFlash.jlink"), this->m_csCurr_Exe_Path, m_iClass_Idx);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}

		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			if ((_T("QDM002EUEF-D10-CAAAA") == m_csOC)//复旦微的OC
				|| (_T("QDM002NAEF-D10-CAAAA") == m_csOC))//复旦微的OC
			{
				csData.Format(_T("device FM33LG02x\n"));
			}
			else//st mcu的OC
			{
				csData.Format(_T("device STM32F302K8\n"));
			}

			Cmd_File.WriteString(csData);

			csData.Format(_T("usb 0\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("si 1\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("speed 4000\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("erase\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 400\n"));
			Cmd_File.WriteString(csData);

			if ((_T("QDM002EUEF-D10-CAAAA") == m_csOC)//复旦微的OC
				|| (_T("QDM002NAEF-D10-CAAAA") == m_csOC))//复旦微的OC
			{
				csData.Format(_T("loadfile \"%s\" 0x00000000\n"), this->m_str_Hex_N.cs_Path);
				Cmd_File.WriteString(csData);

				csData.Format(_T("sleep 100\n"));
				Cmd_File.WriteString(csData);

				csData.Format(_T("loadfile \"%s\" 0x00010000\n"), this->m_str_Hex_E.cs_Path);
				Cmd_File.WriteString(csData);
			}
			else//st mcu的OC
			{
				csData.Format(_T("loadfile \"%s\" 0x08000000\n"), this->m_str_Hex_N.cs_Path);
				Cmd_File.WriteString(csData);

				csData.Format(_T("sleep 100\n"));
				Cmd_File.WriteString(csData);

				csData.Format(_T("loadfile \"%s\" 0x08007800\n"), this->m_str_Hex_E.cs_Path);
				Cmd_File.WriteString(csData);
			}

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("r\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("g\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("q\n"));
			Cmd_File.WriteString(csData);


			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));

		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			//throw(1);

		}
	}
	catch (...)
	{
		this->Show_Status(this->m_csError_Code);
		return false;
	}

	return true;
}

//20210602
bool CARM_OP_QCM::LOAD_FW_FILE_QDE006(const wchar_t * wcp_FW_File_Path)
{
	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int iHex_Quan = 0;
	int j;

	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Hex_E.cs_Name.Format(_T("hex_e"));
		this->m_str_Hex_E.cs_Path.Format(_T(""));


		//提取软件路径
		if (this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get HEX file directory fail!"));
			throw(0);
		}


		//把Hex文件放入临时BUFF中t
		cs_FW_Path.Format(_T("%s"), wcp_FW_File_Path);
		cs_FW_Name = cs_FW_Path.Right(cs_FW_Path.GetLength() - cs_FW_Path.ReverseFind(_T('\\')) - 1);
		this->m_str_Hex_E.cs_Name.Format(_T("%s"), cs_FW_Name);
		this->m_str_Hex_E.cs_Path.Format(_T("%s"), wcp_FW_File_Path);

		//生成eraseAndFlash.jlink 文件
		// 		device STM32F030CC
		// 		usb 0
		// 		si 1
		// 		speed 9600
		// 		erase
		// 
		// 		sleep 400
		// 
		// 		loadfile "D:\24_FW_2\Honeywell-A4\A4_Test\A4_Test\a4cell_flash_script\A4CellMfg_0_1.hex"
		// 		sleep 100
		// 		r
		// 		g
		//		q

		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;

		strCmd_file_name.Format(_T("%s\\Honeywell_A4\\%d\\eraseAndFlash.jlink"), this->m_csCurr_Exe_Path, m_iClass_Idx);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}

		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			csData.Format(_T("device STM32F030CC\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("usb 0\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("si 1\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("speed 9600\n"));
			Cmd_File.WriteString(csData);

			//csData.Format(_T("erase\n"));
			//Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 400\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("loadfile \"%s\"\n"), this->m_str_Hex_E.cs_Path);
			Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);

			//----------------------------------------
			csData.Format(_T("loadfile \"%s\"\n"), this->m_str_Hex_E.cs_Path);
			Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("r\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("g\n"));
			Cmd_File.WriteString(csData);

			csData.Format(_T("q\n"));
			Cmd_File.WriteString(csData);


			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));

		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			//throw(1);

		}

	}
	catch (...)
	{
		this->Show_Status(this->m_csError_Code);

		return false;
	}

	return true;
}



int CARM_OP_QCM::Execute_SDM845(void)
{
	CString csData,csReditInfo;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	//
	bool bOpenFlag =false,bFindComFlag =false;

	m_bEDL_Now = false;

	bool bDL_Flag = true;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,120);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,120) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}
		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//------------------------------

		//刷新COM参数
		this->Load_Com_Port_Params();




		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8909的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8909的QDLoader口”
				bEDL_Now = true;

				m_bEDL_Now = true;//20190507 区别裸片和非裸片
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}

		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_SDM845( iQDLoader_Port ) == false)
		{
			throw(3);
		}

		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}


		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}




bool CARM_OP_QCM::LOAD_FW_FILE_Sdm660(const wchar_t * wcp_FW_File_Path)
{
	//Sdm660---SC66CE NA
	//判定、加载Sdm660的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//20190528 识别SC662NCE机型
		CString strFW_Path;
		strFW_Path.Format(_T("%s"), cs_FW_Dir);
		strFW_Path = strFW_Path.MakeUpper();
		if(NULL != wcsstr(strFW_Path,_T("SC662NCE")))
		{
			mQCM_SC662NCE_Flag  = true;
		}
		else
		{
			mQCM_SC662NCE_Flag  = false;
		}


		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);



		

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .ELF 文件
				if(wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//挑出“prog_emmc_ufs_firehose_Sdm660_ddr.elf”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_UNSPARSE")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//
					//SC66CENA
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM1")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG1_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG1_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG1_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM2")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG2_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG2_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG2_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM3")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG3_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG3_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG3_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM4")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG4_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG4_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG4_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM5")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG5_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG5_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG5_SDM660_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch1.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH1")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH1_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH1_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH1_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch2.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH2")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH2_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH2_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH2_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch3.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH3")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH3_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH3_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH3_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch4.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH4")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH4_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH4_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH4_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//挑出“patch5.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH5")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH5_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH5_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH5_SDM660_XML_FILE_I].b_Enable_DL = true;
					}
					//provision_samsung.xml
					if(wcsstr(cs_FW_Name, _T("PROVISION_SAMSUNG")) != NULL)
					{
						this->m_strr_Mbn_File_List[PROVISION_SDM660_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PROVISION_SDM660_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PROVISION_SDM660_XML_FILE_I].b_Enable_DL = true;
					}

				}


				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM660_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM660_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SDM660_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_SDM660_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SDM660_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SDM660_BIN_FILE_I].b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_SDM660_ELF_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_SDM660_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_SDM660_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

int CARM_OP_QCM::Execute_SDM660(void)
{
	CString csData,csReditInfo;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	//
	bool bOpenFlag =false,bFindComFlag =false;

	m_bEDL_Now = false;

	bool bDL_Flag = true;

	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,120);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,120) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}
		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//------------------------------

		//刷新COM参数
		this->Load_Com_Port_Params();




		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8909的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8909的QDLoader口”
				bEDL_Now = true;

				m_bEDL_Now = true;//20190507 区别裸片和非裸片
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}

		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_SDX660( iQDLoader_Port ) == false)
		{
			throw(3);
		}

		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}


		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::LOAD_FW_FILE_9X55(const wchar_t * wcp_FW_File_Path)
{
	//MDM9X55
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir,cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		int num=0;
		for(num=0;num<Firehose_File_NUM;num++)
		{			
			Firehose_File[num].dis_flag =0;
		}

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;


		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		BOOL bFirehoseFind =FALSE;
		int  iFirehoseFind =-1;
		//直接通过路径中是否带Firehose进行判断 20181121
		iFirehoseFind = cs_FW_Dir.Find(_T("firehose"));
		if (0 == m_iFirhose_DB) //离线方式
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else
			{
				//20200113
				AfxMessageBox(_T("Please load firehose file"));
				this->m_csError_Code.Format(_T("Please load firehose file"));
				throw(0);

			}
		} 
		else if(((1 == m_iFirhose_DB)&&(1 == m_iAutoDL_Flag) ) //在线方式 Firehose
			|| (1 == m_iFirhose_DB_Path)) //Firmware路径中有Firehose
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
			else //查找firehose文件夹
			{
				cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

				b_Found = cla_Finder.FindFile(cs_Finder_Dir);

				while(b_Found) 
				{
					b_Found = cla_Finder.FindNextFile();

					if(cla_Finder.IsDots())
					{
						continue;//找到的是当前目录或上级目录则跳过
					}

					if(cla_Finder.IsDirectory())	//如果是文件夹
					{
						cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
						cs_FW_Name.MakeUpper();//统一大写
						if(wcsstr(cs_FW_Name, _T("FIREHOSE")) != NULL)
						{
							cs_FW_Dir=cs_FW_Dir+_T("\\firehose");
							cs_FW_Fire_hoseDir = cs_FW_Dir;
							bFirehoseFind = TRUE;
							break;
						}
					}
				}

			}

		}
		else
		{
			if (iFirehoseFind>=0)
			{
				cs_FW_Fire_hoseDir = cs_FW_Dir;
				bFirehoseFind = TRUE;
			}
		}
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 partition_nand.xml 文件
				if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
				{
					this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
				}

				//去掉文件类型显示
				cs_FW_Name.Replace(_T(".XML"), _T("\0"));

				//挑出“rawprogram_nand_p4K_b256K_update.xml\rawprogram_nand_p4K_b256K_factory.xml”文件
				if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
				{
					this->m_strr_Mbn_File_List[RAWPROG_MDM9X55_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_MDM9X55_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[RAWPROG_MDM9X55_XML_FILE_I].b_Enable_DL = true;
				}

				//挑出“patch_p4K_b256K.xml”文件
				if(wcsstr(cs_FW_Name, _T("PATCH")) != NULL)
				{
					this->m_strr_Mbn_File_List[PATCH0_MDM9X55_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_MDM9X55_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_strr_Mbn_File_List[PATCH0_MDM9X55_XML_FILE_I].b_Enable_DL = true;
				}
				//挑出Firehose  \update\firehose\partition_complete_p4K_b256K.mbn

				if(wcsstr(cs_FW_Name, _T("PARTITION_COMPLETE")) != NULL)
				{
					this->m_str_partition_complete.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_partition_complete.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_partition_complete.b_Enable_DL = true;
				}

				if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
				{
					//加载数据
					this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					this->m_str_Mbn_CEFS.b_Enable_DL = true;
				}

				//寻找 mbn 驱动文件
				if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_nand_firehose_9x55.mbn”文件
					//if (m_bSAHARA_DL_Switch == false)
					//{
						if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
						{
							this->m_strr_Mbn_File_List[FIREHOSE_MDM9X55_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_MDM9X55_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_strr_Mbn_File_List[FIREHOSE_MDM9X55_MBN_FILE_I].b_Enable_DL = true;
							m_iMDM9X07_NEW_FLAG =1;
						}
					//}


					//挑出“ENPRG9x55.mbn”文件
					if(wcscmp(cs_FW_Name, _T("ENPRG9X55")) == 0)
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
					}


					//挑出“NPRG9x55.mbn”文件
					if(wcscmp(cs_FW_Name, _T("NPRG9X55")) == 0)
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//去掉文件类型显示
						//						cs_FW_Name.Replace(_T(".QCN"), _T("\0"));
						//把QCN文件放入BUFF中
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		if(TRUE == bFirehoseFind)
		{
			if (iFirehoseFind ==-1) //选的文件和Firehose同一个文件夹
			{
				int iAd = cs_FW_Dir.ReverseFind('\\');
				cs_FW_Dir = cs_FW_Dir.Left(iAd);

			}
			else
			{
				cs_FW_Dir = cs_FW_Dir.Left(iFirehoseFind-1);	
			}

			cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

			b_Found = cla_Finder.FindFile(cs_Finder_Dir);

			while(b_Found) 
			{
				b_Found = cla_Finder.FindNextFile();

				if(cla_Finder.IsDots())
				{
					continue;//找到的是当前目录或上级目录则跳过
				}			

				if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
				{
					cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名
					// 					sbl1.mbn
					// 					13:10:44: INFO: Looking for file '../tz.mbn'
					// 					13:10:44: INFO: Looking for file '../rpm.mbn'
					// 					13:10:44: INFO: Looking for file '../appsboot.mbn'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-boot.img'
					// 					13:10:44: INFO: Looking for file '../mdm-perf-recovery-image-mdm9607-perf.ubi'
					// 					13:10:44: INFO: Looking for file '../NON-HLOS.ubi'
					// 					13:10:44: INFO: Looking for file '../usrdata.ubi'
					// 					13:10:44: INFO: Looking for file '../mdm9607-perf-sysfs.ubi'
					for(num=0;num<Firehose_File_NUM;num++)
					{
						if (Firehose_File[num].Firehose_File == cs_FW_Name)
						{
							Firehose_File[num].dis_flag =1;
						}
					}
					//Firehose_File[11].dis_flag =1;//E:\Firmware\Stanley\app_atc_pipe(0725)\update\firehose\partition_complete_p4K_b256K.mbn

					cs_FW_Name.MakeUpper();//统一大写

					//寻找 partition_nand.xml 文件
					if((wcsstr(cs_FW_Name, _T(".XML")) != NULL) && (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL))
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					if(wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
					//寻找 mbn 驱动文件
					if(wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
					{
						//去掉文件类型显示
						cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

						//------------------------------------------

						//挑出“ENPRG9x55.mbn”文件
						if(wcscmp(cs_FW_Name, _T("ENPRG9X55")) == 0)
						{
							this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Emerg.b_Enable_DL = true;
						}


						//挑出“NPRG9x55.mbn”文件
						if(wcscmp(cs_FW_Name, _T("NPRG9X55")) == 0)
						{
							this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
							this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
							this->m_str_Mbn_Norm.b_Enable_DL = true;
						}
					}

					//客户无需下载QCN
				}
			}//while(b_Found

			cs_FW_Dir=cs_FW_Fire_hoseDir;

		}

		//关闭find
		cla_Finder.Close();

		if (1 == m_iMDM9X07_NEW_FLAG)
		{
			if(this->m_strr_Mbn_File_List[RAWPROG_MDM9X55_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if(this->m_strr_Mbn_File_List[PATCH0_MDM9X55_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径

			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
			//this->m_csFW_File_Path.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_9X07_MBN_FILE_I].cs_Path);
		}
		else
		{
			//检查是否找到文件
			if(this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x07.mbn file!"));
				throw(0);
			}
			if(this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x07.mbn file!"));
				throw(0);
			}

			//从“partition_nand.xml”文件中解析“下载文件”
			if(this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				throw(0);
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if(this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if(this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::DL_FW_MDM9X55_SAHARA(void)
{
	int iM9x07_Cur_Status;
	CString csData;
	unsigned long ulMax_Block_Size = 0;
	//下载步骤控制变量
	bool bSwitch_Sahara = false;
	bool bDL_Sahara = false;


	try
	{
		//一般都是高速CPU模块
		this->m_bLow_Speed_CPU = false;

		//DM口下载
		this->m_iDLOAD_PORT = QCMM_DL_PORT_DIAG;



		//----------------------- 确定将下载的FW的byte总数 ----------------------- 
		//清空发送Byte统计
		this->m_ul_Transmit_Bytes = 0;
		//计算下载文件的总大小
		this->m_ul_DL_All_Bytes = 0;

		//加上mbn文件大小
		for(int i=0; i<MAX_MBN_FILE; i++)
		{
			if(this->m_strr_Mbn_File_List[i].b_Enable_DL == true)
			{
				this->m_ul_DL_All_Bytes += this->m_strr_Mbn_File_List[i].ul_File_Size;
			}
		}
		//加上Partition文件大小
		this->m_ul_DL_All_Bytes += this->m_str_Mbn_Partition_Table.ul_File_Size;
		//如果下载CEFS文件，就要增加CEFS文件的大小
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)//“控制下载CEFS文件”并且“FW包中有CEFS文件”
		{
			this->m_ul_DL_All_Bytes += this->m_str_Mbn_CEFS.ul_File_Size;
		}
		//-----------------------



		//初始化PKT_BUFF内存
		//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Send);
		//		this->m_cla_GFC.PKT_BUFF_INIT(&this->m_str_Pkt_Read);



		//----------------------- 打开串口（第一次）----------------------- 
		this->Show_Status(_T("Open com port......"));

		CString strPortInfo;
		strPortInfo.Format(_T("Open com port %d......"),m_iCom_Port);
		Save_Trace_Log(strPortInfo);

		//以界面波特率打开串口
		this->COM_PORT_CHANGE_BAUDRATE(this->m_iBaud_Rate);
		//打开串口
		if(this->COM_PORT_OPEN() == false)
		{
			csData.Format(_T("%s [1st Open]"), this->GET_COM_PORT_ERROR_INFO());
			this->Show_Status(csData);
			Save_Trace_Log(csData);
			m_csError_Code = csData;
			throw(0);
		}
		//-----------------------

		//----------------------- 最先检查“开机是否是sahara模式” -----------------------
		if(this->DL_FW_SAHARA_EMERG() == true)//“紧急下载模式”时的模块一开始就是sahara模式
		{
			//开机就是sahara模式，紧急下载

			this->Show_Status(_T("DL Emerg Switching ......"));
			Save_Trace_Log(_T("DL Emerg Switching ......"));
			//关闭COM口前的延时
			Sleep(4000);
			//重启串口
			if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
			{
				this->m_csError_Code += _T(" [DL Re-Start]");
				this->Show_Status(this->m_csError_Code);
				Save_Trace_Log(this->m_csError_Code);
				throw(0);
			}
		}
		else
		{
			//开机不是sahara模式，正常模块，正常下载

			//----------------------- 探测确定“模块初始化状态（模式）”----------------------- 
			//探测模块状态模式
			if(this->Ping_DLoad_Port_MDM9x07(&iM9x07_Cur_Status, 20) == false)
			{
				this->Show_Status(this->m_csError_Code);
				Save_Trace_Log(this->m_csError_Code);
				throw(0);
			}
			//-----------------------



			//----------------------- 检查状态是否异常, 确定接下来的流程 -----------------------
			switch(iM9x07_Cur_Status)
			{
			case 1://当前“正常状态”
				bSwitch_Sahara = true;
				bDL_Sahara = true;
				break;
			case 3://当前“SAHARA状态”，状态正常
				bSwitch_Sahara = false;
				bDL_Sahara = true;
				break;
				//0926
			case 4://当前“SAHARA状态”，状态emerg
				bSwitch_Sahara = false;
				bDL_Sahara = true;
				break;

			default:
				{
					this->m_csError_Code.Format(_T("ERROR, Status(%d) no defined!"), iM9x07_Cur_Status);
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------



			//----------------------- 切换到SAHARA下载模式，完成重启 -----------------------
			if(bSwitch_Sahara == true)
			{
				//发3A A1 6E 7E
				if(this->Switch_To_DL_Mode(2) == true)
				{
					//重启串口
					if(this->COM_PORT_RE_DETECT(_T("DM Switching"), 10000, true) == false)
					{
						this->m_csError_Code += _T(" [Diag Open]");
						this->Show_Status(this->m_csError_Code);
						Save_Trace_Log(this->m_csError_Code);
						throw(0);
					}
				}
				else
				{
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------


			//----------------------- SAHARA下载 -----------------------
			if(bDL_Sahara == true)
			{
				if(this->DL_FW_SAHARA_ALL() == false)
				{
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					throw(0);
				}


				this->Show_Status(_T("DL Norm Switching ......"));
				Save_Trace_Log(_T("DL Norm Switching ......"));
				//关闭COM口前的延时
				Sleep(4000);
				//重启串口
				if(this->COM_PORT_RE_DETECT(_T("DL Re-Start"), 4000, true) == false)
				{
					this->m_csError_Code += _T(" [DL Re-Start]");
					this->Show_Status(this->m_csError_Code);
					Save_Trace_Log(this->m_csError_Code);
					throw(0);
				}
			}
			//-----------------------
		}//最先检查“开机是否是sahara模式”
		//-----------------------




		//----------------------- Stream下载 -----------------------

		//----------------------- 发送Hello，并解析回报的HW信息数据 ----------------------- 
		if(this->Send_Stream_Cmd_Hello(10, 0x02, &ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			throw(0);
		}

		//处理block size数据
		if(ulMax_Block_Size > 0x400)
		{
			ulMax_Block_Size = 0x400;
		}
		//-----------------------



		//----------------------- 下载前，运行一句“close”指令 ----------------------- 
		this->Send_Stream_Cmd_Close(-1);
		this->m_csError_Code.Format(_T(""));
		//-----------------------



		//----------------------- 设置Security_Mode，我们用“0x01”----------------------- 
		if(this->Send_Stream_Cmd_Security_Mode(0x01) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 发送Partition_Table文件 ----------------------- 
		if(this->DL_Partition_Table_File(this->m_str_Mbn_Partition_Table) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 下载其他mbn文件 ----------------------- 
		if(this->DL_Mbn_All_File(ulMax_Block_Size) == false)
		{
			this->Show_Status(this->m_csError_Code);
			Save_Trace_Log(this->m_csError_Code);
			throw(0);
		}
		//-----------------------



		//----------------------- 下载cefs文件 ----------------------- 
		if(this->m_bCEFS_DL && this->m_str_Mbn_CEFS.b_Enable_DL)
		{
			if(this->DL_Cefs_File(ulMax_Block_Size) == false)
			{
				this->Show_Status(this->m_csError_Code);
				Save_Trace_Log(this->m_csError_Code);
				throw(0);
			}
		}
		//-----------------------


		//
		//Sleep(1000);


		//----------------------- 重启模块 ----------------------- 
		if(this->Send_Stream_Cmd_Reset() == false)
		{
			//20181220
// 			this->Show_Status(this->m_csError_Code);
 			Save_Trace_Log(this->m_csError_Code);
// 			throw(0);
		}
		//-----------------------
		//重启成功后再向后延迟10秒
		Sleep(10000);




		//关闭串口
		this->COM_PORT_CLOSE();


		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);




		/*
		//----------------------- 导入xqcn -----------------------
		if((this->m_bQCN_DL == true) && (this->m_str_Mbn_QCN_DL.b_Enable_DL == true))
		{
		this->Show_Status(_T("Restart ......"));
		//关闭COM口前的延时
		Sleep(2000);
		//重启串口
		if(this->COM_PORT_RE_DETECT(_T("Re-Start"), 4000, false) == false)
		{
		this->m_csError_Code += _T(" [Re-Start]");
		this->Show_Status(this->m_csError_Code);
		throw(0);
		}


		//
		this->Show_Status(_T("Restore xqcn ......"));
		//
		if(::QLIB_QCN_Restore_XQCN(this->m_cla_Com_Port.m_iPort, this->m_str_Mbn_QCN_DL.cs_Path) == false)
		{
		this->Show_Status(_T("FAIL, Restore xqcn fail!"));
		throw(0);
		}
		}
		//-----------------------
		*/




		//PASS信息显示
		switch(this->m_iDL_Emerg_Norm_TYPE)
		{
		case QCMM_DL_TYPE_EMERG:
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
			break;
		case QCMM_DL_TYPE_NORM:
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
			break;
		default:
			this->Show_Status(_T("ERROR, DL type is wrong!"));
			Save_Trace_Log(_T("ERROR, DL type is wrong!"));
			throw(0);
		}
	}
	catch(...)
	{
		//关闭串口
		this->COM_PORT_CLOSE();

		//释放PKT_BUFF内存
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Send);
		this->m_cla_GFC.PKT_BUFF_FREE(&this->m_str_Pkt_Read);

		//
		return false;
	}

	return true;
}
int CARM_OP_QCM::Execute_MDM9X55_FIREHOSE(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”
	CString csCOM;

	int iQDloadPort=0;

	bool bDL_Flag = true;
	try
	{
		//进度条置零
		this->Show_Progress(0.0);
		
		iQDloadPort = this->m_iCom_Port;

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}
		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//COM口刚生成后，模块初始化未完成，模块无法下载
		//代码锁定
		Sleep(3000);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------

		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“9x07的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“9x07的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++
		//g_cla_Lock_Port.Unlock();
		m_iCom_Old_Port =0;

		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			csCOM.Format(_T("QDLoader %d"), this->m_iCom_Port);
			Save_Trace_Log(csCOM);

			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}

		}
		else
		{
			csCOM.Format(_T("DM %d"), this->m_iCom_Port);
			Show_COMPORT(csCOM);
			Save_Trace_Log(csCOM);

			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				//				g_cla_Lock_Port.Unlock();
				this->m_iError_Code=0x00000072;
				throw(2);
			}
			else
			{
				//虽找到后Qloader口可能还没准备好 20180508
				Sleep(3000);
			}
			//刷新端口的显示

			//csCOM.Format(_T("Start %d"), iQDLoader_Port);
			csCOM.Format(_T("QDLoader %d"), iQDLoader_Port);
			Show_COMPORT(csCOM);
			m_iCom_Old_Port=m_iCom_Port;
			Save_Trace_Log(csCOM);
		}

		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);
		Save_Trace_Log(csData);
		//		g_cla_Lock_Port.Unlock();

		//------------------------------

		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_MDM9X55_FIREHOSE( iQDLoader_Port ) == false)
		{
			throw(3);
			//如果失败了，再尝试下载一遍
			// 			Sleep(2000);
			// 			if(this->DL_FW_V2_MSM9X07( iQDLoader_Port ) == false)
			// 			{
			// 				throw(3);
			// 			}
		}
		if (TRUE == m_bFirehose_Reset_after_DL)
		{
			//重启成功后再向后延迟30秒
			this->Show_Status(_T("Reset..."));
			Sleep(30000);
		}
		//-------------


		//-----------------
#if 0
		if(this->m_iOP_Robot == LOAD_AUTO_ROBOT)//全自动机器人
		{
			//下载完重启
			//向总控PC发送DC重启指令
			bool bDC_Reset =false;
			csData.Format(_T("Reset......%d OFF"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);


			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("OFF") );
			Sleep(5000);
			bDC_Reset = ::TS_LAN_SEND_DC_LAN_CMD_TO_MC_PC( m_Ts_Num, _T("ON") );

			csData.Format(_T("Reset......%d ON"), m_Ts_Num);
			this->Show_Status(csData);
			Save_Trace_Log(csData);
			Sleep(8000);

			// 			if (this->m_DM_Port >0)
			// 			{
			// 				if(this->Confirm_Dynamic_Com_Port(this->m_DM_Port, 30) == false)
			// 				{
			// 					this->m_csError_Code.Format(_T("Reset Fail(DM(%d) Find Fail)"),this->m_DM_Port);
			// 					this->Show_Status(this->m_csError_Code);
			// 					throw(1);
			// 				}
			// 			}
			this->Show_Status(_T("Reset Suecess"));
			Save_Trace_Log(_T("Reset Suecess"));

		}
#endif

		//显示进度条 100%
		this->Show_Progress(1.0);

		//保存当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
		}
		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
			Save_Trace_Log(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
			Save_Trace_Log(_T("FW upgrade success."));
		}

		//刷新端口的显示
		if (m_iCom_Old_Port != 0)
		{
			csCOM.Format(_T("%d"), m_iCom_Old_Port);
			Show_COMPORT(csCOM);
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		// 		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		// 		{
		// 			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		// 		}

		//对应的置零
		switch(m_iClass_Idx)
		{
		case 1:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
			break;
		case 2:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
			break;
		case 3:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
			break;
		case 4:
			this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
			break;
		}
		return RTN_FAIL;
	}

	//对应的置零
	//下载完成后去除当前使用QDLoader的COM口
	// 	if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
	// 	{
	// 		g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
	// 	}
	switch(m_iClass_Idx)
	{
	case 1:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_1"), 0);
		break;
	case 2:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_2"), 0);
		break;
	case 3:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_3"), 0);
		break;
	case 4:
		this->m_cla_iniQD_Params.StoreInt(_T("FIREHOSE"), _T("QD_4"), 0);
		break;
	}
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_MDM9X55_FIREHOSE(int i_QDLoader_Port)
{
	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_MDM9X55_MBN_FILE_I]) == false)
		{
			this->m_iError_Code=0x00000073;
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_MDM9X55_XML_FILE_I]) == false)
		{
			this->m_iError_Code=0x00000074;
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_MDM9X55_XML_FILE_I]) == false)
		{
			throw(3);
		}

		//显示进度条 90%
		this->Show_Progress(0.9);
		if (TRUE == m_bFirehose_Reset_after_DL)
		{
			//4. Reset the device if necessary
			if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
			{
				throw(4);
			}
		}

		//
	}
	catch(...)
	{
		return false;
	}

	return true;
}

int CARM_OP_QCM::Execute_MDM9X55(void)
{
	//------------------------------
	//------------------------------
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//
		CString csData;
					
		if (1 != m_iMDM9X07_NEW_FLAG)//Sahara
		{
			//探测DM口生成
			csData.Format(_T("Find Port(%d)..."),this->m_iCom_Port);
			this->Show_Out(csData);
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 25) == false)
			{
				this->Show_Out(this->m_csError_Code);
				this->Show_Status(this->m_csError_Code);
				throw(1);
			}
			//DM端口刚生成后，模块初始化未完成，模块无法下载
			Sleep(9000);
			csData.Format(_T("Find Port(%d) Pass"),this->m_iCom_Port);
			this->Show_Out(csData);

			//------------------------------ 下载FW操作 ------------------------------ 
			if(this->DL_FW_MDM9X55_SAHARA() == false)
			{
				throw(2);
			}
		}
		else //Firehose
		{
			//------------------------------ 下载FW操作 ------------------------------ 
			int iDL_Flag = RTN_FAIL;
			iDL_Flag = Execute_MDM9X55_FIREHOSE();

			return iDL_Flag;
		}
		//------------------------------

	}
	catch(...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}

void CARM_OP_QCM::Show_Out(const wchar_t * wcp_Status)
{
	::SendMessage(this->m_hWnd_View, WM_OUT_STATUS_MSG, (WPARAM)wcp_Status, (LPARAM)this->m_iClass_Idx);
}

//如果口消失认为是正常的
bool CARM_OP_QCM::Confirm_Dynamic_Com_Port_N(const int i_Tgt_Com_Port, int i_TimeOut)
{
	time_t t_Start, t_End;
	CString csA, csB;
	int j = 0;

	try
	{
		csB.Format(_T(" ."));

		time(&t_Start);
		this->Show_Status(_T("Wait DM Port normal exist..."));
		this->Show_Out(_T("Wait DM Port normal exist..."));
		this->Save_Trace_Log(_T("Wait DM Port normal exist..."));
		do
		{
			//读出regedit中的COM列表
			if(this->m_cla_GFC.Confirm_Reg_Com_Port(i_Tgt_Com_Port) == false)
			{	
				this->Show_Status(_T("DM Port not exist"));
				this->Show_Out(_T("DM Port not exist"));
				this->Save_Trace_Log(_T("DM Port not exist"));
				return true;
			}

			//系统暂停
			if(this->m_iStop_Flag > 0)
			{
				this->m_csError_Code.Format(_T("Operation has been stopped!"));
				throw(0);
			}

			//检查是否超时
			time(&t_End);
			if((int)difftime(t_End, t_Start) >= i_TimeOut)
			{
				this->m_csError_Code.Format(_T("FAIL, Confirm dynamic com port %d timeout(N)!"), i_Tgt_Com_Port);
				throw(0);
			}

			//进度简易显示
			if((j % 10) == 0)
			{
				csA.Format(_T("Detect dynamic com port %d"), i_Tgt_Com_Port);
			}

			csA += csB;
			this->Show_Status(csA);
			j++;

			//每次读取注册表的延迟
			Sleep(800);
		}
		while(true);
	}
	catch(...)
	{
		this->Show_Out(_T("Query DM port exist"));
		this->Save_Trace_Log(_T("Query DM port exist"));
		this->Show_Status(_T("Query DM port exist"));
		return false;
	}

	return false;
}

//SC66 在裸片下载FW前第一步需下载provision （SDM660 导入 UFS 存储）
bool CARM_OP_QCM::QFIL_DL_UFS_Provision_Check(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“provision”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download UFS Provision......"));
		this->Save_Trace_Log(_T("Download UFS Provision......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d --getstorageinfo=65210 --memoryname=UFS"),
			'/', this->m_csCurr_Exe_Path, i_QDLoader_Port);
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_UFS_Provision "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//provision_samsung.xml
//SC66 在裸片下载FW前第一步需下载provision （SDM660 导入 UFS 存储）
bool CARM_OP_QCM::QFIL_DL_UFS_Provision(int i_QDLoader_Port, const MBN_FILE_S str_provision_File)
{
	//使用“fh_loader.exe”操作“provision”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download UFS Provision......"));
		this->Save_Trace_Log(_T("Download UFS Provision......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

      //C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM89 
	  //--sendxml=provision_samsung.xml --search_path=D:\4_Firmware\SC66CENAR01A05_BP01.005V01_Android9.0.0.01.019V01_UFS_factory\SC66_ufs 
	  //--noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS --skipstorageinit 

		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH1\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=\"%s\" --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS --skipstorageinit"),
			'/', this->m_csCurr_Exe_Path, i_QDLoader_Port,str_provision_File.cs_Name, this->m_csFW_File_Path);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_UFS_Provision "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_UFS_Provision, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::QFIL_DL_Rawprogram_Ext(int i_QDLoader_Port, 
										 const MBN_FILE_S str_Rawprogram_File,
										 const MBN_FILE_S str_Rawprogram_File1,
										 const MBN_FILE_S str_Rawprogram_File2,
										 const MBN_FILE_S str_Rawprogram_File3,
										 const MBN_FILE_S str_Rawprogram_File4,
										 const MBN_FILE_S str_Rawprogram_File5)
{
	//使用“fh_loader.exe”下载“rawprogram_unsparse.xml”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 10;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download rawprogram Ext file ......"));
		this->Save_Trace_Log(_T("Download rawprogram Ext file ......"));
		this->Show_Out(_T("Download rawprogram Ext file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//------------------------------ 打包dos指令 ------------------------------ --sendxml=rawprogram_unsparse.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s,%s,%s,%s,%s,%s --search_path=\"%s\"  --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, str_Rawprogram_File1.cs_Name, str_Rawprogram_File2.cs_Name, str_Rawprogram_File3.cs_Name, str_Rawprogram_File4.cs_Name, str_Rawprogram_File5.cs_Name, this->m_csFW_File_Path);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//提取重要的“进度百分比信息”
				//提取第一个值(0)
				wcpEach = wcstok(wcpData, _T("\r\n"));
				//
				while(wcpEach != NULL)
				{
					//是否有“percent 开始”关键词
					wcpPercent = wcsstr(wcpEach, _T("{percent files transferred"));
					//
					if(wcpPercent != NULL)
					{
						//备份单条数据
						csEach.Format(_T("%s"), wcpPercent);

						//提取百分比数据
						wcpPercent += 26;

						//是否有“percent 结束”关键词
						if(wcsstr(wcpPercent, _T("%")) != NULL)
						{
							//发现百分比数据的“结尾”
							csTemp.Format(_T("%s"), wcpPercent);
							csTemp.Replace('%', '\0');//去掉结尾

							//字符转数字
							dNew_Percent = _wtof(csTemp);

							//刷新百分比数据
							if(dNew_Percent > dCurr_Percent)
							{
								//赋值新百分比数据
								dCurr_Percent = dNew_Percent;


								//显示“单条信息数据”
								csEach.Replace('{', ' ');//去掉不想显示的字符
								csEach.Replace('}', ' ');//去掉不想显示的字符
								csEach.Replace('\r', ' ');//去掉不想显示的字符
								csEach.Replace('\n', ' ');//去掉不想显示的字符
								csTemp.Format(_T("DL-Rawprogram( %.2f%% ), %s"), dCurr_Percent, csEach);
								this->Show_Status(csTemp);
								this->Save_Trace_Log(csTemp);
								//无延迟，则看不出显示信息的变化
								Sleep(20);


								//显示进度条
								this->Show_Progress( (0.2 + 0.6 * (dCurr_Percent / 100.0)) );
							}
						}//if(wcsstr(wcpPercent, _T("%")) != NULL
					}//if(wcpPercent != NULL


					//提取下一个值
					wcpEach = wcstok(NULL, _T("\r\n"));
				}//while(wcpEach != NULL



				//汇总数据
				if(dCurr_Percent > 98.0)
				{
					csTotal_Info += csData;
				}
				else
				{
					csTotal_Info.Format(_T("%s"), csData);
				}


				//有数据的话就重新开始计时
				time(&t_Start);
			}//if(ulActual_Read > 0


			//检查是否有错误报出
			if ((SDX20 == this->m_eu_BB_Chip)
				|| (MDM9X05 == this->m_eu_BB_Chip)
				|| (SDX55 == this->m_eu_BB_Chip))
			{
				//ERROR: [1318] error : 9
				if((wcsstr(csTotal_Info, _T("error: [1318]")) != NULL)
					||((wcsstr(csTotal_Info, _T("erasing")) != NULL)
					&&(wcsstr(csTotal_Info, _T("error:")) != NULL))
					||((wcsstr(csTotal_Info, _T("erase")) != NULL)
					&&(wcsstr(csTotal_Info, _T("error:")) != NULL))
					)					
				{

				}
				else
				{
					if(wcsstr(csTotal_Info, _T("error:")) != NULL)
					{	
						this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
						throw(3);
					}
				}

			}
			else
			{
				if(wcsstr(csTotal_Info, _T("error:")) != NULL)
				{
					this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
					throw(3);
				}
			}


			//检查是否pass
			if((wcsstr(csTotal_Info, _T("all finished successfully")) != NULL) &&
				(wcsstr(csTotal_Info, _T("percent files transferred 100.00")) != NULL))
			{
				//				::AfxMessageBox(csTotal_Info);

				bSuccess_Flag = true;//pass
				break;//退出while
			}



			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Time out!"));
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for(iTemp=1; iTemp>=0; iTemp--)
		{
			csData.Format(_T("DL-Rawprogram, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(800);
		}

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

bool CARM_OP_QCM::QFIL_DL_Patch_Ext(int i_QDLoader_Port, 
									const MBN_FILE_S str_Patch_File,
									const MBN_FILE_S str_Patch_File1,
									const MBN_FILE_S str_Patch_File2,
									const MBN_FILE_S str_Patch_File3,
									const MBN_FILE_S str_Patch_File4,
									const MBN_FILE_S str_Patch_File5)
{
	//使用“fh_loader.exe”下载“patch0.xml”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	//int iTimeout = 10; //20170527
	int iTimeout = 60; //20180226


	try
	{
		//显示
		this->Show_Status(_T("Download patch file ......"));
		this->Save_Trace_Log(_T("Download patch file ......"));
		this->Show_Out(_T("Download patch file ..."));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Patch, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		swprintf(wcpCmd, _T("cmd.exe cd %s %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s,%s,%s,%s,%s,%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
				this->m_csCurr_Exe_Path, '/',  m_iClass_Idx,i_QDLoader_Port, str_Patch_File.cs_Name,str_Patch_File1.cs_Name,str_Patch_File2.cs_Name,str_Patch_File3.cs_Name,str_Patch_File4.cs_Name,str_Patch_File5.cs_Name, this->m_csFW_File_Path);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Patch, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Patch "));
				//20180425
				//this->Save_Trace_Log(wcpData);

			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Patch error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Patch, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for(iTemp=1; iTemp>=0; iTemp--)
		{
			csData.Format(_T("DL-Patch, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(500);
		}

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}

//全擦功能
//FHLoaderErase.xml
//
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderErase, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --sendxml=FHLoaderErase.xml --search_path=C:\Users\Q\AppData\Roaming\Qualcomm\QFIL\COMPORT_279 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand 
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=FHLoaderErase.xml --search_path=\"%s\\QCMM\\CH%d\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port,this->m_csCurr_Exe_Path,m_iClass_Idx);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderErase, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderErase "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderErase error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderErase, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc , Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand 		
		//------------------------------ 打包dos指令 ------------------------------
		if (true == this->m_bAG_Flag)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand --porttracename=log\\port_trace-%d.txt"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, m_iClass_Idx);
		}
		else
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port);
		}


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}


//检测统计存在QDloader口
void CARM_OP_QCM::Detect_QDloader_Port()
{
	CString csData;	
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int ii,i,j,num;
	i = 0;

	num =0;
	//
	try
	{
		do
		{
			//
			i++;
			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);
			//
			for (j = 0; j < asi.GetSize(); j++)
			{			
				//增加Quectel；QDloader 9008
				if (wcsstr(asi[j].strPortDesc, _T("9008")) != NULL)
				{
					if (num < MAX_QD_NUM)
					{
						m_iQDloader_S[num] = _wtoi(asi[j].strPortName);
						num++;
					}
 					
				}
			}
			//显示
			csData.Format(_T("[INFO] Detect Port......%d"), (10 - i));
			this->Show_Status(csData);

			//
			if (i >= 10)
			{
				break;
			}

		} while (true);
	}
	catch (...)
	{
		return ;
	}
	return ;
}

//

bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_CMD(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc , Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand 		
		//------------------------------ 打包dos指令 ------------------------------
		//fh_loader.exe --port=\\.\COM66 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
bool CARM_OP_QCM::Deactivate_MBN_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
			throw(0);
		}

	}
	catch(...)
	{
		return 0;
	}
	return 1;

}
//at+qmbncfg="list" 

//  [2017-10-12_19:57:42]+QMBNCFG: "List",0,0,0,"ROW_Generic_3GPP",0x05010814,201704141
//	[2017-10-12_19:57:42]+QMBNCFG: "List",1,1,1,"Telstra-Commercial_VoLTE",0x0580070D,201710111
bool CARM_OP_QCM::List_Op_In_AT_Ext(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	CString  strOpName;


	try
	{
		//发送
		//
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("QMBNCFG"), 3) == false)
		{
			return 1;
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//20200109
		//取出ROW_Generic_3GPP

		CString csrList[16];

		CString csDt;
		int num =0;
		int i = 0;

		m_iCsrListNum =0;

		for (int i =0;i<16;i++)
		{
			csrList[i].Format(_T(""));
			m_csrPN[i].Format(_T(""));
		}
		int iPos = -1;

		iPos = csData.Find(_T("\r\n"));
		while((iPos>=0)&&(i<16))
		{
			csDt =  csData.Left(iPos);

			if (csDt.Find(_T("+QMBNCFG")) >= 0)
			{

				csDt.Replace(_T("\""),_T(""));

				csrList[i] = csDt;

				if(this->m_cla_GFC.WCSTOK_STRING_C( csrList[i], _T(","), 4, &(m_csrPN[i]) ) == false)
				{
					//
					this->Show_Out(_T("Fail,Get PN Fail"));

				}

				i++;

				m_iCsrListNum++;


			}

			csData = csData.Mid(iPos+1);
			iPos = csData.Find(_T("\r\n"));

		}




	}
	catch(...)
	{
		//		this->m_cla_AT_Com_Port.Port_Close();
		return 0;
	}
	return 1;

}
bool CARM_OP_QCM::QMBN_Del_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			//this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			//throw(0);
		}
	}
	catch(...)
	{
		return 0;
	}
	return 1;

}

bool CARM_OP_QCM::FindMbnFile(CString lpPath)
{
	CString strSubPath,strNewPath;

	//WIN32_FIND_DATA结构描述了一个由FindFirstFile, 
	//FindFirstFileEx, 或FindNextFile函数查找到的文件信息
	WIN32_FIND_DATA FindFileData;

	//通过FindFirstFile()函数根据当前的文件存放路径
	//查找该文件来把待操作文件的相关属性读取到WIN32_FIND_DATA结构中去
	strNewPath.Format(_T("%s*.*"),lpPath);
	HANDLE hFind=::FindFirstFile(strNewPath,&FindFileData);
	if(INVALID_HANDLE_VALUE == hFind)    
	{
		return false;  //如果hFind的句柄值无效，返回0
	}

	while(TRUE)
	{
		//将dwFileAttributes和FILE_ATTRIBUTE_DIRECTORY做位"与"运算来判断所找到的项目是不是文件夹，
		//这段程序的目的是查找文件夹下子文件夹中的内容
		if(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if(FindFileData.cFileName[0]!='.')
			{	
				strSubPath.Format(_T("%s%s\\"),lpPath,FindFileData.cFileName);
				FindMbnFile(strSubPath);
			}
		}
		else
		{
			if (mMbn_File_NUM<MAX_MBN_FILE)
			{
				this->m_strr_Mbn_File_List_Ext[mMbn_File_NUM].cs_Name.Format(_T("%s"),FindFileData.cFileName);
				this->m_strr_Mbn_File_List_Ext[mMbn_File_NUM].cs_Path.Format(_T("%s"),lpPath);				
				this->m_strr_Mbn_File_List_Ext[mMbn_File_NUM].ul_File_Size = FindFileData.nFileSizeLow;
				this->m_strr_Mbn_File_List_Ext[mMbn_File_NUM].b_Enable_DL = true;
			}
			mMbn_File_NUM++;
		}
		if(!FindNextFile(hFind,&FindFileData))   
			break;//如果没有找到下一个文件，结束本次循环
	}
	FindClose(hFind);

	return true;
}
//AT+QFUPL="RAM:mcfg_sw.mbn",26280
bool CARM_OP_QCM::Set_MBN_Sent_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	// 	if(!this->m_cla_AT_Com_Port.Port_Open(i_TimeOut))
	// 	{
	// 		this->Show_Status(_T("Fail,AT PORT OPEN FAIL."));
	// 		return 0;
	// 	}

	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("CONNECT"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		// 		//提取AT返回数据
		// 		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);
		// 
		// 		//提取有用数据
		// 		CString csTemp;
		// 		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("CONNECT"), &csTemp) == false)
		// 		{
		// 			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
		// 			throw(0);
		// 		}
		//		this->m_cla_AT_Com_Port.Port_Close();

	}
	catch(...)
	{
		//		this->m_cla_AT_Com_Port.Port_Close();
		return 0;
	}
	return 1;

}

bool CARM_OP_QCM::Qfdel_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			//this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			//throw(0);
		}

		//提取AT返回数据
		//this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		//CString csTemp;
		//if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		//{
		//this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
		//throw(0);
		//}

	}
	catch(...)
	{
		return 0;
	}
	return 1;

}
void TEST_Send_File(LPVOID x);
void CARM_OP_QCM::OnSend_MBNFile() 
{
	//文件传输时是否显示由此控制
	this->m_bSending_File = true;
	this->m_bSendFileRes = false;

	this->Show_Status(_T(""));
	HANDLE hThread;
	DWORD dwThreadId;

	hThread = CreateThread(NULL,  
		0,     
		(LPTHREAD_START_ROUTINE)TEST_Send_File,
		(void *)this,  
		0,     
		&dwThreadId);
}

void TEST_Send_File(LPVOID x)
{
	CARM_OP_QCM *Sv = (CARM_OP_QCM *)x;

	Sv->m_bSendFileRes = Sv->Send_File(Sv->m_csMbnFilePath, FALSE, TRUE);

	Sv->m_bSending_File = false;

}

bool CARM_OP_QCM::Send_File(CString csPath, BOOL bHEX, BOOL bEnter)
{
	HANDLE FileHandle;
	DWORD TotalByte, numBytesRead;
	DWORD FinishSendByte = 0;
	DWORD blockSize = 350;
	unsigned char ucrTxBuffer[356];
	memset(ucrTxBuffer,0,sizeof(ucrTxBuffer));

	CString strData;

	try
	{
		FileHandle = CreateFile(csPath,
			GENERIC_READ,    // Read only required
			FILE_SHARE_READ, // read share file
			NULL,            // SecurityAttributes - none in Win95
			OPEN_EXISTING,   // how to create
			FILE_FLAG_SEQUENTIAL_SCAN,  // file attributes
			NULL             // handle of file with attributes to copy
			);

		if(FileHandle == INVALID_HANDLE_VALUE)
		{
			return false;
		}

		//Calculate number of blocks
		TotalByte = GetFileSize(FileHandle, NULL);



		//开始读取发送
		do
		{
			memset(ucrTxBuffer, 0, sizeof(ucrTxBuffer));
			numBytesRead = 0;

			if(!ReadFile(FileHandle, ucrTxBuffer, blockSize, &numBytesRead, NULL))
			{
				throw(0);
			}

			if(bHEX == TRUE)
			{
				char crCmd[1024];
				int iByte_2;
				int iError;

				//进行16进制转换
				do
				{
					memset(crCmd, 0, sizeof(crCmd));

					iError = this->View_HEX_Char_To_Signed_Char((char *)ucrTxBuffer, crCmd, iByte_2);

					if(iError == 0)
					{
						break;//转换成功
					}
					else if(iError == -3)//有效字符长度不是偶数，再读个新的补救
					{
						unsigned char ucrBuff[2];
						DWORD dwByteRead = 0;

						if(!ReadFile(FileHandle, ucrBuff, 1, &dwByteRead, NULL))
						{
							return false;
						}
						else
						{
							if(dwByteRead == 1)
							{
								ucrTxBuffer[numBytesRead] = ucrBuff[0];
								numBytesRead++;
								continue;//重新进行16进制转换
							}
							else
							{
								return false;
							}
						}
					}
					else
					{
						return false;//转换出错
					}
				}
				while(1);
				if(this->m_cla_AT_Com_Port.Write_Byte(crCmd,(unsigned long)iByte_2) == false)
				{
					this->m_csError_Code.Format(_T("FAIL, Send_Mbn_Pkt_Data_Ext Data Err"));
					throw(0);
				}
				//this->COM_Write(crCmd, (unsigned long)iByte_2);
			}
			else
			{
				if(this->m_cla_AT_Com_Port.Write_Byte((char *)ucrTxBuffer,numBytesRead) == false)
				{
					this->m_csError_Code.Format(_T("FAIL, Send_Mbn_Pkt_Data_Ext Data Err"));
					throw(0);
				}
				//this->COM_Write((char *)ucrTxBuffer, numBytesRead);
			}

			FinishSendByte += numBytesRead;

			Sleep(200);

			strData.Format(_T("Send MBN File %.1f%%"),((float)FinishSendByte / (float)TotalByte * 100.0));

			this->Show_Status(strData);

		}
		while(FinishSendByte < TotalByte);

		//提取AT返回数据
		//unsigned char * ucpRx_Buff = NULL;
		//unsigned long ulRx_Quan = 0;
		//bool ret =false;
		//ret = READ_BYTE(&ucpRx_Buff,&ulRx_Quan);


		//
		CloseHandle(FileHandle);
		//m_cla_AT_Com_Port.Port_Close();
		return true;
	}
	catch(...)
	{
		CloseHandle(FileHandle);
		//m_cla_AT_Com_Port.Port_Close();
		return false;
	}
}



bool CARM_OP_QCM::Add_MBN_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	// 	if(!this->m_cla_AT_Com_Port.Port_Open(i_TimeOut))
	// 	{
	// 		this->Show_Status(_T("Fail,AT PORT OPEN FAIL."));
	// 		return 0;
	// 	}

	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
			throw(0);
		}
		//		this->m_cla_AT_Com_Port.Port_Close();

	}
	catch(...)
	{
		//		this->m_cla_AT_Com_Port.Port_Close();
		return 0;
	}
	return 1;

}

//  [2017-10-12_19:57:42]+QMBNCFG: "List",0,0,0,"ROW_Generic_3GPP",0x05010814,201704141
//	[2017-10-12_19:57:42]+QMBNCFG: "List",1,1,1,"Telstra-Commercial_VoLTE",0x0580070D,201710111
bool CARM_OP_QCM::List_Op_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	CString  strOpName;
	// 	if(!this->m_cla_AT_Com_Port.Port_Open(i_TimeOut))
	// 	{
	// 		this->Show_Status(_T("Fail,AT PORT OPEN FAIL."));
	// 		return 0;
	// 	}

	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("QMBNCFG"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		csData = csData.MakeUpper();

		strOpName = m_strOpName;
		strOpName = strOpName.MakeUpper();
		if(-1 == csData.Find(strOpName))
		{
			AfxMessageBox(_T("Input Operator Name can't find in Moudle"));
		}

		//		this->m_cla_AT_Com_Port.Port_Close();

	}
	catch(...)
	{
		//		this->m_cla_AT_Com_Port.Port_Close();
		return 0;
	}
	return 1;

}

bool CARM_OP_QCM::Autosel_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	//
	CString strATCom,csData;
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
			throw(0);
		}

	}
	catch(...)
	{
		return 0;
	}
	return 1;
}

bool CARM_OP_QCM::Select_Op_In_AT(int i_TimeOut,CString strATCommand)
{
	//
	CString csCOM,strATCom,csData;
	int  iCom;
	// 	if(!this->m_cla_AT_Com_Port.Port_Open(i_TimeOut))
	// 	{f
	// 		this->Show_Status(_T("Fail,AT PORT OPEN FAIL."));
	// 		return 0;
	// 	}

	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCommand, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
			throw(0);
		}
		//		this->m_cla_AT_Com_Port.Port_Close();

	}
	catch(...)
	{
		//		this->m_cla_AT_Com_Port.Port_Close();
		return 0;
	}
	return 1;

}
int CARM_OP_QCM::View_HEX_Char_To_Signed_Char(char *cpHEX, char *cpData, int &iBytes)
{
	//DWORD是32位，char是8位，每8位按16进制显示是2位（FF），所以按16进制打印是8位的16进制位。
	try
	{
		//判定是否有数据
		int iLong = strlen(cpHEX);
		if(iLong <= 0)
		{
			*cpData = '\0';
			iBytes = 0;
			return 0;
		}

		//检查是否有非法字符
		int i;
		int i4Bit = 0;
		CString csData;

		csData.Format(_T("\0"));

		for(i=0; i<iLong; i++)
		{
			if(
				((*(cpHEX + i) >= '0') && (*(cpHEX + i) <= '9')) ||
				((*(cpHEX + i) >= 'a') && (*(cpHEX + i) <= 'f')) ||
				((*(cpHEX + i) >= 'A') && (*(cpHEX + i) <= 'F'))
				)
			{
				csData += *(cpHEX + i);//把有用的字符放进BUFF
			}
			else if((*(cpHEX + i) == ' ') || (*(cpHEX + i) == '\r') || (*(cpHEX + i) == '\n'))
			{
				continue;//空格是合法字符，但转换时会丢弃
			}
			else
			{
				continue;
				//
				//throw(-2);//非法字符，Fail
			}
		}

		i4Bit = csData.GetLength();

		if((i4Bit % 2) != 0)
		{
			throw(-3);//有效字符数必须是偶数，否则无法转换成8Bit的字符
		}

		char *d;
		char crTemp[16];
		int j;

		i4Bit = i4Bit / 2;//计算DWORD元素的数目

		for(j=0; j<i4Bit; j++)
		{
			memset(crTemp, 0, sizeof(crTemp));		
			crTemp[0] = '0';
			crTemp[1] = 'X';

			for(i=0; i<2; i++)
			{
				crTemp[i + 2] = csData.GetAt(j * 2 + i);
			}
			crTemp[4] = '\0';
			*(cpData + j) = strtoul(crTemp, &d, 16);
		}

		*(cpData + j) = '\0';
		iBytes = i4Bit;
		return 0;
	}
	catch(int a)
	{
		iBytes = 0;
		return a;
	}	
}

int CARM_OP_QCM::Execute_HONEYWELL(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code  = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\Honeywell_A4\\%d\\JLink.exe  \"%s\\Honeywell_A4\\%d\\eraseAndFlash.jlink\""),
			'/', this->m_csCurr_Exe_Path,m_iClass_Idx,this->m_csCurr_Exe_Path,m_iClass_Idx);
		
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code  = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有“Script file read successfully 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script file read successfully"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("script file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("script file read successfully"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Connecting to J-Link via USB...O.K”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("connecting to j-link via usb...o.k"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting usb ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("connecting to j-link via usb...o.k"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing device"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("erasing..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("erasing device"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing done"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if((wcpPercent != NULL)&&(NULL !=wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script processing completed"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code  = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code  = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
					this->m_iError_Code  = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}

int CARM_OP_QCM::Execute_QDE006_MCU2(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\Honeywell_A4\\%d\\JLink.exe  \"%s\\Honeywell_A4\\%d\\eraseAndFlash.jlink\""),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_csCurr_Exe_Path, m_iClass_Idx);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有“Script file read successfully 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script file read successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("script file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("script file read successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Connecting to J-Link via USB...O.K”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("connecting to j-link via usb...o.k"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting usb ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("connecting to j-link via usb...o.k"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("erasing..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("erasing device"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing done"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script processing completed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}
int CARM_OP_QCM::Execute_QDM002(void)
{
	int iDl_Flag;

	//iDl_Flag = this->Execute_QDM002_bootloader();
	//
	//if (RTN_FAIL == iDl_Flag)
	//{
	//	return RTN_FAIL;
	//}
	
	//iDl_Flag = this->Execute_QDM002_app_bin();

	iDl_Flag = this->Execute_QDM002_DL_Jlink();

	return iDl_Flag;
}
//
int CARM_OP_QCM::Execute_QDM002_DL_Jlink(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\JLink.exe  \"%s\\QDM002\\%d\\eraseAndFlash.jlink\""),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_csCurr_Exe_Path, m_iClass_Idx);

		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有“Script file read successfully 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script file read successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("script file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("script file read successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Connecting to J-Link via USB...O.K”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("connecting to j-link via usb...o.k"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting usb ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("connecting to j-link via usb...o.k"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("erasing..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("erasing device"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing done"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script processing completed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}

int CARM_OP_QCM::Execute_QDM002_bootloader(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 20;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download bootloader file ......"));
		this->Save_Trace_Log(_T("Download bootloader file ......"));
		this->Show_Out(_T("Download bootloader file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, bootloader, Create pipe fail!"));
			this->m_iError_Code  = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);

		//STVP_CmdLine.exe -BoardName=ST-LINK -Port=USB -ProgMode=SWD -Device=STM32F302x8 -erase -progress -FileProg=D:\38-QDM002-NA\EG91_NC_UARTtoCAN_V1.1_20201126.hex

		//------------------------------ 打包dos指令 ------------------------------
		//swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\STVP_CmdLine.exe -BoardName=ST-LINK -Port=USB -ProgMode=SWD -Device=STM32F302x8 -erase -progress -FileProg=%s -no_loop"),
		//	'/', this->m_csCurr_Exe_Path,m_iClass_Idx,this->m_str_Hex_E.cs_Path);
		//STM32_Programmer_CLI.exe - c port = SWD freq = 4000 - w D : \38 - QDM002 - NA\st_upgrade.bin 0x08000000 - v
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\STM32Cube\\bin\\STM32_Programmer_CLI.exe -c port=SWD freq=4000 -w %s 0x08000000 -v"),
			'/', this->m_csCurr_Exe_Path,m_iClass_Idx,this->m_str_Hex_N.cs_Path);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code  = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有Memory Programming 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("memory programming"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("Memory Programming ..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("memory programming"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Erasing memory”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing memory"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("Erasing memory..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing memory"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Download in Progress
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("download in progress"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("Download in Progress..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("Download in Progress"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Download verified successfully
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("download verified successfully"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("Download verified successfully"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);

					csTemp.Format(_T("Download verified successfully"));

					wcpPercent+=  csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					bSuccess_Flag = true;//fail
					break;//退出while
				}
				
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error: cannot identify the device"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code  = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Error: No STM32 target found!
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error: no stm32 target found!"));
				//
				if(wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Error: No STM32 target found!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Error: No STM32 target found!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Error: No STM32 target found!"));
					this->m_iError_Code  = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, bootloader, Time out!"));
					this->Save_Trace_Log(_T("FAIL, bootloader, Time out!"));
					this->m_iError_Code  = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}
int CARM_OP_QCM::Execute_QDM002_app_bin(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 20;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);

		//STVP_CmdLine.exe -BoardName=ST-LINK -Port=USB -ProgMode=SWD -Device=STM32F302x8 -erase -progress -FileProg=D:\38-QDM002-NA\EG91_NC_UARTtoCAN_V1.1_20201126.hex

		//------------------------------ 打包dos指令 ------------------------------
		//swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\STVP_CmdLine.exe -BoardName=ST-LINK -Port=USB -ProgMode=SWD -Device=STM32F302x8 -erase -progress -FileProg=%s -no_loop"),
		//	'/', this->m_csCurr_Exe_Path,m_iClass_Idx,this->m_str_Hex_E.cs_Path);
		//STM32_Programmer_CLI.exe - c port = SWD freq = 4000 - w D : \38 - QDM002 - NA\st_upgrade.bin 0x08007800 - v
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\STM32Cube\\bin\\STM32_Programmer_CLI.exe -c port=SWD freq=4000 -w %s 0x08007800 -v"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_str_Hex_E.cs_Path);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有Memory Programming 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("memory programming"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("Memory Programming ..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("memory programming"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Erasing memory”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing memory"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("Erasing memory..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing memory"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Download in Progress
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("download in progress"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("Download in Progress..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("Download in Progress"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Download verified successfully
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("download verified successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("Download verified successfully"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);

					csTemp.Format(_T("Download verified successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					bSuccess_Flag = true;//fail
					break;//退出while
				}

				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error: cannot identify the device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Error: No STM32 target found!
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error: no stm32 target found!"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Error: No STM32 target found!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Error: No STM32 target found!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Error: No STM32 target found!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Execute_QCM6125(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	bool bDL_Flag = true;


	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port, this->m_iCom_Port_Auto_Sec, 70);
			//成功找到端口1
			if (1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if (2 == iFlag)
			{
				this->m_iCom_Port = this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if (this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8953的QDLoader口”
		for (i = 0; i<iQDL_Port_Quan; i++)
		{
			if (this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8953的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if (bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			//保存当前使用QDLoader的COM口
			if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
			}

		}
		else
		{
			//切换到EDL模式
			if (this->Switch_EDL(&iQDLoader_Port) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if (this->DL_FW_V5_SM6115(iQDLoader_Port) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);

		//下载完成后去除当前使用QDLoader的COM口
		if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx - 1] = 0;
		}


		//PASS信息显示
		if (this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch (...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx - 1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V5_QCM6125(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if (this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_QCM6125_MBN_FILE_I]) == false)
		{
			//第一步是必须的
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if (this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_QCM6125_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if (this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_QCM6125_XML_FILE_I]) == false)
		{
			throw(3);
		}
		//20180507 del
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if (this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if (this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch (...)
	{
		return false;
	}

	return true;
}

int CARM_OP_QCM::Execute_SM4350(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	bool bDL_Flag = true;


	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port, this->m_iCom_Port_Auto_Sec, 70);
			//成功找到端口1
			if (1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if (2 == iFlag)
			{
				this->m_iCom_Port = this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if (this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8953的QDLoader口”
		for (i = 0; i<iQDL_Port_Quan; i++)
		{
			if (this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8953的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if (bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			//保存当前使用QDLoader的COM口
			if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
			}

		}
		else
		{
			//切换到EDL模式
			if (this->Switch_EDL(&iQDLoader_Port) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx - 1] = iQDLoader_Port;
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if (this->DL_FW_V5_SM4350(iQDLoader_Port) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);

		//下载完成后去除当前使用QDLoader的COM口
		if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx - 1] = 0;
		}


		//PASS信息显示
		if (this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch (...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if ((m_iClass_Idx>0) && (m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx - 1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V5_SM4350(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if (this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SM4350_ELF_FILE_I]) == false)
		{
			//第一步是必须的
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if (this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_SM4350_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if (this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_SM4350_XML_FILE_I]) == false)
		{
			throw(3);
		}
		//20180507 del
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if (this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if (this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch (...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_SM4350(const wchar_t * wcp_FW_File_Path)
{
	//SM4350
	//判定、加载SM4350的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for (j = 0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if (this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while (b_Found)
		{
			b_Found = cla_Finder.FindNextFile();

			if (cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if (!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .ELF 文件
				if (wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//挑出“prog_firehose_SM4350_ddr.elf”文件
					if (wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_SM4350_ELF_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SM4350_ELF_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SM4350_ELF_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if (wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if (wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_SM4350_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SM4350_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SM4350_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if (wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_SM4350_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SM4350_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SM4350_XML_FILE_I].b_Enable_DL = true;
					}
				}

#if  1
				//寻找 .img 文件
				if (wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if (wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_SM4350_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SM4350_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SM4350_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if (wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if (wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_SM4350_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SM4350_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SM4350_BIN_FILE_I].b_Enable_DL = true;
					}
				}
#endif

				//判定文件类型，载入.xqcn文件
				if (wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if (this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if (this->m_strr_Mbn_File_List[FIREHOSE_SM4350_ELF_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if (this->m_strr_Mbn_File_List[RAWPROG_SM4350_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if (this->m_strr_Mbn_File_List[PATCH0_SM4350_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch (...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

int CARM_OP_QCM::Execute_SM6115(void)
{
	CString csData;
	int i, iQDLoader_Port;
	int irQDL_Port_List[64], iQDL_Port_Quan;//所有“QDLoader”口的记录
	bool bEDL_Now = false;//是否“已经是EDL模式”

	bool bDL_Flag = true;


	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		//刷新COM参数
		this->Load_Com_Port_Params();

		//------------------------------ 检查COM口是否存在 ------------------------------ 
		// check port 是否存在
		//---------------------------------------------------------------------------------
		if (this->m_iCom_Port_Auto_Sec>0)//
		{
			//成功找到端口1
			int iFlag = 0;
			iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port,this->m_iCom_Port_Auto_Sec,70);
			//成功找到端口1
			if(1 == iFlag)
			{
				bDL_Flag = true;
			}
			//成功找到端口2
			else if(2 == iFlag)
			{
				this->m_iCom_Port= this->m_iCom_Port_Auto_Sec;
				this->m_DM_Port = this->m_iCom_Port_Auto_Sec;
				bDL_Flag = true;
			}
			else //两个端口都没找到
			{
				bDL_Flag = false;
			}
		}
		else
		{
			if(this->Confirm_Dynamic_Com_Port(this->m_iCom_Port,70) == false)
			{
				bDL_Flag = false;
			}
			else
			{
				bDL_Flag = true;
			}
		}

		if (false == bDL_Flag)
		{
			this->Show_Status(this->m_csError_Code);
			throw(1);
		}
		//刷新COM参数
		this->Load_Com_Port_Params();


		//------------------------------ 判断COM口是否已是“EDL的QDLoader口” ------------------------------ 
		//清空
		iQDL_Port_Quan = 0;
		memset(irQDL_Port_List, 0, sizeof(irQDL_Port_List));

		//读PC机存在的所有“QDLoader”口记录
		this->Read_Reg_USB_VID_PID_QDLoader_Port_Of_QUD(irQDL_Port_List, &iQDL_Port_Quan);

		//核对“当前串口”是不是已经是“8953的QDLoader口”
		for(i=0; i<iQDL_Port_Quan; i++)
		{
			if(this->m_iCom_Port == irQDL_Port_List[i])
			{
				//“当前串口”已经是“8953的QDLoader口”
				bEDL_Now = true;
				break;//已经是EDL模式
			}
		}//for(j=0; j<iQDL_Port_Quan; j++



		//确定下载用的“QDLoader口”
		if(bEDL_Now == true)
		{
			//已经是EDL模式
			iQDLoader_Port = this->m_iCom_Port;

			//保存当前使用QDLoader的COM口
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}

		}
		else
		{
			//切换到EDL模式
			if(this->Switch_EDL( &iQDLoader_Port ) == false)
			{
				this->Show_Status(this->m_csError_Code);
				throw(2);
			}
			//保存当前使用QDLoader的COM口
			if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
			{
				g_QDL_USE_Port_List[m_iClass_Idx-1] = iQDLoader_Port;
			}
		}


		//显示进度条 10%
		this->Show_Progress(0.1);

		//显示
		csData.Format(_T("EDL port %d"), iQDLoader_Port);
		this->Show_Status(csData);

		csData.Format(_T("QDLoader %d"), iQDLoader_Port);
		this->Show_COMPORT(csData);
		//
		Sleep(1500);
		//------------------------------



		//------------------------------ EDL下载FW操作 ------------------------------ 
		if(this->DL_FW_V5_SM6115( iQDLoader_Port ) == false)
		{
			throw(3);
		}
		//------------------------------



		//显示进度条 100%
		this->Show_Progress(1.0);

		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}


		//PASS信息显示
		if(this->m_bCEFS_DL == true)
		{
			this->Show_Status(_T("FW download success."));
		}
		else
		{
			this->Show_Status(_T("FW upgrade success."));
		}

	}
	catch(...)
	{
		//
		//下载完成后去除当前使用QDLoader的COM口
		if((m_iClass_Idx>0)&&(m_iClass_Idx<5))
		{
			g_QDL_USE_Port_List[m_iClass_Idx-1] = 0;
		}
		return RTN_FAIL;
	}

	//
	return RTN_SUCCESS;
}

bool CARM_OP_QCM::DL_FW_V5_SM6115(int i_QDLoader_Port)
{

	try
	{
		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if(this->QFIL_DL_Firehose_Programmer(i_QDLoader_Port, this->m_strr_Mbn_File_List[FIREHOSE_SM6115_MBN_FILE_I]) == false)
		{
			//第一步是必须的
			throw(1);
		}

		//显示进度条 20%
		this->Show_Progress(0.2);


		//2. Download the flat build to the eMMC flash of device
		if(this->QFIL_DL_Rawprogram(i_QDLoader_Port, this->m_strr_Mbn_File_List[RAWPROG_SM6115_XML_FILE_I]) == false)
		{
			throw(2);
		}

		//显示进度条 80%
		this->Show_Progress(0.8);


		//3. Apply the patch
		if(this->QFIL_DL_Patch(i_QDLoader_Port, this->m_strr_Mbn_File_List[PATCH0_SM6115_XML_FILE_I]) == false)
		{
			throw(3);
		}
		//20180507 del
#if 0
		//显示进度条 90%
		this->Show_Progress(0.9);

		//20180502
		//4-1. Reset the device if necessary
		if(this->QFIL_DL_Reset_Prepare(i_QDLoader_Port) == false)
		{
			throw(5);
		}


		//4. Reset the device if necessary
		if(this->QFIL_DL_Reset(i_QDLoader_Port) == false)
		{
			throw(4);
		}
		//下载完成后延时15秒
		Sleep(50000);
#endif
	}
	catch(...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_SM6115(const wchar_t * wcp_FW_File_Path)
{
	//SM6115
	//判定、加载SM6115的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for(j=0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for(j=0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if(this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while(b_Found) 
		{
			b_Found = cla_Finder.FindNextFile();

			if(cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if(!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .ELF 文件
				if(wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//挑出“prog_firehose_sm6115_ddr.elf”文件
					if(wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_SM6115_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SM6115_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_SM6115_MBN_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if(wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if(wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_SM6115_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SM6115_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_SM6115_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if(wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_SM6115_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SM6115_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_SM6115_XML_FILE_I].b_Enable_DL = true;
					}
				}

#if  1
				//寻找 .img 文件
				if(wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if(wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_SM6115_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SM6115_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_SM6115_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if(wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if(wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_SM6115_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SM6115_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_SM6115_BIN_FILE_I].b_Enable_DL = true;
					}
				}
#endif

				//判定文件类型，载入.xqcn文件
				if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if(this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if(this->m_strr_Mbn_File_List[FIREHOSE_SM6115_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[RAWPROG_SM6115_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if(this->m_strr_Mbn_File_List[PATCH0_SM6115_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch(...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}


bool CARM_OP_QCM::LOAD_FW_FILE_QCM6125(const wchar_t * wcp_FW_File_Path)
{
	//QCM6125
	//判定、加载QCM6125的FW文件中的“关键文件”

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir;
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for (j = 0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));



		//提取软件路径
		if (this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while (b_Found)
		{
			b_Found = cla_Finder.FindNextFile();

			if (cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if (!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写


				//寻找 .ELF 文件
				if (wcsstr(cs_FW_Name, _T(".ELF")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".ELF"), _T("\0"));

					//挑出“prog_firehose_Qcm6125_ddr.elf”文件
					if (wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_QCM6125_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_QCM6125_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_QCM6125_MBN_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .xml 文件
				if (wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if (wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_QCM6125_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_QCM6125_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_QCM6125_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if (wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_QCM6125_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_QCM6125_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_QCM6125_XML_FILE_I].b_Enable_DL = true;
					}
				}

#if  1
				//寻找 .img 文件
				if (wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if (wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_QCM6125_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_QCM6125_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_QCM6125_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if (wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if (wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_QCM6125_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_QCM6125_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_QCM6125_BIN_FILE_I].b_Enable_DL = true;
					}
				}
#endif

				//判定文件类型，载入.xqcn文件
				if (wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if (this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						//						this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();


		//检查是否找到“必需的文件”
		if (this->m_strr_Mbn_File_List[FIREHOSE_QCM6125_MBN_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
			throw(0);
		}
		if (this->m_strr_Mbn_File_List[RAWPROG_QCM6125_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
			throw(0);
		}
		if (this->m_strr_Mbn_File_List[PATCH0_QCM6125_XML_FILE_I].b_Enable_DL == false)
		{
			this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
			throw(0);
		}



		//软件包的路径
		this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);

	}
	catch (...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}



//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc_1(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc 1......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc 1......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 1, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 		
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 1, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc 1 "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 1 error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 1, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc_2(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc 2......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc 2......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 2 , Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=0 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 		
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=1 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 2, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc 2"));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 2 error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 2, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=2 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc_3(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc 3......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc 3......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 3 , Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=2 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 		
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=2 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 3, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc 3 "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 3 error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 3, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=4 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc_4(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc 4......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc 4......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 4, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=4 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 		
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=4 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 4, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc 4 "));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 4 error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 4, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=5 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 
bool CARM_OP_QCM::QFIL_DL_FHLoaderErase_Proc_5(int i_QDLoader_Port)
{
	//使用“fh_loader.exe”操作“FHLoaderErase.xml erase”

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 25;//20180226


	try
	{
		//显示
		this->Show_Status(_T("Download FHLoaderErase Proc 5......"));
		this->Save_Trace_Log(_T("Download FHLoaderErase Proc 5......"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if(CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 5, Create pipe fail!"));
			throw(1);
		}
		//------------------------------ 

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 512));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);

		//C:\Program Files (x86)\Qualcomm\QPST\bin\fh_loader.exe --port=\\.\COM279 --erase=5 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs 		
		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --erase=5 --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=ufs"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if(CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE) 
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 5, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while(bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if(ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_FHLoaderEraseProc 5"));
				//20180425
				//this->Save_Trace_Log(wcpData);
			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if(wcsstr(csTotal_Info, _T("error:")) != NULL)
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 5 error!"));
				throw(3);
			}


			//检查是否pass
			if(wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FHLoaderEraseProc 5, Time out!"));
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch(...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);



		//释放句柄的指针
		if(hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if(hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//at+quimslot=2 OK
//at+quimslot=1 OK
bool CARM_OP_QCM::Set_Quimslot(int iTag)
{
	//
	CString strATCom,csData;

	strATCom.Format(_T("at+quimslot=%d"),iTag);
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 3) == false)
		{
			throw(0);
		}

	}
	catch(...)
	{
		return false;
	}
	return true;

}

//AT+QCFG="usbnet",0  返回的是：OK
bool CARM_OP_QCM::Set_RMNET(void)
{
	wchar_t wcrData[128];
	int i, iRec_Bits;
	CString csCmd;
	try
	{
		//
		csCmd.Format(_T("AT+QCFG=\"usbnet\",0"));

		//写
		this->m_cla_AT_Com_Port.Write(csCmd);

		//读
		for (i = 0; i<15; i++)
		{
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(800);
			//
			this->m_cla_AT_Com_Port.Read(wcrData, &iRec_Bits, 100);

			//
			if (wcsstr(wcrData, _T("OK")) != NULL)
			{
				//
				return true;
			}
			else 
			{
				//可能开机时间不够
				Sleep(1200);
				//
				this->m_cla_AT_Com_Port.Write(csCmd);
			}
		}//for(i=0; i<15; i++
	}
	catch (...)
	{
		return false;
	}

	return false;
}

//AT+QCFG="usbnet"   返回的是：+QCFG:"usbnet",0 OK
bool CARM_OP_QCM::Get_RMNET(void)
{
	//
	CString strATCom, csData;

	strATCom.Format(_T("AT+QCFG=\"usbnet\""));
	try
	{
		//发送
		if (this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 3) == false)
		{
			throw(0);
		}
		//提取转化数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);


		if (NULL != wcsstr(csData, _T("\"usbnet\",0")))
		{
			///;
		}
		else
		{
			this->Save_Trace_Log(_T("Get_RMNET Fail Info:"));
			this->Show_Out(_T("Get_RMNET Info:"));

			this->Save_Trace_Log(csData);
			this->Show_Out(csData);
			throw(0);
		}

	}
	catch (...)
	{
		return false;
	}
	return true;

}


//AT+QUIMSLOT? QUIMSLOT: 2
//AT+QUIMSLOT? QUIMSLOT: 1
bool CARM_OP_QCM::Get_Quimslot(int iTag)
{
	//
	CString strATCom,csData;

	csData.Format(_T("%d"),iTag);

	strATCom.Format(_T("AT+QUIMSLOT?"));
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, csData, 5) == false)
		{
			throw(0);
		}

	}
	catch(...)
	{
		return false;
	}
	return true;

}

//AT+CSIM=26,"00A4040008A000000151000000"
//+CSIM: 4,"6184"
bool CARM_OP_QCM::Check_ESIM_1(void)
{
	//
	CString strATCom,csData;

	strATCom.Format(_T("AT+CSIM=26,\"00A4040008A000000151000000\""));
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 5) == false)
		{
			throw(0);
		}
		//提取转化数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);


		if (NULL !=  wcsstr(csData,_T("4,\"6184\"")))
		{
           ///;
		} 
		else
		{
			this->Save_Trace_Log(_T("Check_ESIM_1 Fail Info:"));
			this->Show_Out(_T("Check_ESIM_1 Fail Info:"));

			this->Save_Trace_Log(csData);
			this->Show_Out(csData);
			throw(0);
		}
	}
	catch(...)
	{
		return false;
	}
	return true;

}
//AT + QSIMCFG = "pn"    //查询PN号，即软件版本号
//+ QSIMCFG: "pn", WLCSP68-eUICC-MFO
//OK
bool CARM_OP_QCM::Check_PN(void)
{
	//
	int iLen = 0;
	CString strATCom, csData, csUseful;

	strATCom.Format(_T("AT+QSIMCFG =\"pn\""));
	try
	{
		//发送
		if (this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 5) == false)
		{
			throw(0);
		}
		//提取转化数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取号码数据
		if (this->m_cla_GFC.GET_AT_RSP_STRING(csData, _T("pn\","), 0, &csUseful) == true)
		{
			//
			csUseful.Remove(_T(' '));
			iLen = csUseful.Find(_T("pn\","));
			csUseful.Delete(0, (iLen + wcslen(_T("pn\","))));
			csUseful.Remove(_T('\"'));
			csUseful.Remove(_T(':'));
			csUseful.MakeUpper();

			this->Save_Trace_Log(csUseful);
			this->Show_Out(csUseful);

			if (0 == wcscmp(csUseful, _T("WLCSP68-EUICC-MFO")))
			{
				//////;
			}
			else
			{
				this->Save_Trace_Log(_T("Check_PN Fail Info:"));
				this->Show_Out(_T("Check_PN Fail Info:"));

				this->Save_Trace_Log(csData);
				this->Show_Out(csData);
				throw(0);
			}

		}
		else
		{
			throw(0);
		}
	}
	catch (...)
	{
		return false;
	}
	return true;

}
//AT + QSIMCFG = "os"    //查询OS版本
//+ QSIMCFG : "os", D1497223-B
//OK
bool CARM_OP_QCM::Check_OS(void)
{
	//
	int iLen = 0;
	CString strATCom, csData, csUseful;

	strATCom.Format(_T("AT+QSIMCFG =\"os\""));
	try
	{
		//发送
		if (this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 5) == false)
		{
			throw(0);
		}
		//提取转化数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取号码数据
		if (this->m_cla_GFC.GET_AT_RSP_STRING(csData, _T("os\","), 0, &csUseful) == true)
		{
			//
			csUseful.Remove(_T(' '));
			iLen = csUseful.Find(_T("os\","));
			csUseful.Delete(0, (iLen + wcslen(_T("os\","))));
			csUseful.Remove(_T('\"'));
			csUseful.Remove(_T(':'));
			csUseful.MakeUpper();

			this->Save_Trace_Log(csUseful);
			this->Show_Out(csUseful);

			if (0 == wcscmp(csUseful, _T("D1497223-B")))
			{
				//////;
			}
			else
			{
				this->Save_Trace_Log(_T("Check_OS Fail Info:"));
				this->Show_Out(_T("Check_OS Fail Info:"));

				this->Save_Trace_Log(csData);
				this->Show_Out(csData);
				throw(0);
			}

		}
		else
		{
			throw(0);
		}
	}
	catch (...)
	{
		return false;
	}
	return true;

}


//AT+CSIM=10,"80CA004200"
//+CSIM: 48,"4214574C43535036382D65554943432D4D464FFFFFFF9000"
bool CARM_OP_QCM::Check_ESIM_2(void)
{
	//
	int iLen =0;
	CString strATCom,csData,csUseful;

	strATCom.Format(_T("AT+CSIM=10,\"80CA004200\""));
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 5) == false)
		{
			throw(0);
		}
		//提取转化数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取号码数据
		if (this->m_cla_GFC.GET_AT_RSP_STRING(csData, _T("48,\""), 0, &csUseful) == true)
		{
			//
			csUseful.Remove(_T(' '));
			iLen = csUseful.Find(_T("48,\""));
			csUseful.Delete(0, (iLen + wcslen(_T("48,\""))));
			csUseful.Remove(_T('\"'));
			csUseful.Remove(_T(':'));
			csUseful.MakeUpper();

			this->Save_Trace_Log(csUseful);
			this->Show_Out(csUseful);

			if (0 ==  wcscmp(csUseful,_T("4214574C43535036382D65554943432D4D464FFFFFFF9000")))
			{
				//////;
			} 
			else
			{
				this->Save_Trace_Log(_T("Check_ESIM_2 Fail Info:"));
				this->Show_Out(_T("Check_ESIM_2 Fail Info:"));

				this->Save_Trace_Log(csData);
				this->Show_Out(csData);
				throw(0);
			}

		}
		else
		{
			throw(0);
		}


		
	}
	catch(...)
	{
		return false;
	}
	return true;

}




bool CARM_OP_QCM::Get_EID(void)
{
	// AT+QSIMCFG="eid"
	// +QSIMCFG: "eid",89033023424310000000001168683879
	// OK
	//
	CString strATCom,csData;

	strATCom.Format(_T("AT+QSIMCFG=\"eid\""));
	try
	{
		//发送
		if(this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 3) == false)
		{
			throw(0);
		}
		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if(this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T("\"eid\","), _T("OK"), &this->m_strEID) == false)
		{
			throw(0);
		}
		this->m_strEID.Replace(_T("\r"),_T(""));
		this->m_strEID.Replace(_T("\n"),_T(""));

	}
	catch(...)
	{
		return false;
	}
	return true;

}

bool CARM_OP_QCM::Q_DL_QBhiServer()
{
	//使用“QBhiServer.exe”下载“Firehose”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	int iTimeout = 30;//延时20,秒 20170608


	try
	{
		//显示
		csData.Format(_T("[INFO] DL_QBhiServer ......"));
		this->Show_Status(csData);
		this->Save_Trace_Log(csData);


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			csData.Format(_T("[FAIL] DL_QBhiServer, Create pipe fail"));

			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create pipe fail!"));
			this->m_iError_Code = DL_QBhiServer_fail1;

			throw(1);
		}
		//------------------------------ 
		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (m_csCurr_Exe_Path.GetLength() + this->m_strFirehoseFullPath.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\QBhiServer.exe -pushimage \"%s\""),
			'/', m_csCurr_Exe_Path, m_iClass_Idx, m_strFirehoseFullPath);

		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			csData.Format(_T("[FAIL] DL_QBhiServer, Create process fail"));
			this->m_csError_Code = csData;
			this->m_iError_Code = DL_QBhiServer_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 

		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。

			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;

			}//if(ulActual_Read > 0

			this->Save_Trace_Log(csTotal_Info);

			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("fail")) != NULL)
			{
				csData.Format(_T("[FAIL] DL_QBhiServer, Fail"));
				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(csData);
				this->m_iError_Code = DL_QBhiServer_fail3;

				throw(3);
			}
			else if (wcsstr(csTotal_Info, _T("error:")) != NULL)
			{

				csData.Format(_T("[FAIL] DL_QBhiServer, error"));
				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(csData);
				this->m_iError_Code = DL_QBhiServer_Error;

				throw(4);
			}


			//检查是否pass
			if ((wcsstr(csTotal_Info, _T("done sending the image")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				csData.Format(_T("[FAIL] DL_QBhiServer, Time out"));
				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(csData);
				this->m_iError_Code = DL_QBhiServer_TimeOut;

				throw(5);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		////延迟3秒
		for (iTemp = 1; iTemp <= 2; iTemp++)
		{
			csData.Format(_T("[INFO] DL_QBhiServer, wait for %d seconds ......"), (3 - iTemp));

			this->Show_Status(csData);
			//
			Sleep(1100);
		}

		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//


	}
	catch (...)
	{
		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
//检测统计存在UDE AT口
bool CARM_OP_QCM::Detect_PCIE_UDE_Port(int iTimeOut)
{
	CString csData;
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int  i, j;
	bool bAT_Get_Success = false;
	bool bDetectPortFlag = false;

	bool bQDloader_Get_Success = false;
	i = 0;
	//
	try
	{
		do
		{
			//
			i++;
			//
			Sleep(1100);

			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);

			//
			for (j = 0; j < asi.GetSize(); j++)
			{
				if (wcsstr(asi[j].strPortDesc, _T("UDE AT")) != NULL)
				{
					//
					bAT_Get_Success = true;
				}	
			}

			//
			if (true == bAT_Get_Success)
			{
				bDetectPortFlag = true;

				break;
			}
			else
			{
				//
				if (i >= iTimeOut)
				{
					//this->Show_REdit_Info(_T("[FAIL] Detect Port Fail"), true);
					bDetectPortFlag = false;
					throw(0);
				}
			}
		} while (true);
	}
	catch (...)
	{
		return bDetectPortFlag;
	}

	return bDetectPortFlag;
}

//
//注意必须要管理员权限打开工具
bool CARM_OP_QCM::_W_PCIE_Rescan(int i_TimeOut)
{
	//使用“devcon.exe”刷新端口

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csCmd;
	int iTemp;
	bool bSuccess_Flag = false;

	try
	{
		//显示
		csData.Format(_T("[INFO] Rescan Port ......"));
		this->Show_Out(csData);

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			csData.Format(_T("[FAIL]Rescan Port, Create pipe fail"));
			this->Show_Out(csData);
			throw(1);
		}
		Sleep(500);
		//------------------------------ 
		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + 128));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		//------------------------------ 打包dos指令 ------------------------------ 
		swprintf(wcpCmd, _T("cmd.exe cd %s %cc devcon rescan"),
			this->m_csCurr_Exe_Path, '/');
		csCmd.Format(_T("%s"), wcpCmd);
		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			csData.Format(_T("[FAIL]Rescan Port, Create process fail"));
			this->Show_Out(csData);
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 

		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//csData.Replace ( _T ( '\r' ) , _T ( ' ' ) );
				//csData.Replace ( _T ( '\n' ) , _T ( ' ' ) );


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				//this->Show_Status_In_Each(wcpData, _T("DL-Firehose "));
			}//if(ulActual_Read > 0


			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("failed")) != NULL)
			{
				csData.Format(_T("[FAIL]Rescan Port, error"));
				this->Show_Out(csData);
				throw(3);
			}


			//检查是否pass
			if ((wcsstr(csTotal_Info, _T("completed")) != NULL))
			{
				bSuccess_Flag = true;//pass
				break;//退出while
			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= i_TimeOut)//超时，报fail
			{
				csData.Format(_T("[FAIL]Rescan Port, Time out"));
				this->Show_Out(csData);
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		return false;
	}

	//
	return true;
}
bool CARM_OP_QCM::Confirm_NO_PCIE_Port(int i_TimeOut)
{
	time_t start, end;
	CString csData;
	int iTimeOut;
	int i = 0, j = 0;

	try
	{
		iTimeOut = 30;

		time(&start);
		//
		do
		{
			i++;

			//先将口刷掉，判断是否已经没口了
			if (false == this->_W_PCIE_Rescan(10))
			{
				csData.Format(_T("Pre_Rescan_PCIE_Port_%d_Times, Rescan fail"), i + 1);
				this->Show_Out(csData);
			}
			else
			{
				csData.Format(_T("Pre_Rescan_PCIE_Port_%d_Times, Rescan pass"), i + 1);
				this->Show_Out(csData);


				if (this->Detect_PCIE_UDE_Port(10) == true)
				{
					//当搜到有口，代表没有刷掉，继续去刷
					csData.Format(_T("Pre_Rescan_PCIE_Port,Port holds"));
					this->Show_Out(csData);
				}
				else
				{
					//
					csData.Format(_T("Pre_Rescan_PCIE_Port_Times,No Port"));
					this->Show_Out(csData);

					break;
				}
			}

			Sleep(1000);

			//
			time(&end);

			if ((int)difftime(end, start) >= iTimeOut)
			{
				throw(0);
			}

		} while (true);
	}
	catch (...)
	{
		return false;
	}
	//
	return true;
}

//...
bool CARM_OP_QCM::Confirm_PCIE_Port(int i_TimeOut)
{
	time_t start, end;
	CString csData;
	int iTimeOut;
	int i = 0, j = 0;

	try
	{
		iTimeOut = 30;

		time(&start);
		//
		do
		{
			i++;

			//先将口刷新，判断是否已经有口了
			if (false == this->_W_PCIE_Rescan(10))
			{
				csData.Format(_T("Confirm_PCIE_Port_%d_Times, Rescan fail"), i + 1);
				this->Show_Out(csData);
			}
			else
			{
				csData.Format(_T("Confirm_PCIE_Port_%d_Times, Rescan pass"), i + 1);
				this->Show_Out(csData);


				if (this->Detect_PCIE_UDE_Port(10) == true)
				{
					//当搜到有口，代表没有刷掉，继续去刷
					csData.Format(_T("Confirm_PCIE_Port,OK"));
					this->Show_Out(csData);
					break;
				}
				else
				{
					//
					csData.Format(_T("Confirm_PCIE_Port,No Port"));
					this->Show_Out(csData);		
				}
			}

			Sleep(1000);

			//
			time(&end);

			if ((int)difftime(end, start) >= iTimeOut)
			{
				throw(0);
			}

		} while (true);
	}
	catch (...)
	{
		return false;
	}
	//
	return true;
}
//检测是否存在PCIE DM口
bool CARM_OP_QCM::Detect_UDE_DM_Port()
{
	CString csData;
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int ii, i, j;
	bool bAT_Get_Success = false;
	bool bDM_Get_Success = false;
	bool bDetectPortFlag = false;

	//
	i = 0;
	//
	try
	{
		do
		{
			//
			i++;
			//
			Sleep(1100);

			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);

			//
			for (j = 0; j < asi.GetSize(); j++)
			{
				if (wcsstr(asi[j].strPortDesc, _T("UDE AT")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iAT_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect UDE AT Port%d"), this->m_iAT_Port);
					this->Show_Out(csData);

					//
					bAT_Get_Success = true;
				}
				if (wcsstr(asi[j].strPortDesc, _T("UDE DM")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iCom_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect DM Port%d"), this->m_iCom_Port);
					this->Show_Out(csData);

					//
					bDM_Get_Success = true;
				}
				//
				if ((true == bAT_Get_Success)
					&& (true == bDM_Get_Success))
				{
					bDetectPortFlag = true;

					break;
				}
			}
			//显示
			csData.Format(_T("[INFO] Detect UDE Port......%d"), (40 - i));
			this->Show_Status(csData);
			//
			if ((true == bAT_Get_Success)
				&& (true == bDM_Get_Success))
			{
				break;
			}
			else
			{
				//
				if (i >= 40)
				{
					bDetectPortFlag = false;
					throw(0);
				}
			}
		} while (true);
	}
	catch (...)
	{
		return bDetectPortFlag;
	}

	return bDetectPortFlag;
}

//...
bool CARM_OP_QCM::Confirm_PCIE_UDE_EDL_Port(int i_TimeOut)
{
	time_t start, end;
	CString csData;
	int iTimeOut;
	int i = 0, j = 0;

	try
	{
		iTimeOut = 30;

		time(&start);
		//
		do
		{
			i++;

			//先将口刷新，判断是否已经有口了
			if (false == this->_W_PCIE_Rescan(10))
			{
				csData.Format(_T("Confirm_PCIE_UDE_EDL_Port_%d_Times, Rescan fail"), i + 1);
				this->Show_Out(csData);
			}
			else
			{
				csData.Format(_T("Confirm_PCIE_UDE_EDL_Port_%d_Times, Rescan pass"), i + 1);
				this->Show_Out(csData);


				if (this->Detect_PCIE_UDE_EDL_Port(10) == true)
				{
					//当搜到有口，代表没有刷掉，继续去刷
					csData.Format(_T("Confirm_PCIE_UDE_EDL_Port,OK"));
					this->Show_Out(csData);
					break;
				}
				else
				{
					//
					csData.Format(_T("Confirm_PCIE_UDE_EDL_Port,No Port"));
					this->Show_Out(csData);
				}
			}

			Sleep(1000);

			//
			time(&end);

			if ((int)difftime(end, start) >= iTimeOut)
			{
				throw(0);
			}

		} while (true);
	}
	catch (...)
	{
		return false;
	}
	//
	return true;
}
//检测统计存在UDE EDL口
bool CARM_OP_QCM::Detect_PCIE_UDE_EDL_Port(int iTimeOut)
{
	CString csData;
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int  i, j;
	bool bQDloader_Get_Success = false;
	i = 0;
	//
	try
	{
		do
		{
			//
			i++;
			//
			Sleep(1100);

			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);

			//
			for (j = 0; j < asi.GetSize(); j++)
			{
				if (wcsstr(asi[j].strPortDesc, _T("UDE EDL")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iCom_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect UDE EDL Port%d"), this->m_iCom_Port);
					this->Show_Out(csData);

					//
					bQDloader_Get_Success = true;
				}
			}

			//
			if (true == bQDloader_Get_Success)
			{
				bQDloader_Get_Success = true;

				break;
			}
			else
			{
				//
				if (i >= iTimeOut)
				{
					//this->Show_REdit_Info(_T("[FAIL] Detect Port Fail"), true);
					bQDloader_Get_Success = false;
					throw(0);
				}
			}
		} while (true);
	}
	catch (...)
	{
		return false;
	}

	return true;
}

//...
bool CARM_OP_QCM::Confirm_PCIE_UDE_AT_Port(int i_TimeOut)
{
	time_t start, end;
	CString csData;
	int iTimeOut;
	int i = 0, j = 0;

	try
	{
		iTimeOut = 30;

		time(&start);
		//
		do
		{
			i++;

			//先将口刷新，判断是否已经有口了
			if (false == this->_W_PCIE_Rescan(10))
			{
				csData.Format(_T("Confirm_PCIE_UDE_AT_Port_%d_Times, Rescan fail"), i + 1);
				this->Show_Out(csData);
			}
			else
			{
				csData.Format(_T("Confirm_PCIE_UDE_AT_Port_%d_Times, Rescan pass"), i + 1);
				this->Show_Out(csData);


				if (this->Detect_PCIE_UDE_AT_Port(10) == true)
				{
					//当搜到有口，代表没有刷掉，继续去刷
					csData.Format(_T("Confirm_PCIE_AT_EDL_Port,OK"));
					this->Show_Out(csData);
					break;
				}
				else
				{
					//
					csData.Format(_T("Confirm_PCIE_UDE_AT_Port,No Port"));
					this->Show_Out(csData);
				}
			}

			Sleep(1000);

			//
			time(&end);

			if ((int)difftime(end, start) >= iTimeOut)
			{
				throw(0);
			}

		} while (true);
	}
	catch (...)
	{
		return false;
	}
	//
	return true;
}
//检测统计存在UDE AT口
bool CARM_OP_QCM::Detect_PCIE_UDE_AT_Port(int iTimeOut)
{
	CString csData;
	//
	CArray<SSerInfo, SSerInfo&> asi;
	int  i, j;
	bool bAT_Get_Success = false;
	i = 0;
	//
	try
	{
		do
		{
			//
			i++;
			//
			Sleep(1100);

			// Populate the list of serial ports.
			EnumSerialPorts(asi, FALSE);

			//
			for (j = 0; j < asi.GetSize(); j++)
			{
				if (wcsstr(asi[j].strPortDesc, _T("UDE AT")) != NULL)
				{
					csData.Format(_T("[INFO] %s"), asi[j].strPortDesc);

					this->Show_Out(csData);

					//发现目标
					this->m_iAT_Port = _wtoi(asi[j].strPortName);
					//显示
					csData.Format(_T("[INFO] Detect UDE AT Port%d"), this->m_iAT_Port);
					this->Show_Out(csData);

					//
					bAT_Get_Success = true;
				}
			}

			//
			if (true == bAT_Get_Success)
			{
				bAT_Get_Success = true;

				break;
			}
			else
			{
				//
				if (i >= iTimeOut)
				{
					//this->Show_REdit_Info(_T("[FAIL] Detect Port Fail"), true);
					bAT_Get_Success = false;
					throw(0);
				}
			}
		} while (true);
	}
	catch (...)
	{
		return false;
	}

	return true;
}

bool CARM_OP_QCM::LOAD_FW_FILE_V3_Ext(const wchar_t * wcp_FW_File_Path)
{
	//MSM8909
	//判定该高通FW路径下有多少可用FW文件

	CString cs_Finder_Dir, cs_FW_Name, cs_FW_Path, cs_FW_Dir, cs_FW_Fire_hoseDir;
	HEX_FILE_S strr_Hex_File[2];
	CFileFind cla_Finder; //文件查找类
	BOOL b_Found;
	int j;


	try
	{
		//--------------------------------------- 开始解析信息，载入高通下载文件 --------------------------------------- 
		//清空高通下载用文件列表
		this->m_str_Mbn_Emerg.cs_Name.Format(_T(""));
		this->m_str_Mbn_Emerg.cs_Path.Format(_T(""));
		this->m_str_Mbn_Emerg.b_Enable_DL = false;
		this->m_str_Mbn_Norm.cs_Name.Format(_T(""));
		this->m_str_Mbn_Norm.cs_Path.Format(_T(""));
		this->m_str_Mbn_Norm.b_Enable_DL = false;

		this->m_str_Mbn_Partition_Table.cs_Name.Format(_T("partition_nand"));
		this->m_str_Mbn_Partition_Table.cs_Path.Format(_T(""));
		this->m_str_Mbn_Partition_Table.b_Enable_DL = false;

		this->m_str_Mbn_PT_2.cs_Name.Format(_T("partition-2"));
		this->m_str_Mbn_PT_2.cs_Path.Format(_T(""));
		this->m_str_Mbn_PT_2.b_Enable_DL = false;
		this->m_str_Mbn_PT_2.ul_File_Size = 0;

		this->m_str_Mbn_CEFS.cs_Name.Format(_T("0:EFS2"));
		this->m_str_Mbn_CEFS.cs_Path.Format(_T(""));
		this->m_str_Mbn_CEFS.b_Enable_DL = false;

		this->m_str_Mbn_QCN_DL.cs_Name.Format(_T("XQCN-A"));
		this->m_str_Mbn_QCN_DL.cs_Path.Format(_T(""));
		this->m_str_Mbn_QCN_DL.b_Enable_DL = false;

		for (j = 0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_YAFFS2_FILE; j++)
		{
			this->m_strr_Yaffs2_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Yaffs2_File_List[j].b_Enable_DL = false;
		}

		for (j = 0; j<MAX_IMG_FILE; j++)
		{
			this->m_strr_Img_File_List[j].cs_Name.Format(_T(""));
			this->m_strr_Img_File_List[j].cs_Path.Format(_T(""));
			this->m_strr_Img_File_List[j].b_Enable_DL = false;
		}

		this->m_str_Yaffs_Head_aa.cs_Name.Format(_T("yaffs_head.aa"));
		this->m_str_Yaffs_Head_aa.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_aa.b_Enable_DL = false;

		this->m_str_Yaffs_Head_ab.cs_Name.Format(_T("yaffs_head.ab"));
		this->m_str_Yaffs_Head_ab.cs_Path.Format(_T(""));
		this->m_str_Yaffs_Head_ab.b_Enable_DL = false;

		//
		this->m_csPartition_XML_File.Format(_T(""));

		this->m_str_partition_complete.cs_Name.Format(_T(""));
		this->m_str_partition_complete.cs_Path.Format(_T(""));
		this->m_str_partition_complete.b_Enable_DL = false;


		//提取软件路径
		if (this->m_cla_GFC.Get_File_Directory(wcp_FW_File_Path, &cs_FW_Dir) == false)
		{
			this->m_csError_Code.Format(_T("Error, Get mbn file directory fail!"));
			throw(0);
		}

		//寻找文件开始
		cs_Finder_Dir.Format(_T("%s\\*"), cs_FW_Dir);

		b_Found = cla_Finder.FindFile(cs_Finder_Dir);

		while (b_Found)
		{
			b_Found = cla_Finder.FindNextFile();

			if (cla_Finder.IsDots())
			{
				continue;//找到的是当前目录或上级目录则跳过
			}

			if (!cla_Finder.IsDirectory())	//如果不是文件夹，便是文件
			{
				cs_FW_Name.Format(_T("%s"), cla_Finder.GetFileName());//获取找到的文件名

				cs_FW_Name.MakeUpper();//统一大写

				//寻找 .xml 文件
				if (wcsstr(cs_FW_Name, _T(".XML")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".XML"), _T("\0"));

					//挑出“rawprogram_unsparse.xml”文件
					if (wcsstr(cs_FW_Name, _T("RAWPROGRAM_")) != NULL)
					{
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].b_Enable_DL = true;
					}

					//挑出“patch0.xml”文件
					if (wcsstr(cs_FW_Name, _T("PATCH0")) != NULL)
					{
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].b_Enable_DL = true;
					}
					//

					//寻找 partition_nand.xml 文件
					if (wcsstr(cs_FW_Name, _T("PARTITION")) != NULL)
					{
						this->m_csPartition_XML_File.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
					}
					
				}


				//寻找 .img 文件
				if (wcsstr(cs_FW_Name, _T(".IMG")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".IMG"), _T("\0"));

					//挑出“fs_image.tar.gz.mbn.img”文件
					if (wcsstr(cs_FW_Name, _T("FS_IMAGE")) != NULL)
					{
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FS_IMAGE_8909_IMG_FILE_I].b_Enable_DL = true;
					}
				}


				//寻找 .bin 文件
				if (wcsstr(cs_FW_Name, _T(".BIN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".BIN"), _T("\0"));

					//挑出“zero.bin”文件
					if (wcsstr(cs_FW_Name, _T("ZERO")) != NULL)
					{
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[ZERO_8909_BIN_FILE_I].b_Enable_DL = true;
					}
				}

				//寻找 mbn 驱动文件
				if (wcsstr(cs_FW_Name, _T(".MBN")) != NULL)
				{
					//去掉文件类型显示
					cs_FW_Name.Replace(_T(".MBN"), _T("\0"));

					//------------------------------------------
					//挑出“prog_emmc_firehose_8909_ddr”文件
				
					if (wcsstr(cs_FW_Name, _T("FIREHOSE_")) != NULL)
					{
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].b_Enable_DL = true;

						//保存全路径
						this->m_strFirehoseFullPath.Format(_T("%s"), this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].cs_Path);
						//重要标志---9X07不一样
						m_iMDM9X07_NEW_FLAG =1;
					}
					//}


					//挑出“ENPRG8909.mbn”文件
					if (wcscmp(cs_FW_Name, _T("ENPRG8909")) == 0)
					{
						this->m_str_Mbn_Emerg.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Emerg.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Emerg.b_Enable_DL = true;
						//重要标志---9X07不一样
						m_iMDM9X07_NEW_FLAG = 0;
					}


					//挑出“NPRG8909.mbn”文件
					if (wcscmp(cs_FW_Name, _T("NPRG8909")) == 0)
					{
						this->m_str_Mbn_Norm.cs_Name.Format(_T("%s"), cs_FW_Name);
						this->m_str_Mbn_Norm.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_Norm.b_Enable_DL = true;

						//重要标志---9X07不一样
						m_iMDM9X07_NEW_FLAG = 0;
					}

					if (wcsstr(cs_FW_Name, _T("CEFS")) != NULL)//判断是不是“cefs.mbn”
					{
						//加载数据
						this->m_str_Mbn_CEFS.cs_Name.Format(_T("%s"), cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_CEFS.b_Enable_DL = true;
					}
				}


				//判定文件类型，载入.xqcn文件
				if (wcsstr(cs_FW_Name, _T(".XQCN")) != NULL)
				{
					if (this->m_str_Mbn_QCN_DL.b_Enable_DL == true)
					{
						this->m_csError_Code.Format(_T("ERROR, There are more than 1 qcn file!"));
						throw(0);
					}
					else
					{
						this->m_str_Mbn_QCN_DL.cs_Path.Format(_T("%s\\%s"), cs_FW_Dir, cla_Finder.GetFileName());
						this->m_str_Mbn_QCN_DL.b_Enable_DL = true;
					}
				}//if(wcsstr(cs_FW_Name, _T(".XQCN")) != NULL
			}
		}//while(b_Found

		//关闭find
		cla_Finder.Close();

		if (1 == m_iMDM9X07_NEW_FLAG)
		{

			//检查是否找到“必需的文件”
			if (this->m_strr_Mbn_File_List[FIREHOSE_8909_MBN_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No firehose file!"));
				throw(0);
			}
			if (this->m_strr_Mbn_File_List[RAWPROG_8909_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No rawprogram file!"));
				throw(0);
			}
			if (this->m_strr_Mbn_File_List[PATCH0_8909_XML_FILE_I].b_Enable_DL == false)
			{
				this->m_csError_Code.Format(_T("FAIL, No patch0 file!"));
				throw(0);
			}
			//软件包的路径
			this->m_csFW_File_Path.Format(_T("%s"), cs_FW_Dir);
		}
		else
		{
			//检查是否找到文件
			if (this->m_csPartition_XML_File.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No partition_nand.xml file!"));
				this->Show_Out(_T("FAIL, No partition_nand.xml file!"));
				throw(0);
			}
			if (this->m_str_Mbn_Emerg.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No ENPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No ENPRG9x07.mbn file!"));
				throw(0);
			}
			if (this->m_str_Mbn_Norm.cs_Path.GetLength() <= 0)
			{
				this->m_csError_Code.Format(_T("FAIL, No NPRG9x07.mbn file!"));
				this->Show_Out(_T("FAIL, No NPRG9x07.mbn file!"));
				throw(0);
			}

			//从“partition_nand.xml”文件中解析“下载文件”
			if (this->Load_Partition_Xml_Data(this->m_csPartition_XML_File, cs_FW_Dir) == false)
			{
				this->Show_Out(_T("FAIL, Load_Partition_Xml_Data"));
				throw(0);
			}
		}

		//cefs文件要特殊处理，判定下文件是否存在。若不存在，则不下载
		if (this->m_str_Mbn_CEFS.b_Enable_DL == true)
		{
			if (this->Get_File_Size(this->m_str_Mbn_CEFS.cs_Path, &this->m_str_Mbn_CEFS.ul_File_Size) == false)
			{
				this->m_str_Mbn_CEFS.b_Enable_DL = false;
			}
		}

	}
	catch (...)
	{
		this->Show_Status(this->m_csError_Code);
		//
		return false;
	}

	//
	return true;
}

//高通平台的5G的efuse
int CARM_OP_QCM::QUALCOMM_PCIE_EFUSE(void)
{
	CString csCOM;
	int ieFuseQDLoader_Port = 0;
	CString cs_FW_Dir1,cs_FW_Dir2,cs_FW_Dir3;

	try
	{
		this->m_iCom_Port = this->m_iCom_Port_Auto_Sec;
		this->m_cla_Com_Port.m_iPort = this->m_iCom_Port;
		this->m_cla_Com_Port.m_iBaudRate = 115200;

		//-------------------------------------------------------------
		if (this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 70) == false)
		{
			throw(1);
		}
		csCOM.Format(_T("eFuse DM %d"), this->m_iCom_Port);
		Show_COMPORT(csCOM);
		Save_Trace_Log(csCOM);
		this->Show_Status(csCOM);
		this->Show_Out(csCOM);

		//-------------------------------------------------------------
		//切换到EDL模式
		if (this->Switch_EDL(&ieFuseQDLoader_Port) == false)
		{
			this->Show_Status(this->m_csError_Code);
			this->m_iError_Code = 0x00000075;
			throw(2);
		}
		else
		{
			//虽找到后Qloader口可能还没准备好 20180508
			Sleep(3000);
		}
		//刷新端口的显示
		csCOM.Format(_T("eFuse QDLoader %d"), ieFuseQDLoader_Port);
		Show_COMPORT(csCOM);
		Save_Trace_Log(csCOM);
		//-------------------------------------------------------------

		for (int j = 0; j<MAX_MBN_FILE; j++)
		{
			this->m_strr_Mbn_File_List_efuse[j].cs_Name.Format(_T(""));
			this->m_strr_Mbn_File_List_efuse[j].cs_Path.Format(_T(""));
			this->m_strr_Mbn_File_List_efuse[j].b_Enable_DL = false;
		}

		this->m_csFW_File_Path_efuse.Format(_T("%s\\QCMM\\SDX55_SEC_ONLY_20190924\\update\\firehose"), m_csCurr_Exe_Path);

		cs_FW_Dir1.Format(_T("%s\\QCMM\\SDX55_SEC_ONLY_20190924\\update\\firehose\\prog_firehose_sdx55.mbn"), m_csCurr_Exe_Path);
		cs_FW_Dir2.Format(_T("%s\\QCMM\\SDX55_SEC_ONLY_20190924\\update\\firehose\\rawprogram_nand_p4K_b256K_factory.xml"), m_csCurr_Exe_Path);
		cs_FW_Dir3.Format(_T("%s\\QCMM\\SDX55_SEC_ONLY_20190924\\update\\firehose\\patch_p4K_b256K.xml"), m_csCurr_Exe_Path);
		
		Save_Trace_Log(this->m_csFW_File_Path_efuse);
		Save_Trace_Log(cs_FW_Dir1);
		Save_Trace_Log(cs_FW_Dir2);
		Save_Trace_Log(cs_FW_Dir2);

		this->m_strr_Mbn_File_List_efuse[FIREHOSE_9X07_MBN_FILE_I].cs_Name.Format(_T("prog_firehose_sdx55.mbn"));
		this->m_strr_Mbn_File_List_efuse[FIREHOSE_9X07_MBN_FILE_I].cs_Path.Format(_T("%s"), cs_FW_Dir1);
		this->m_strr_Mbn_File_List_efuse[FIREHOSE_9X07_MBN_FILE_I].b_Enable_DL = true;

		this->m_strr_Mbn_File_List_efuse[RAWPROG_9X07_XML_FILE_I].cs_Name.Format(_T("rawprogram_nand_p4K_b256K_factory.xml"));
		this->m_strr_Mbn_File_List_efuse[RAWPROG_9X07_XML_FILE_I].cs_Path.Format(_T("%s"), cs_FW_Dir2);
		this->m_strr_Mbn_File_List_efuse[RAWPROG_9X07_XML_FILE_I].b_Enable_DL = true;

		this->m_strr_Mbn_File_List_efuse[PATCH0_9X07_XML_FILE_I].cs_Name.Format(_T("patch_p4K_b256K.xml"));
		this->m_strr_Mbn_File_List_efuse[PATCH0_9X07_XML_FILE_I].cs_Path.Format(_T("%s"), cs_FW_Dir3);
		this->m_strr_Mbn_File_List_efuse[PATCH0_9X07_XML_FILE_I].b_Enable_DL = true;
		//-------------------------------------------------------------

		//1. Load the firehose programmer to the EDL device with QSaharaServer.exe
		if (this->QFIL_DL_Firehose_Programmer(ieFuseQDLoader_Port, this->m_strr_Mbn_File_List_efuse[FIREHOSE_9X07_MBN_FILE_I]) == false)
		{
			this->m_iError_Code = 0x00000076;
			throw(3);
		}
		//2. Download the flat build to the eMMC flash of device
		if (this->QFIL_DL_Rawprogram_Efuse(ieFuseQDLoader_Port, this->m_strr_Mbn_File_List_efuse[RAWPROG_9X07_XML_FILE_I]) == false)
		{
			this->m_iError_Code = 0x00000077;
			throw(4);
		}
		//3. Apply the patch
		if (this->QFIL_DL_Patch_Efuse(ieFuseQDLoader_Port, this->m_strr_Mbn_File_List_efuse[PATCH0_9X07_XML_FILE_I]) == false)
		{
			this->m_iError_Code = 0x00000078;
			throw(3);
		}
		//-------------------------------------------------------------


	}
	catch (...)
	{
		return RTN_FAIL;
	}
	return RTN_SUCCESS;





}

bool CARM_OP_QCM::QFIL_DL_Rawprogram_Efuse(int i_QDLoader_Port, const MBN_FILE_S str_Rawprogram_File)
{
	//使用“fh_loader.exe”下载“rawprogram_unsparse.xml”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 10;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download rawprogram file ......"));
		this->Save_Trace_Log(_T("Download rawprogram file ......"));
		this->Show_Out(_T("Download rawprogram file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create pipe fail!"));
			this->m_iError_Code = DL_Rawprogram_fail3;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path_efuse.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);

		if (NAND == this->m_eu_Memory_Type)
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=rawprogram_unsparse.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path_efuse);
			if (SDX55 == this->m_eu_BB_Chip)
			{
				iTimeout = 360;//
			}
			else
			{
				//...
			}
		}
		// 		else if (UFS == this->m_eu_Memory_Type)
		// 		{
		// 			swprintf(wcpCmd, _T("cmd.exe cd \"%s\" %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=\"%s\" --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS"),
		// 				this->m_csCurr_Exe_Path, '/', m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path);
		// 
		// 		}
		else //默认EMMC
		{
			swprintf(wcpCmd, _T("cmd.exe cd \"%s\" %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=\"%s\" --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=eMMC"),
				this->m_csCurr_Exe_Path, '/', m_iClass_Idx, i_QDLoader_Port, str_Rawprogram_File.cs_Name, this->m_csFW_File_Path_efuse);

		}

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Create process fail!"));
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//提取重要的“进度百分比信息”
				//提取第一个值(0)
				wcpEach = wcstok(wcpData, _T("\r\n"));
				//
				while (wcpEach != NULL)
				{
					//是否有“percent 开始”关键词
					wcpPercent = wcsstr(wcpEach, _T("{percent files transferred"));
					//
					if (wcpPercent != NULL)
					{
						//备份单条数据
						csEach.Format(_T("%s"), wcpPercent);

						//提取百分比数据
						wcpPercent += 26;

						//是否有“percent 结束”关键词
						if (wcsstr(wcpPercent, _T("%")) != NULL)
						{
							//发现百分比数据的“结尾”
							csTemp.Format(_T("%s"), wcpPercent);
							csTemp.Replace('%', '\0');//去掉结尾

							//字符转数字
							dNew_Percent = _wtof(csTemp);

							//刷新百分比数据
							if (dNew_Percent > dCurr_Percent)
							{
								//赋值新百分比数据
								dCurr_Percent = dNew_Percent;


								// 								//显示“单条信息数据”
								// 								csEach.Replace('{', ' ');//去掉不想显示的字符
								// 								csEach.Replace('}', ' ');//去掉不想显示的字符
								// 								csEach.Replace('\r', ' ');//去掉不想显示的字符
								// 								csEach.Replace('\n', ' ');//去掉不想显示的字符
								// 								csTemp.Format(_T("DL-Rawprogram( %.2f%% ), %s"), dCurr_Percent, csEach);

								csTemp.Format(_T("DL-Rawprogram( %.2f%% )"), dCurr_Percent);
								this->Show_Status(csTemp);
								//this->Save_Trace_Log(csTemp);
								//无延迟，则看不出显示信息的变化
								Sleep(20);


								//显示进度条
								this->Show_Progress((0.2 + 0.6 * (dCurr_Percent / 100.0)));
							}
						}//if(wcsstr(wcpPercent, _T("%")) != NULL
					}//if(wcpPercent != NULL


					//提取下一个值
					wcpEach = wcstok(NULL, _T("\r\n"));
				}//while(wcpEach != NULL



				//汇总数据
				if ((dCurr_Percent > 98.0)
					|| (dCurr_Percent<1.0))//20201106
				{
					csTotal_Info += csData;
				}
				else
				{
					csTotal_Info.Format(_T("%s"), csData);
				}


				//有数据的话就重新开始计时
				time(&t_Start);
			}//if(ulActual_Read > 0


			//检查是否有错误报出
			if ((SDX20 == this->m_eu_BB_Chip)
				|| (MDM9X05 == this->m_eu_BB_Chip)
				|| (SDX55 == this->m_eu_BB_Chip))
			{
				//ERROR: [1318] error : 9
				if ((wcsstr(csTotal_Info, _T("error: [1318]")) != NULL)
					// 					||(wcsstr(csTotal_Info, _T("error: [348]")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
					// 					||(wcsstr(csTotal_Info, _T("error: [849]")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
					|| (wcsstr(csTotal_Info, _T("error: [1320]")) != NULL)//20200602 软件已经确认
					|| (wcsstr(csTotal_Info, _T("error: set bootable fail")) != NULL)//20200602 软件已经确认
					// 
					// 					||((wcsstr(csTotal_Info, _T("devprg_storage_read")) != NULL)//20200205----下发ECN的方式，不合入正式归档版本
					// 						&&(wcsstr(csTotal_Info, _T("error:")) != NULL))

					|| ((wcsstr(csTotal_Info, _T("erasing")) != NULL)
					&& (wcsstr(csTotal_Info, _T("error:")) != NULL))
					|| ((wcsstr(csTotal_Info, _T("erase")) != NULL)
					&& (wcsstr(csTotal_Info, _T("error:")) != NULL))
					)
				{
					this->Save_Trace_Log(csTotal_Info);
				}
				else
				{
					if (wcsstr(csTotal_Info, _T("error:")) != NULL)
					{
						this->Save_Trace_Log(csTotal_Info);

						this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
						this->m_iError_Code = DL_Rawprogram_fail1;
						throw(3);
					}
				}

			}
			else
			{
				if (wcsstr(csTotal_Info, _T("error:")) != NULL)
				{
					this->Save_Trace_Log(csTotal_Info);

					this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram fail!"));
					this->m_iError_Code = DL_Rawprogram_fail1;
					throw(3);
				}
			}


			//检查是否pass
			//20200711 EG91机型下载中发现有部分没有100%的场景
			if (wcsstr(csTotal_Info, _T("all finished successfully")) != NULL)
				//||
				//(wcsstr(csTotal_Info, _T("percent files transferred 100.00")) != NULL))
			{
				//				::AfxMessageBox(csTotal_Info);

				this->Save_Trace_Log(csTotal_Info);

				bSuccess_Flag = true;//pass
				break;//退出while
			}
			//兼容AG550Q的出现进度只有96%，但有all finished successfully 信息的场景
			else if (SDX55 == this->m_eu_BB_Chip)
			{
				if (wcsstr(csTotal_Info, _T("all finished successfully")) != NULL)
				{
					this->Save_Trace_Log(csTotal_Info);

					bSuccess_Flag = true;//pass
					break;//退出while
				}
			}



			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_Rawprogram, Time out!"));
				this->Save_Trace_Log(_T("FAIL, DL_Rawprogram, Time out!"));
				this->m_iError_Code = DL_Rawprogram_fail2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for (iTemp = 1; iTemp >= 0; iTemp--)
		{
			csData.Format(_T("DL-Rawprogram, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			//this->Save_Trace_Log(csData);
			//
			Sleep(800);
		}

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		this->Save_Trace_Log(_T("QFIL_DL_Rawprogram_Efuse FAIL"));
		return false;
	}

	//
	//
	this->Save_Trace_Log(_T("QFIL_DL_Rawprogram_Efuse Pass"));
	return true;
}

bool CARM_OP_QCM::QFIL_DL_Patch_Efuse(int i_QDLoader_Port, const MBN_FILE_S str_Patch_File)
{
	//使用“fh_loader.exe”下载“Efuse”文件

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;
	//int iTimeout = 5;
	//int iTimeout = 10; //20170527
	int iTimeout = 60; //20180226


	try
	{
		//显示
		this->Show_Status(_T("Download Efuse file ......"));
		this->Save_Trace_Log(_T("Download Efuse file ......"));
		this->Show_Out(_T("Download Efuse file ..."));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Efuse, Create pipe fail!"));
			this->m_iError_Code = DL_Efuse_fail1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path_efuse.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		if (NAND == this->m_eu_Memory_Type)
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=nand"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path_efuse);

		}
		// 		else if (UFS == this->m_eu_Memory_Type)
		// 		{
		// 			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
		// 			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=UFS"),
		// 				'/', this->m_csCurr_Exe_Path, m_iClass_Idx,i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path);
		// 
		// 		}
		else
		{
			//------------------------------ 打包dos指令 ------------------------------ --sendxml=patch0.xml --search_path=E:\Firmware\SC60CETAR02A01H16G_factory --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=emmc 
			swprintf(wcpCmd, _T("cmd.exe cd %s %cc QCMM\\CH%d\\fh_loader.exe --port=\\\\.\\COM%d --sendxml=%s --search_path=\"%s\" --noprompt --showpercentagecomplete --zlpawarehost=1 --memoryname=eMMC"),
				this->m_csCurr_Exe_Path, '/', m_iClass_Idx, i_QDLoader_Port, str_Patch_File.cs_Name, this->m_csFW_File_Path_efuse);

		}
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_Efuse, Create process fail!"));
			this->m_iError_Code = DL_Efuse_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果QDLoader口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				//				csData.Replace(_T('\r'), _T(' '));
				//				csData.Replace(_T('\n'), _T(' '));
				csData.MakeLower();


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL-Efuse "));
				//20180425
				this->Save_Trace_Log(wcpData);

			}//if(ulActual_Read > 0



			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("error:")) != NULL)
			{

				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(_T("FAIL, DL_Efuse error!"));
				this->m_iError_Code = DL_Patch_fail4;
				throw(3);
			}


			//检查是否pass
			if (wcsstr(csTotal_Info, _T("{all finished successfully}")) != NULL)
			{
				this->Save_Trace_Log(_T("{all finished successfully}"));

				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->Save_Trace_Log(_T("FAIL, DLEfuse, Time out!"));

				this->m_csError_Code.Format(_T("FAIL, DL_Efuse, Time out!"));
				this->m_iError_Code = DL_Patch_fail3;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for (iTemp = 1; iTemp >= 0; iTemp--)
		{
			csData.Format(_T("DL-Efuse wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(500);
		}

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		this->Save_Trace_Log(_T("QFIL_DL_Patch_Efuse Fail"));
		return false;
	}

	//
	this->Save_Trace_Log(_T("QFIL_DL_Patch_Efuse Pass"));
	
	return true;
}


int CARM_OP_QCM::Do_Execute_SPC(void)
{
	int iRtn;

	//\QDM002\1\serial_sender\prod_p3_write_crk\packet.list
	iRtn = this->Do_Execute_SPC_CRK();
	//\QDM002\1\serial_sender\DownloadFiles\packet.list
	if (RTN_SUCCESS == iRtn)
	{
		iRtn = this->Do_Execute_SPC_FW();
	}

	return iRtn;
}

int CARM_OP_QCM::Do_Execute_SPC_CRK(void)
{
	int iRtn;

	//\QDM002\1\serial_sender\prod_p3_write_crk\packet.list

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;

	int iTimeout = 30; //20180226


	try
	{
		//显示
		this->Show_Status(_T("Download SPC_CRK ......"));
		this->Save_Trace_Log(_T("Download SPC_CRK ......"));
		this->Show_Out(_T("Download SPC_CRK ..."));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_SPC_CRK, Create pipe fail!"));
			this->m_iError_Code = DL_SPC_CRK_fail1;
			throw(1);
		}
		//------------------------------ 
		//\QDM002\1\serial_sender\DownloadFiles\packet.list
		CString strSP_FW_path;
		strSP_FW_path.Format(_T("%s\\QDM002\\%d\\serial_sender\\prod_p3_write_crk\\packet.list"), this->m_csCurr_Exe_Path, m_iClass_Idx);

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + strSP_FW_path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);



		//------------------------------ 打包dos指令 ------------------------------ 
		////serial_sender.exe -s COM5 -v -t 10 prod_p3_write_crk\packet.list

		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\serial_sender\\serial_sender.exe -s COM%d -v -t 10 %s"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, m_iBG95_Ctrl_Port, strSP_FW_path);


		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_SPC_CRK, Create process fail!"));
			this->m_iError_Code = DL_SPC_CRK_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果下载口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				csData.MakeLower();

				if (csData.Find(_T("waiting for device")) != -1)
				{
					this->Show_Status(_T("Reset Module..."));
				}


				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_SPC_CRK "));
				//20180425
				this->Save_Trace_Log(wcpData);

			}//if(ulActual_Read > 0


			//error: SCP session FAILED
			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("error:")) != NULL)
			{

				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(_T("SCP session FAILED"));
				this->m_iError_Code = DL_SPC_CRK_fail4;
				throw(3);
			}


			//检查是否pass
			if (wcsstr(csTotal_Info, _T("scp session ok")) != NULL)
			{
				this->Save_Trace_Log(_T("SCP session ok"));

				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->Save_Trace_Log(_T("FAIL, DL_SPC_CRK, Time out!"));

				this->m_csError_Code.Format(_T("FAIL, DL_SPC_CRK, Time out!"));
				this->m_iError_Code = DL_SPC_CRK_fail3;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for (iTemp = 1; iTemp >= 0; iTemp--)
		{
			csData.Format(_T("DL_SPC_CRK, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(500);
		}

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		this->Save_Trace_Log(_T("DL_SPC_CRK Fail"));
		return RTN_FAIL;
	}

	//
	this->Save_Trace_Log(_T("DL_SPC_CRK Pass"));

	return RTN_SUCCESS;

	return iRtn;
}

int CARM_OP_QCM::Do_Execute_SPC_FW(void)
{
	int iRtn;

	//\QDM002\1\serial_sender\DownloadFiles\packet.list
	

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;

	time_t t_Start, t_End;
	unsigned long ulActual_Read;
	CString csTotal_Info, csData;
	int iTemp;
	bool bSuccess_Flag = false;

	int iTimeout = 120; //20180226


	try
	{
		//显示
		this->Show_Status(_T("Download SPC_FW ......"));
		this->Save_Trace_Log(_T("Download SPC_FW ......"));
		this->Show_Out(_T("Download SPC_FW ..."));

		m_cla_GFC.Kill_Process(_T("serial_sender.exe"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_SPC_FW, Create pipe fail!"));
			this->m_iError_Code = DL_SPC_FW_fail1;
			throw(1);
		}
		//------------------------------ 
		//\QDM002\1\serial_sender\DownloadFiles\packet.list
		CString strSP_FW_path;
		strSP_FW_path.Format(_T("%s\\QDM002\\%d\\serial_sender\\DownloadFiles\\packet.list"), this->m_csCurr_Exe_Path, m_iClass_Idx);

		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + strSP_FW_path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 512);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 512);


		
		//------------------------------ 打包dos指令 ------------------------------ 
		////serial_sender.exe -s COM5 -v -t 10 DownloadFiles\packet.list

		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\serial_sender\\serial_sender.exe -s COM%d -v -t 10 %s"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, m_iBG95_Ctrl_Port, strSP_FW_path);

		
		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_SPC_FW, Create process fail!"));
			this->m_iError_Code = DL_SPC_FW_fail2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 512);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 256, &ulActual_Read, NULL);
			//注意：如果下载口状态异常的话，程序会吊死在这里。一直无返回。


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 512);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);
				csData.MakeLower();

				if (csData.Find(_T("waiting for device")) != -1)
				{
					this->Show_Status(_T("Reset Module..."));
				}

				//汇总数据
				csTotal_Info += csData;


				//逐条显示每次的读出data
				this->Show_Status_In_Each(wcpData, _T("DL_SPC_FW "));
				//20180425
				this->Save_Trace_Log(wcpData);

			}//if(ulActual_Read > 0


		    //error: SCP session FAILED
			//检查是否有错误报出
			if (wcsstr(csTotal_Info, _T("error:")) != NULL)
			{

				this->Save_Trace_Log(csTotal_Info);

				this->m_csError_Code.Format(_T("SCP session FAILED"));
				this->m_iError_Code = DL_SPC_FW_fail4;
				throw(3);
			}


			//检查是否pass
			if (wcsstr(csTotal_Info, _T("scp session ok")) != NULL)
			{
				this->Save_Trace_Log(_T("SCP session ok"));

				bSuccess_Flag = true;//pass
				break;//退出while
			}


			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->Save_Trace_Log(_T("FAIL, DL_SPC_FW, Time out!"));

				this->m_csError_Code.Format(_T("FAIL, DL_SPC_FW, Time out!"));
				this->m_iError_Code = DL_SPC_FW_fail3;
				throw(4);
			}
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);



		//延迟1秒
		for (iTemp = 1; iTemp >= 0; iTemp--)
		{
			csData.Format(_T("DL_SPC_FW, wait for %d seconds ......"), iTemp);
			this->Show_Status(csData);
			this->Save_Trace_Log(csData);
			//
			Sleep(500);
		}

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);
		//
		this->Save_Trace_Log(_T("DL_SPC_FW Fail"));
		return RTN_FAIL;
	}

	//
	this->Save_Trace_Log(_T("DL_SPC_FW Pass"));

	return RTN_SUCCESS;
}
//AT+QWSETMAC="xxxxxx"
bool CARM_OP_QCM::Set_QWSETMAC(void)
{
	//
	CString strATCom, csData;

	strATCom.Format(_T("AT+QWSETMAC=\"%s\""), this->m_strQW_MAC);
	try
	{
		//发送
		if (this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 3) == false)
		{
			throw(0);
		}

	}
	catch (...)
	{
		return false;
	}
	return true;

}
//AT + QWSETMAC ?
bool CARM_OP_QCM::Get_QWSETMAC(void)
{
	//
	CString csCOM, strATCom, csData;
	strATCom.Format(_T("AT+QWSETMAC=?"));
	try
	{
		//发送
		if (this->m_cla_AT_Com_Port.Query_Tgt_CHAR(strATCom, _T("OK"), 3) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE."));
			throw(0);
		}

		//提取AT返回数据
		this->m_cla_AT_Com_Port.GET_RX_PKT_BUFF_DATA(&csData);

		//提取有用数据
		CString csTemp;
		if (this->m_cla_AT_Com_Port.m_cla_GFC.GET_AT_RSP_MID_STRING(csData, _T(""), _T("OK"), &csTemp) == false)
		{
			this->Show_Status(_T("Fail,AT COMAND NO RESPONSE(OK)."));
			throw(0);
		}

		this->Save_Trace_Log(csTemp);
		this->Show_Out(csTemp);

	}
	catch (...)
	{
		return 0;
	}
	return 1;

}
int CARM_OP_QCM::Execute_QDE007_Danlow_Jlink(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Danlow Fw file ......"));
		this->Save_Trace_Log(_T("Download Danlow Fw file ......"));
		this->Show_Out(_T("Download Danlow Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDE007\\%d\\JLink.exe  \"%s\\QDE007\\%d\\eraseAndFlash.jlink\""),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_csCurr_Exe_Path, m_iClass_Idx);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有“Script file read successfully 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script file read successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("script file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("script file read successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Connecting to J-Link via USB...O.K”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("connecting to j-link via usb...o.k"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting usb ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("connecting to j-link via usb...o.k"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("erasing..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("erasing device"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing done"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script processing completed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}


	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


// check port 是否存在
bool CARM_OP_QCM::Check_Port(void)
{
	bool  bDL_Flag = false;
	//---------------------------------------------------------------------------------
	if (this->m_iCom_Port_Auto_Sec > 0)//
	{
		//成功找到端口1
		int iFlag = 0;
		iFlag = this->Confirm_Dynamic_Com_Port_Ext(this->m_iCom_Port, this->m_iCom_Port_Auto_Sec, 70);
		//成功找到端口1
		if (1 == iFlag)
		{
			bDL_Flag = true;
		}
		//成功找到端口2
		else if (2 == iFlag)
		{
			bDL_Flag = true;
		}
		else //两个端口都没找到
		{
			bDL_Flag = false;
		}
	}
	else
	{
		if (this->Confirm_Dynamic_Com_Port(this->m_iCom_Port, 70) == false)
		{
			bDL_Flag = false;
		}
		else
		{
			bDL_Flag = true;
		}
	}

	return bDL_Flag;
}

int CARM_OP_QCM::DL_FW_ESP32_MCU(void)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 300;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach, str_ExeName;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;

	int P1(-1), P2(-1), Pos(0);


	try
	{
		//显示
		this->Show_Status(_T("Download ESP32_MCU file ......"));
		this->Save_Trace_Log(_T("Download ESP32_MCU file ......"));
		this->Show_Out(_T("Download ESP32_MCU file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_ESP32_MCU, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);


		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------

		//esptool.exe -p COM1 -b 115200 write_flash 0x00 quectel_ESP32_main.bin 0x180000 audio-esp.bin

		//扫码下载要稍微等模块压下后再做此处的处理
		Sleep(5000);

		//m_csMCU_Name

		//QDM002GLEF-M21-AAAAA全球版本的命令中没有语音文件 20220729
		if (_T("QDM002GLEF-M21-AAAAA") == m_csOC)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash 0x00 %s"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, m_strESP32_main_path);
		}
		else if (NULL != wcsstr(m_csOC, _T("QDM040")) || NULL != wcsstr(m_csOC, _T("QDM059")))
		{
			/*
			0x0 bootloader.bin 0x10000 harald-upgrader.bin 0x8000 partition-table.bin 0xd000 ota_data_initial.bin
			CString m_strESP32_Bootloader_Path;
			CString m_strESP32_PartitionTable_Path;
			CString m_strESP32_OtaDataInitial_Path;
			CString m_strESP32_NetworkAdapter_Path;
			*/
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash 0x00 %s 0x10000 %s 0x8000 %s 0xd000 %s"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, m_strESP32_Bootloader_Path, m_strESP32_HaraldUpgrader_Path, m_strESP32_PartitionTable_Path, m_strESP32_OtaDataInitial_Path);
		}
		else
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash 0x00 %s 0x180000 %s"),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, m_strESP32_main_path, m_straudio_esp_path);
		}
		

		this->Save_Trace_Log(wcpCmd);
		this->Show_Out(wcpCmd);

		str_ExeName.Format(_T("esptool%d.exe"), this->m_iClass_Idx);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0, iTimeTemp=0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;

			if (TRUE == ::PeekNamedPipe(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, 0, 0))
			{
				ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			}

			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csTemp = csData;

				//Writing at 0x00013111... (5  %)
				if ((NULL != wcsstr(csTemp, _T("Writing at")))
					&&
					(NULL != wcsstr(csTemp, _T("%)"))))
				{
					P1 = csTemp.Find(_T("("));
					if (P1 > 0)
					{
						csTemp = csTemp.Mid(P1 + 1);
						csTemp.Replace(_T(" "), _T(""));
						P2 = csTemp.Find(_T("%"));
						if (P2 > 0)
						{
							csTemp = csTemp.Left(P2);
							dCurr_Percent = _ttof(csTemp);
							dCurr_Percent = dCurr_Percent / 100.0;

							this->Show_Progress(dCurr_Percent);
						}
					}
				}


				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//csData.MakeLower();

				csTotal_Info += csData;

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//是否有“Connecting.. 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Connecting.."));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Connecting......."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Connecting......."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Detecting chip type... ESP32 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("ESP32"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Detecting chip type... ESP32"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Detecting chip type... ESP32"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Configuring flash size”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Configuring flash size"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("Configuring flash size"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("Configuring flash size"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}



				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Hash of data verified"));
				//
				if (wcpPercent != NULL)
				{
					i_verified++;
					switch (i_verified)
					{
					case 1:
						dCurr_Percent = 0.3; break;
					case 2:
						dCurr_Percent = 0.6; break;
					case 3:
						dCurr_Percent = 0.9; break;
					default:
						dCurr_Percent = 0.1; break;
					}

					csTemp.Format(_T("Hash of data verified"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(dCurr_Percent);

					csTemp.Format(_T("Hash of data verified"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Leaving"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Leaving.
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Leaving"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}

				//Hard resetting via RTS pin..
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Hard resetting via RTS pin"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Failed to connect to Espressif device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Failed to connect to Espressif device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to connect to Espressif device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW_MCU, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}
			else
			{
				//------------------------------------------------
				time(&t_End);
				iTimeTemp = (int)difftime(t_End, t_Start);
				//
				if (iTimeTemp >= iTimeout)
				{
					//发个消息将esptool%d.exe文件杀掉
					bool bKill_Flag = false;
					bKill_Flag = m_cla_GFC.Kill_Process(str_ExeName);
					if (false == bKill_Flag)
					{
						csData.Format(_T("%s Del FAIL_1"), str_ExeName);
						this->Show_Out(csData);
					}
					else
					{
						csData.Format(_T("%s Del PASS_1"), str_ExeName);
						this->Show_Out(csData);
					}

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Get Data Timeout"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Get Data Timeout!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

				}

			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}



int CARM_OP_QCM::Execute_DL_Jlink(CString str_JlinkFolderName)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;
	CString str_ExeName = _T("");


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));



		str_ExeName = _T("JLink.exe");
		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(500);
		m_cla_GFC.Kill_Process(str_ExeName);


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\%s\\%d\\JLink.exe  \"%s\\%s\\%d\\eraseAndFlash.jlink\""),
			'/', this->m_csCurr_Exe_Path, str_JlinkFolderName, m_iClass_Idx, this->m_csCurr_Exe_Path, str_JlinkFolderName, m_iClass_Idx);

		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				//是否有“Script file read successfully 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script file read successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("script file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("script file read successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Connecting to J-Link via USB...O.K”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("connecting to j-link via usb...o.k"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting usb ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("connecting to j-link via usb...o.k"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("erasing..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("erasing device"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing done"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("script processing completed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				
			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
				this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}




		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);


		str_ExeName= _T("JLink.exe");
		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(500);
		m_cla_GFC.Kill_Process(str_ExeName);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);

		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(500);
		m_cla_GFC.Kill_Process(str_ExeName);

		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}


	m_cla_GFC.Kill_Process(str_ExeName);
	Sleep(500);
	m_cla_GFC.Kill_Process(str_ExeName);

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


bool CARM_OP_QCM::Creat_DL_Jlink_CMD(CString str_JLinkFolderName, CString str_DeviceName, CString str_FlashAddress_01, CString str_FlashAddress_02, CString str_FWPath_01, CString str_FWPath_02)
{
	//

	//device LPC1768		//选择MCU型号
	//	usb 0
	//	si 1				//选择swd接口
	//	speed 4000			//选择速度
	//	erase				//擦除
	//	sleep 400
	//	loadfile "D:\software\WeChat Files\sezai1014440164\FileStorage\File\2021-02\Danlow_QDE007-NA\34VB011900.hex"	0x00//选择你要下载的文件，后面是FW烧录到目标芯片的地址
	//	sleep 100
	//	r
	//	g
	//	q

	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\%s\\%d\\eraseAndFlash.jlink"), this->m_csCurr_Exe_Path, str_JLinkFolderName, m_iClass_Idx);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();


		Cmd_File.WriteString(_T("device ") + str_DeviceName + _T("\n"));

		csData.Format(_T("usb 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("si 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("speed 4000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("erase\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("sleep 400\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("loadfile \"%s\" %s\n"), str_FWPath_01, str_FlashAddress_01);
		Cmd_File.WriteString(csData);

		csData.Format(_T("sleep 100\n"));
		Cmd_File.WriteString(csData);

		if (str_FWPath_02 != _T(""))
		{
			csData.Format(_T("loadfile \"%s\" %s\n"), str_FWPath_02, str_FlashAddress_02);
			Cmd_File.WriteString(csData);

			csData.Format(_T("sleep 100\n"));
			Cmd_File.WriteString(csData);
		}

		csData.Format(_T("r\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("g\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("q\n"));
		Cmd_File.WriteString(csData);


		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
		return true;
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return false;

	}
}


void CARM_OP_QCM::TraversFolderFile(CString str_TargetPath, CString str_FileMark, CString & strFilePath)
{
	CFileFind finder;
	CString strWildcard(str_TargetPath);
	strWildcard += _T("//*.*");

	BOOL bWorking = finder.FindFile(strWildcard);

	int i = 0;
	while (bWorking)
	{
		//如果还有文件存在就执行下面的
		bWorking = finder.FindNextFile();
		if (finder.IsDots()) //如果是. 或者.. 就continue
		{
			bWorking = finder.FindNextFile();
			continue;
		}
		//一般文件及文件夹

		BOOL bisDir = finder.IsDirectory();
		if (bisDir)
		{ //是文件夹
			CString repath = finder.GetFilePath();
			TraversFolderFile(repath, str_FileMark, strFilePath);
		}
		else
		{//是文件
			//do parse
			CString repath = finder.GetFileName(); 
			//CString repath = finder.GetFileName(); //eg return myfile.txt
			if (wcsstr(repath, str_FileMark) != NULL)
			{
				strFilePath = finder.GetFilePath(); //eg return c:/myhtml/myfile.txt		
			}
		}


	}//end while
	finder.Close();
	return;
}


bool CARM_OP_QCM::Load_MCU_File()
{
	if (NULL != wcsstr(m_csOC, _T("QDM041")))
	{
		CString str_Tmp = _T("");
		//TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("QDM041_NRF52832"), str_Tmp);
		if (false == this->Creat_DL_Jlink_CMD(_T("QDM041"), _T("NRF52832_XXAA"), _T("0x00000000"), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, QDM041 Creat_DL_Jlink_CMD fail!"));
			//
			this->Show_Out(_T("Error, QDM041 Creat_DL_Jlink_CMD fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("QDM041 Creat_DL_Jlink_CMD Pass!"));
		}
	}

	if (NULL != wcsstr(m_csOC, _T("QDC002")))
	{
		CString str_QDC002_Bootloader = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("QDC002_Bootloader"), str_QDC002_Bootloader);
		if (str_QDC002_Bootloader == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDC002_Bootloader.bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDC002_Bootloader.bin file does not exist, fail!"));

			return false;
		} 
		else
		{
			if (false == this->Creat_DL_Jlink_CMD(_T("Jlink_Newest"), _T("GD32F303CC"), _T("0x08000000"), _T("0x08008000"), m_csScat_Cfg_File_Path, str_QDC002_Bootloader))
			{
				this->m_csError_Code.Format(_T("Error, QDC002 Creat_DL_Jlink_CMD fail!"));

				this->Show_Out(_T("Error, QDC002 Creat_DL_Jlink_CMD fail!"));

				return false;
			}
			else
			{
				this->Show_Out(_T("QDC002 Creat_DL_Jlink_CMD Pass!"));
			}
		}
		
	}

	if (m_csOC == _T("QDC004EAXC-I01-AAAAA"))
	{
		CString str_QDC004_Bootloader = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("QDC004_R7FA6M5BF_BOOT"), str_QDC004_Bootloader);
		if (str_QDC004_Bootloader == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDC004_R7FA6M5BF_BOOT.bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDC004_R7FA6M5BF_BOOT.bin file does not exist, fail!"));

			return false;
		}
		else
		{
			if (false == this->Creat_DL_Jlink_CMD(_T("Jlink_Newest"), _T("R7FA6M5BF"), _T("0x00000000"), _T("0x00080000"), m_csScat_Cfg_File_Path, str_QDC004_Bootloader))
			{
				this->m_csError_Code.Format(_T("Error, QDC004 Creat_DL_Jlink_CMD fail!"));
				this->Show_Out(_T("Error, QDC004 Creat_DL_Jlink_CMD fail!"));
				return false;
			}
			else
			{
				this->Show_Out(_T("QDC004 Creat_DL_Jlink_CMD Pass!"));
			}
		}
	}

	if (m_csOC == _T("QDC004EAXD-TI-AAAAA"))  //TI烧录地址，FCT是0x00000000，BOOT是0x00080000
	{
		CString str_QDC004_Bootloader = _T("");
		CString str_QDC004_FCT = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("QDC004_TM4C1290NCPDTI3R_BOOT"), str_QDC004_Bootloader); 
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("QDC004_TM4C1290NCPDTI3R_FCT"), str_QDC004_FCT);
		if (str_QDC004_Bootloader == _T("") || str_QDC004_FCT == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDC004_Bootloader.bin Or QDC004_FCT.bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDC004_Bootloader.bin Or QDC004_FCT.bin file does not exist, fail!"));

			return false;
		}
		else
		{
			if (false == this->Creat_DL_Jlink_CMD(_T("Jlink_Newest"), _T("TM4C1290NCPDT"), _T("0x00000000"), _T("0x00080000"), str_QDC004_FCT, str_QDC004_Bootloader))
			{
				this->m_csError_Code.Format(_T("Error, QDC004 Creat_DL_Jlink_CMD fail!"));
				this->Show_Out(_T("Error, QDC004 Creat_DL_Jlink_CMD fail!"));
				return false;
			}
			else
			{
				this->Show_Out(_T("QDC004 Creat_DL_Jlink_CMD Pass!"));
			}
		}

	}



	if (NULL != wcsstr(m_csOC, _T("QDM027")))
	{

		if (false == this->Creat_DL_Jflash_CMD(_T("QDM027"), _T("FM33LG04x"), _T("0x00000000"), m_csScat_Cfg_File_Path))
		{
			this->m_csError_Code.Format(_T("Error, QDM027 Creat_DL_Jflash_CMD fail!"));
			//
			this->Show_Out(_T("Error, QDM027 Creat_DL_Jflash_CMD fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("QDM027 Creat_DL_Jflash_CMD Pass!"));
		}
	}


	if (_T("QDM551EABL-QNA-AAAAA") == m_csOC)
	{

		CopyFile(GetExeFilePath() + _T("\\QDM027\\1\\QDM551_Jflashfile_Orig.jflash"), GetExeFilePath() + _T("\\QDM027\\1\\QDM551_Jflashfile.jflash"), FALSE);
		Sleep(1000);

		CString str_QDM551_Bin = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), m_csMCU_Name, str_QDM551_Bin);

		if (str_QDM551_Bin == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDM551_Bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDM551_Bin file does not exist, fail!"));

			return false;
		}
		else
		{
			m_csScat_Cfg_File_Path = str_QDM551_Bin;
			if (RTN_FAIL == this->Modify_FileContent(GetExeFilePath() + _T("\\QDM027\\1\\QDM551_Jflashfile.jflash"), _T("  CurrentFile = "), _T("\"") + m_csScat_Cfg_File_Path + _T("\"")))
			{
				this->m_csError_Code.Format(_T("Error, QDM551 Creat_DL_Jflash_CMD fail!"));
				//
				this->Show_Out(_T("Error, QDM551 Creat_DL_Jflash_CMD fail!"));

				return false;
			}
			else
			{
				this->Show_Out(_T("QDM551 Creat_DL_Jflash_CMD Pass!"));
			}

		}
	}


	if (_T("QDM078EAEN-IOT-AAAAA") == m_csOC)
	{

		CopyFile(GetExeFilePath() + _T("\\QDM027\\1\\QDM078_Jflashfile_Orig.jflash"), GetExeFilePath() + _T("\\QDM027\\1\\QDM078_Jflashfile.jflash"), FALSE);
		Sleep(1000);

		CString str_QDM078_Bin = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), m_csMCU_Name, str_QDM078_Bin);

		if (str_QDM078_Bin == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDM078_Bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDM078_Bin file does not exist, fail!"));

			return false;
		}
		else
		{
			m_csScat_Cfg_File_Path = str_QDM078_Bin;
			if (RTN_FAIL == this->Modify_FileContent(GetExeFilePath() + _T("\\QDM027\\1\\QDM078_Jflashfile.jflash"), _T("  CurrentFile = "), _T("\"") + m_csScat_Cfg_File_Path + _T("\"")))
			{
				this->m_csError_Code.Format(_T("Error, QDM551 Creat_DL_Jflash_CMD fail!"));
				//
				this->Show_Out(_T("Error, QDM078 Creat_DL_Jflash_CMD fail!"));

				return false;
			}
			else
			{
				this->Show_Out(_T("QDM078 Creat_DL_Jflash_CMD Pass!"));
			}

		}
	}






	if (NULL != wcsstr(m_csOC, _T("QDM062"))) //QDM062EABL-D08-AAAAA
	{
		CopyFile(GetExeFilePath() + _T("\\QDM027\\1\\QDM062_Jflashfile_Orig.jflash"), GetExeFilePath() + _T("\\QDM027\\1\\QDM062_Jflashfile.jflash"), FALSE);
		Sleep(1000);

		CString str_QDM062_Bin = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), m_csMCU_Name, str_QDM062_Bin);

		if (str_QDM062_Bin == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDM062_Bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDM062_Bin file does not exist, fail!"));

			return false;
		}
		else
		{
			m_csScat_Cfg_File_Path = str_QDM062_Bin;
			if (RTN_FAIL == this->Modify_FileContent(GetExeFilePath() + _T("\\QDM027\\1\\QDM062_Jflashfile.jflash"), _T("  CurrentFile = "), _T("\"") + m_csScat_Cfg_File_Path + _T("\"")))
			{
				this->m_csError_Code.Format(_T("Error, QDM062 Creat_DL_Jflash_CMD fail!"));
				//
				this->Show_Out(_T("Error, QDM062 Creat_DL_Jflash_CMD fail!"));

				return false;
			}
			else
			{
				this->Show_Out(_T("QDM062 Creat_DL_Jflash_CMD Pass!"));
			}

		}


		//if (false == this->Creat_DL_Jlink_CMD(_T("QDM062"), _T("FM33LG04x"), _T(""), _T(""), m_csScat_Cfg_File_Path, _T("")))
		//{
		//	this->m_csError_Code.Format(_T("Error, QDM062 Creat_DL_Jlink_CMD fail!"));
		//	//
		//	this->Show_Out(_T("Error, QDM062 Creat_DL_Jlink_CMD fail!"));

		//	return false;
		//}
		//else
		//{
		//	this->Show_Out(_T("QDM062 Creat_DL_Jlink_CMD Pass!"));
		//}
	}

	if (_T("QDM042AUBL-D01-AAAAA") == m_csOC)
	{

		if (false == this->Creat_DL_Jlink_CMD(_T("Jlink"), _T("LPC802M011"), _T("0x00000000"), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDM042 fail!"));
			//
			this->Show_Out(_T("Error, LOAD_FW_FILE_QDM042 fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("LOAD_FW_FILE_QDM042 Pass!"));
		}
	}

	if (_T("QDE507SPAK-U61-BAAAA") == m_csOC)
	{

		if (false == this->Creat_DL_Jlink_CMD(_T("Jlink"), _T("STM32F030C8"), _T(""), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDE507 fail!"));
			//
			this->Show_Out(_T("Error, LOAD_FW_FILE_QDE507 fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("LOAD_FW_FILE_QDE507 Pass!"));
		}
	}


	if (_T("QDM063EABA-N06-AAAAA") == m_csOC || _T("QDM063EABA-N06-AAASM") == m_csOC)  //bin文件才要配置的吧，hex文件内部有地址 20230511 
	{

		if (false == this->Creat_DL_Jlink_CMD(_T("Jlink"), _T("STM32L476ZG"), _T(""), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDM063 fail!"));
			//
			this->Show_Out(_T("Error, LOAD_FW_FILE_QDM063 fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("LOAD_FW_FILE_QDM063 Pass!"));
		}
	}


	if (_T("QDM066EPBK-I03-AAAAA") == m_csOC)  //bin文件才要配置的吧，hex文件内部有地址 20230627
	{

		if (false == this->Creat_DL_Jlink_CMD(_T("Jlink"), _T("STM32L471RG"), _T(""), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, LOAD_FW_FILE_QDM066 fail!"));
			//
			this->Show_Out(_T("Error, LOAD_FW_FILE_QDM066 fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("LOAD_FW_FILE_QDM066 Pass!"));
		}
	}


	if (_T("QDC519SASE-E53-AAAAA") == m_csOC || _T("QDC519SASE-E53-BAAAA") == m_csOC || _T("QDC519SASE-E53-CAAAA") == m_csOC || _T("QDC519SASE-E53-DAAAA") == m_csOC)
	{
		CString str_QDC519_Key = _T("");
		CString str_QDC519_Boot = _T("");
		CString str_QDC519_Cfg = _T("");
		CString str_QDC519_Os = _T("");
		
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("PUK"), str_QDC519_Key);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("BOOT"), str_QDC519_Boot);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("CFG"), str_QDC519_Cfg);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T("OS"), str_QDC519_Os);
		if (str_QDC519_Key == _T("") || str_QDC519_Boot == _T("") || str_QDC519_Cfg == _T("") || str_QDC519_Os == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDC519 Key Boot Cfg or Os file does not exist, fail!"));

			this->Show_Out(_T("Error, QDC519 Key Boot Cfg or Os file does not exist, fail!"));

			return false;
		}
		else
		{
			if (false == Call_QDC519_SunmiDownloader(str_QDC519_Key, str_QDC519_Boot, str_QDC519_Cfg, str_QDC519_Os))
			{
				this->m_csError_Code.Format(_T("Error, CreateProcess SunmiDownloader fail!"));
				this->Show_Out(_T("Error, CreateProcess SunmiDownloader fail!"));
				return false;
			}
			else
			{
				this->Show_Out(_T("CreateProcess SunmiDownloader Pass!"));
			}
		}
	}

	//QDE017EABL-N07-AAAAA
	if (m_csOC == _T("QDE017EABL-N07-AAAAA"))  
	{
		CString str_QDE017_BinFile = _T("");
		CString str_QDE017_CbxFile = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T(".bin"), str_QDE017_BinFile);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T(".cbx"), str_QDE017_CbxFile);

		if (str_QDE017_BinFile == _T("") || str_QDE017_CbxFile == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDE017 bin or cbx file does not exist, fail!"));

			this->Show_Out(_T("Error, QDE017 bin or cbx file does not exist, fail!"));

			return false;
		}
		else
		{
			m_str_QDE017_Binfile = str_QDE017_BinFile;
			CopyFile(m_str_QDE017_Binfile, m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1) + _T("cust_app_update.bin"), FALSE);
			Sleep(1000);
			m_str_QDE017_Binfile = m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1) + _T("cust_app_update.bin");


			WritePrivateProfileString(_T("Config"), _T("PathFile"), str_QDE017_CbxFile, this->m_csCurr_Exe_Path + _T("\\QDE017\\Xmodem.ini"));

		}
	
	}

	if (_T("QDM536CNEG-I05-AAAAA") == m_csOC || _T("QDM536CNEG-I05-BBAAA") == m_csOC)  //bin文件才要配置的吧，hex文件内部有地址 20230627
	{

		if (false == this->Creat_DL_Jlink_CMD(_T("QDM536"), _T("gd32f303ze"), _T("0x08000000"), _T(""), m_csScat_Cfg_File_Path, _T("")))
		{
			this->m_csError_Code.Format(_T("Error, QDM536 Creat_DL_Jlink_CMD fail!"));
			//
			this->Show_Out(_T("Error, QDM536 Creat_DL_Jlink_CMD fail!"));

			return false;
		}
		else
		{
			this->Show_Out(_T("QDM536 Creat_DL_Jlink_CMD Pass!"));
		}
	}


	if (_T("QDM536CNEM-IOT-AAAASM") == m_csOC)  //bin文件才要配置的吧，hex文件内部有地址 20230627
	{
		CString strBinfileFullPathName = _T("");
		strBinfileFullPathName = m_csScat_Cfg_File_Path;
		strBinfileFullPathName = strBinfileFullPathName.Left(strBinfileFullPathName.ReverseFind('\\'));
		TraversFolderFile(strBinfileFullPathName, _T("QDM536_MCU_boot"), strBinfileFullPathName);


		if (strBinfileFullPathName == _T("") || strBinfileFullPathName == _T(" ") || strBinfileFullPathName.IsEmpty())
		{
			this->m_csError_Code.Format(_T("Error, QDM536_MCU bin file does not exist, fail!"));

			this->Show_Out(_T("Error, QDM536_MCU bin file does not exist, fail!"));

			return false;
		}
		else
		{
			if (false == this->Creat_DL_Jlink_CMD(_T("QDM536"), _T("gd32f303ze"), _T("0x08000000"), _T(""), strBinfileFullPathName, _T("")))
			{
				this->m_csError_Code.Format(_T("Error, QDM536_MCU Creat_DL_Jlink_CMD fail!"));
				//
				this->Show_Out(_T("Error, QDM536_MCU Creat_DL_Jlink_CMD fail!"));

				return false;
			}
			else
			{
				this->Show_Out(_T("QDM536_MCU Creat_DL_Jlink_CMD Pass!"));
			}
		}
	
	}


	if (_T("QDM025NASP-E53-AAAAA") == m_csOC)
	{
		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;

		strCmd_file_name.Format(_T("%s\\Fir\\QDM025_FastbootCMD.bat"), this->m_csCurr_Exe_Path);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}

		CString str_QDM025_Boot = _T("");
		CString str_QDM025_System = _T("");
		CString str_QDM025_Vendor = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("boot.img"), str_QDM025_Boot);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("system.img"), str_QDM025_System);
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("vendor.img"), str_QDM025_Vendor);

		if (str_QDM025_Boot ==_T("") || str_QDM025_System == _T("") || str_QDM025_Vendor == _T(""))
		{
			this->m_csError_Code.Format(_T("Error, QDM025 img file does not exist, fail!"));

			this->Show_Out(_T("Error, QDM025 img file does not exist, fail!"));

			return false;
		}

		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			Cmd_File.WriteString(_T("cd /d") + this->m_csCurr_Exe_Path + _T("\r\n"));
			Sleep(200);

			Cmd_File.WriteString(_T("adb reboot bootloader\r\n"));
			Sleep(200);

			csData.Format(_T("fastboot flash boot %s\r\n"), str_QDM025_Boot);
			Cmd_File.WriteString(csData);
			Sleep(200);

			csData.Format(_T("fastboot flash system %s\r\n"), str_QDM025_System);
			Cmd_File.WriteString(csData);
			Sleep(200);

			csData.Format(_T("fastboot flash vendor %s\r\n"), str_QDM025_Vendor);
			Cmd_File.WriteString(csData);
			Sleep(200);

			Cmd_File.WriteString(_T("fastboot reboot\r\n"));
			Sleep(200);

			this->Save_Trace_Log(csData);

			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));
		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			return RTN_FAIL;
		}
	}

	if (_T("QDM055EAEQ-N03-AAASM") == m_csOC)
	{
		CString str_Registration_CSV_File = this->m_csCurr_Exe_Path + _T("\\QDM055\\") + m_csMCU_Name2 + _T(".csv");
		CFileFind f;
		if (f.FindFile(str_Registration_CSV_File) == false)
		{
			CString temp = _T("");
			temp.Format(_T("%s, Registration CSV file not found"), str_Registration_CSV_File);
			this->Show_Status(temp);
			this->Save_Trace_Log(temp);
			this->Show_Out(temp);
			this->m_csError_Code.Format(_T("Registration CSV file not found"));

			return false;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("%s, Registration CSV file exists"), str_Registration_CSV_File);
			this->Show_Status(_T("Ready"));
			this->Save_Trace_Log(temp);
			this->Show_Out(temp);
		}

	}
	
	return true;
}


bool CARM_OP_QCM::Creat_DL_Jflash_CMD(CString str_JlinkFolderName, CString str_DeviceName, CString str_FlasgAddress, CString str_FWPath)
{
	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\%s\\%d\\Jflashfile.jflash"), this->m_csCurr_Exe_Path, str_JlinkFolderName, m_iClass_Idx);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();


		csData.Format(_T("  AppVersion = 63004\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  FileVersion = 2\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("[GENERAL]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ConnectMode = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  CurrentFile = \"%s\"\n"), str_FWPath);
		Cmd_File.WriteString(csData);

		csData.Format(_T("  DataFileSAddr = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  GUIMode = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  HostName = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  TargetIF = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  USBPort = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  USBSerialNo = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("[JTAG]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  IRLen = 0\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  MultipleTargets = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  NumDevices = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  Speed0 = 1000\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  Speed1 = 4000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  TAP_Number = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  UseAdaptive0 = 0\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  UseAdaptive1 = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  UseMaxSpeed0 = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  UseMaxSpeed1 = 0\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("[CPU]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  NumInitSteps = 46\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep0_Action = \"Reset\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep0_Value0 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep0_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep0_Comment = \"Reset and halt target\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep1_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep1_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep1_Value1 = 0x0000000A\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep1_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep2_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep2_Value0 = 0x40002438\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  InitStep2_Value1 = 0x00000020\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep2_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep3_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep3_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep3_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep3_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep4_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep4_Value0 = 0x4000244C\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep4_Value1 = 0x40000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep4_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep5_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep5_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep5_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep5_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep6_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep6_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep6_Value1 = 0x00000201\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep6_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep7_Action = \"Delay\"\n"));
			Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep7_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep7_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep7_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep8_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep8_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep8_Value1 = 0x96969696\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep8_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep9_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep9_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep9_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep9_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep10_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep10_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep10_Value1 = 0x7D7D7D7D\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep10_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep11_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep11_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep11_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep11_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep12_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep12_Value0 = 0x1FFFFC00\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep12_Value1 = 0x1234ABCD\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep12_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep13_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep13_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep13_Value1 = 0x000005DC\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep13_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep14_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep14_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep14_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep14_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep15_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  InitStep15_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep15_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep15_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep16_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep16_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep16_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep16_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep17_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep17_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep17_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep17_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep18_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep18_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep18_Value1 = 0x96969696\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep18_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep19_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep19_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep19_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep19_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep20_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep20_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep20_Value1 = 0xEAEAEAEA\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep20_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep21_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep21_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep21_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep21_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep22_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep22_Value0 = 0x1FFFFC00\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep22_Value1 = 0x1234ABCD\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep22_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep23_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep23_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep23_Value1 = 0x000005DC\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep23_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep24_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep24_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep24_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep24_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep25_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep25_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep25_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep25_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep26_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep26_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep26_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep26_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep27_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep27_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep27_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep27_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep28_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep28_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep28_Value1 = 0xA5A5A5A5\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep28_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep29_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep29_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep29_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep29_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep30_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep30_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep30_Value1 = 0xF1F1F1F1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep30_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep31_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep31_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep31_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep31_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep32_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep32_Value0 = 0x1FFFFC00\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep32_Value1 = 0xCC5533AA\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep32_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep33_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep33_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep33_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep33_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep34_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep34_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep34_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep34_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep35_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep35_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep35_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep35_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep36_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep36_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep36_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep36_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep37_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep37_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep37_Value1 = 0xA5A5A5A5\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep37_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep38_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep38_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep38_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep38_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep39_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep39_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep39_Value1 = 0xF1F1F1F1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep39_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep40_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep40_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep40_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep40_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  InitStep41_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep41_Value0 = 0x1FFFFC04\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep41_Value1 = 0x0050FFAF\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep41_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep42_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep42_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep42_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep42_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep43_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep43_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep43_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep43_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep44_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep44_Value0 = 0x4000280C\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep44_Value1 = 0x5C5CAABB\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep44_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  InitStep45_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep45_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep45_Value1 = 0x0000000A\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  InitStep45_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  NumExitSteps = 33\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep0_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep0_Value0 = 0x40002438\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep0_Value1 = 0x00000020\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep0_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep1_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep1_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep1_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep1_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep2_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep2_Value0 = 0x4000244C\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep2_Value1 = 0x40000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep2_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep3_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep3_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep3_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep3_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep4_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep4_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep4_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep4_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep5_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep5_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep5_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep5_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep6_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep6_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep6_Value1 = 0x96969696\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep6_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep7_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep7_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep7_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep7_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep8_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep8_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep8_Value1 = 0xEAEAEAEA\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep8_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep9_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep9_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep9_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep9_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep10_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep10_Value0 = 0x1FFFFC00\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep10_Value1 = 0x1234ABCD\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep10_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep11_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep11_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep11_Value1 = 0x000003E8\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep11_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep12_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep12_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep12_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep12_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep13_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep13_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep13_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep13_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep14_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep14_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep14_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep14_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep15_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep15_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep15_Value1 = 0xA5A5A5A5\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep15_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep16_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep16_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep16_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep16_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep17_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep17_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep17_Value1 = 0xF1F1F1F1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep17_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep18_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep18_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep18_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep18_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep19_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep19_Value0 = 0x1FFFFC00\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep19_Value1 = 0xCCAA3355\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep19_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep20_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep20_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep20_Value1 = 0x0000000A\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep20_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep21_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep21_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep21_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep21_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep22_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep22_Value0 = 0x40001014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep22_Value1 = 0x00000002\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep22_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep23_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep23_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep23_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep23_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  ExitStep24_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep24_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep24_Value1 = 0xA5A5A5A5\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep24_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep25_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep25_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep25_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep25_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ExitStep26_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep26_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep26_Value1 = 0xF1F1F1F1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep26_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep27_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep27_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep27_Value1 = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep27_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep28_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep28_Value0 = 0x1FFFFC04\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep28_Value1 = 0x0050FFAF\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep28_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep29_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep29_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep29_Value1 = 0x0000000A\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep29_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep30_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep30_Value0 = 0x40001018\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep30_Value1 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep30_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep31_Action = \"Write 32bit\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep31_Value0 = 0x4000280C\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep31_Value1 = 0x5C5CAABB\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep31_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  ExitStep32_Action = \"Delay\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep32_Value0 = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep32_Value1 = 0x0000000A\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ExitStep32_Comment = \"\"\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  UseScriptFile = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ScriptFile = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  UseRAM = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  RAMAddr = 0x20000000\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  RAMSize = 0x00008000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  CheckCoreID = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  CoreID = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  CoreIDMask = 0x0F000FFF\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  UseAutoSpeed = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ClockSpeed = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  EndianMode = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  ChipName = \"FMSH Devices %s\"\n"), str_DeviceName);
		Cmd_File.WriteString(csData);




		csData.Format(_T("[FLASH]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  aRangeSel[1] = 0-511\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  BankName = \"Flash Block \"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  BankSelMode = 1\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  BaseAddr = %s\n"), str_FlasgAddress);
		Cmd_File.WriteString(csData);

		csData.Format(_T("  NumBanks = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("[PRODUCTION]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  AutoPerformsErase = 1\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  AutoPerformsProgram = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  AutoPerformsSecure = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  AutoPerformsStartApp = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  AutoPerformsUnsecure = 0\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  AutoPerformsVerify = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  EnableFixedVTref = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  EnableTargetPower = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  EraseType = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  FixedVTref = 0x00000CE4\n"));
		Cmd_File.WriteString(csData);




		csData.Format(_T("  MonitorVTref = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  MonitorVTrefMax = 0x0000157C\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  MonitorVTrefMin = 0x000003E8\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  OverrideTimeouts = 0\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  ProgramSN = 0\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  SerialFile = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  SNAddr = 0x00000000\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  SNInc = 0x00000001\n"));
		Cmd_File.WriteString(csData);





		csData.Format(_T("  SNLen = 0x00000004\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  SNListFile = \"\"\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  SNValue = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  StartAppType = 1\n"));
		Cmd_File.WriteString(csData);


		csData.Format(_T("  TargetPowerDelay = 0x00000014\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  TimeoutErase = 0x00003A98\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  TimeoutProgram = 0x00002710\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  TimeoutVerify = 0x00002710\n"));
		Cmd_File.WriteString(csData);



		csData.Format(_T("  VerifyType = 1\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("[PERFORMANCE]\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  PerfromBlankCheckPriorEraseChip = 0x00000001\n"));
		Cmd_File.WriteString(csData);

		csData.Format(_T("  PerfromBlankCheckPriorEraseSelectedSectors = 0x00000000\n"));
		Cmd_File.WriteString(csData);



		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
		return true;
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return false;

	}
}


int CARM_OP_QCM::Execute_DL_Jflash(CString str_JflashFolderName, CString str_JflashName)
{
	this->Show_Status(_T("Download Jflash_FW ......"));
	this->Save_Trace_Log(_T("Download Jflash_FW ......"));
	this->Show_Out(_T("Download Jflash_FW ..."));

	CString csTemp = _T("");
	CString str_CMD = _T("");
	double dCurr_Percent = 0.0;
	wchar_t * wcpPercent = NULL;
	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	CString str_LogFile = _T("");
	str_LogFile.Format(_T("%s\\%s\\%d\\JflashResult.txt"), this->m_csCurr_Exe_Path, str_JflashFolderName, m_iClass_Idx);  

	//Jflashfile.jflash
	str_CMD.Format(_T("cmd.exe %cc %s\\%s\\%d\\JFlash.exe  -openprj\"%s\\%s\\%d\\%s\" -open%s,0x0000000 -erasechip -programverify -startapp -jflashlog\"%s\\%s\\%d\\JflashResult.txt\" -exit"), 
		'/', this->m_csCurr_Exe_Path, str_JflashFolderName, m_iClass_Idx, this->m_csCurr_Exe_Path, str_JflashFolderName, m_iClass_Idx, str_JflashName, m_csScat_Cfg_File_Path, this->m_csCurr_Exe_Path, str_JflashFolderName, m_iClass_Idx);


	this->Save_Trace_Log(str_CMD);

	CFileFind f;
	if (f.FindFile(str_LogFile))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile);
		if (DelBackValue == 0)
		{
			this->Save_Trace_Log(_T("Del JflashResult.txt fail!!!"));
			this->m_iError_Code = DL_FW_FAIL4;
			return RTN_FAIL;
		}
	}

	
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
		this->Save_Trace_Log(_T("Can not create DL JFlash.exe thread!\r\n"));
		this->Show_Status(_T("Download Jflash_FW FAIL;"));
		this->Save_Trace_Log(_T("Download Jflash_FW FAIL;"));
		this->Show_Out(_T("Download Jflash_FW FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		return RTN_FAIL;
	}
	else
	{
		WaitForSingleObject(pi.hProcess, 30000);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
	}
	Sleep(1000);



	int iFail = -1;
	CStdioFile file;
	if (!file.Open(str_LogFile, CFile::modeRead))
	{
		Save_Trace_Log(_T("FAIL: Unable to open JflashResult.txt!\r\n"));
		this->m_iError_Code = DL_FW_FAIL3;
		return RTN_FAIL;
	}
	CString str_info = _T("");

	while (file.ReadString(str_info))
	{
		this->Save_Trace_Log(str_info);

		str_info.MakeLower();

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("list of mcu devices read successfully"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.1;
			csTemp.Format(_T("List of MCU devices read successfully"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.1);
		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("project opened successfully"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.2;
			csTemp.Format(_T("Project opened successfully"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.2);
		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("connected successfully"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.3;
			csTemp.Format(_T("Connected successfully"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.3);

		}


		wcpPercent = wcsstr(str_info.GetBuffer(), _T("erase operation completed successfully"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.4;
			csTemp.Format(_T("Erase operation completed successfully"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.4);

		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("start of flash programming"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.5;
			csTemp.Format(_T("Start of flash programming"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.5);

		}


		wcpPercent = wcsstr(str_info.GetBuffer(), _T("end of flash programming"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.5;
			csTemp.Format(_T("End of flash programming"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.5);

		}


		wcpPercent = wcsstr(str_info.GetBuffer(), _T("reset: reset device"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.7;
			csTemp.Format(_T("Reset: Reset device"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.7);

		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("target application started"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 1.0;
			csTemp.Format(_T("Target application started"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(1.0);

		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("cannot"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.9;
			csTemp.Format(_T("download fail"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.9);

			this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
			this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
			this->m_iError_Code = DL_FW_FAIL4;
			iFail = 1;
		}


		wcpPercent = wcsstr(str_info.GetBuffer(), _T("fail"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.9;
			csTemp.Format(_T("download fail"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.9);

			this->m_csError_Code.Format(_T("FAIL, DL_FW,  Jlink Fail!"));
			this->Save_Trace_Log(_T("FAIL, DL_FW,  Jlink Fail!"));
			this->m_iError_Code = DL_FW_FAIL4;
			iFail = 1;
		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("error"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.9;
			csTemp.Format(_T("download fail"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.9);

			this->m_csError_Code.Format(_T("FAIL, DL_FW,  Jlink error!"));
			this->Save_Trace_Log(_T("FAIL, DL_FW,  Jlink error!"));
			this->m_iError_Code = DL_FW_FAIL4;
			iFail = 1;
		}

		wcpPercent = wcsstr(str_info.GetBuffer(), _T("not connected"));
		//
		if (wcpPercent != NULL)
		{
			dCurr_Percent = 0.9;
			csTemp.Format(_T("download fail"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(0.9);

			this->m_csError_Code.Format(_T("FAIL, DL_FW,  Jlink Link error!"));
			this->Save_Trace_Log(_T("FAIL, DL_FW,  Jlink Link error!"));
			this->m_iError_Code = DL_FW_FAIL4;
			iFail = 1;
		}

	}
	file.Close();

	if (iFail == 1)
	{
		this->Show_Progress(1.0);
		this->Show_Status(_T("Download Jflash_FW FAIL;"));
		this->Save_Trace_Log(_T("Download Jflash_FW FAIL;"));
		this->Show_Out(_T("Download Jflash_FW FAIL;"));
		return RTN_FAIL;
	}


	this->Show_Status(_T("Download Jflash_FW OK;"));
	this->Save_Trace_Log(_T("Download Jflash_FW OK;"));
	this->Show_Out(_T("Download Jflash_FW OK;"));
	this->Show_Progress(1.0);
	return RTN_SUCCESS;

}


int CARM_OP_QCM::DL_FW_ESP32_MCU_Smart(struct struct_ESP32_FileAddress * esp32_Struct)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 300;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach, str_ExeName;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;

	int P1(-1), P2(-1), Pos(0);


	try
	{
		//显示
		this->Show_Status(_T("Download ESP32_MCU file ......"));
		this->Save_Trace_Log(_T("Download ESP32_MCU file ......"));
		this->Show_Out(_T("Download ESP32_MCU file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_ESP32_MCU, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);


		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------

		//esptool.exe -p COM1 -b 115200 write_flash 0x00 quectel_ESP32_main.bin 0x180000 audio-esp.bin

		//扫码下载要稍微等模块压下后再做此处的处理
		Sleep(5000);

		//m_csMCU_Name

		if (esp32_Struct->iFileNums == 1)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash %s \"%s\""),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, 
				esp32_Struct->str_ESP32_Address1, esp32_Struct->str_ESP32_File1);
		} 
		else if (esp32_Struct->iFileNums == 2)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash %s \"%s\" %s \"%s\""),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, 
				esp32_Struct->str_ESP32_Address1, esp32_Struct->str_ESP32_File1,
				esp32_Struct->str_ESP32_Address2, esp32_Struct->str_ESP32_File2);
		}
		else if (esp32_Struct->iFileNums == 3)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash %s \"%s\" %s \"%s\" %s \"%s\""),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port,
				esp32_Struct->str_ESP32_Address1, esp32_Struct->str_ESP32_File1,
				esp32_Struct->str_ESP32_Address2, esp32_Struct->str_ESP32_File2,
				esp32_Struct->str_ESP32_Address3, esp32_Struct->str_ESP32_File3);
		}
		else if (esp32_Struct->iFileNums == 4)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash %s \"%s\" %s \"%s\" %s \"%s\" %s \"%s\""),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port,
				esp32_Struct->str_ESP32_Address1, esp32_Struct->str_ESP32_File1,
				esp32_Struct->str_ESP32_Address2, esp32_Struct->str_ESP32_File2,
				esp32_Struct->str_ESP32_Address3, esp32_Struct->str_ESP32_File3,
			    esp32_Struct->str_ESP32_Address4, esp32_Struct->str_ESP32_File4);
		}
		else if (esp32_Struct->iFileNums == 5)
		{
			swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM002\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d -b 460800 write_flash %s \"%s\" %s \"%s\" %s \"%s\" %s \"%s\" %s \"%s\""),
				'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port,
				esp32_Struct->str_ESP32_Address1, esp32_Struct->str_ESP32_File1,
				esp32_Struct->str_ESP32_Address2, esp32_Struct->str_ESP32_File2,
				esp32_Struct->str_ESP32_Address3, esp32_Struct->str_ESP32_File3,
				esp32_Struct->str_ESP32_Address4, esp32_Struct->str_ESP32_File4,
			    esp32_Struct->str_ESP32_Address5, esp32_Struct->str_ESP32_File5);
		}

		this->Save_Trace_Log(wcpCmd);
		this->Show_Out(wcpCmd);

		str_ExeName.Format(_T("esptool%d.exe"), this->m_iClass_Idx);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0, iTimeTemp = 0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;

			if (TRUE == ::PeekNamedPipe(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, 0, 0))
			{
				ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			}

			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csTemp = csData;

				//Writing at 0x00013111... (5  %)
				if ((NULL != wcsstr(csTemp, _T("Writing at")))
					&&
					(NULL != wcsstr(csTemp, _T("%)"))))
				{
					P1 = csTemp.Find(_T("("));
					if (P1 > 0)
					{
						csTemp = csTemp.Mid(P1 + 1);
						csTemp.Replace(_T(" "), _T(""));
						P2 = csTemp.Find(_T("%"));
						if (P2 > 0)
						{
							csTemp = csTemp.Left(P2);
							dCurr_Percent = _ttof(csTemp);
							dCurr_Percent = dCurr_Percent / 100.0;

							this->Show_Progress(dCurr_Percent);
						}
					}
				}


				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//csData.MakeLower();

				csTotal_Info += csData;

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//是否有“Connecting.. 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Connecting.."));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Connecting......."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Connecting......."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Detecting chip type... ESP32 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("ESP32"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Detecting chip type... ESP32"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Detecting chip type... ESP32"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//是否有“Configuring flash size”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Configuring flash size"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("Configuring flash size"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("Configuring flash size"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}



				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Hash of data verified"));
				//
				if (wcpPercent != NULL)
				{
					i_verified++;
					switch (i_verified)
					{
					case 1:
						dCurr_Percent = 0.3; break;
					case 2:
						dCurr_Percent = 0.6; break;
					case 3:
						dCurr_Percent = 0.9; break;
					default:
						dCurr_Percent = 0.1; break;
					}

					csTemp.Format(_T("Hash of data verified"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(dCurr_Percent);

					csTemp.Format(_T("Hash of data verified"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Leaving"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Downloading file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("downloading file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("downloading file..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("downloading file"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}
				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Leaving.
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Leaving"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}

				//Hard resetting via RTS pin..
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Hard resetting via RTS pin"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Failed to connect to Espressif device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Failed to connect to Espressif device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to connect to Espressif device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW_MCU, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}
			else
			{
				//------------------------------------------------
				time(&t_End);
				iTimeTemp = (int)difftime(t_End, t_Start);
				//
				if (iTimeTemp >= iTimeout)
				{
					//发个消息将esptool%d.exe文件杀掉
					bool bKill_Flag = false;
					bKill_Flag = m_cla_GFC.Kill_Process(str_ExeName);
					if (false == bKill_Flag)
					{
						csData.Format(_T("%s Del FAIL_1"), str_ExeName);
						this->Show_Out(csData);
					}
					else
					{
						csData.Format(_T("%s Del PASS_1"), str_ExeName);
						this->Show_Out(csData);
					}

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Get Data Timeout"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Get Data Timeout!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

				}

			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


bool CARM_OP_QCM::ESP32_Setting()
{

	CString str_ESP32_AllFile = _T("");
	int iESP32FileNums = 0;
	TraversFolderFile_ESP32(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T(".bin"), str_ESP32_AllFile);


	CString str_ESP32_Temp_File_All = _T("");
	str_ESP32_Temp_File_All = str_ESP32_AllFile;
	iESP32FileNums = str_ESP32_Temp_File_All.Replace(_T(";"), _T(";")) + 1;
	Mystruct_ESP32_FileAddress.iFileNums = iESP32FileNums;



	if (iESP32FileNums > 1)
	{
		for (int i = 0; i < iESP32FileNums; i++)
		{
			int a = 0;
			CString str_Nums = _T("");
			CString str_ESP32_File = _T("");
			str_Nums.Format(_T("%d"), i + 1);
			a = str_ESP32_Temp_File_All.Find(_T(";"));
			str_ESP32_File = str_ESP32_Temp_File_All.Left(a);

			if (i == iESP32FileNums - 1)
			{
				str_ESP32_File = str_ESP32_Temp_File_All;
			}
			else
			{
				str_ESP32_Temp_File_All = str_ESP32_Temp_File_All.Mid(a + 1);
			}



			if (_T("QDM548EAEF-EU-AAASM") == m_csOC )  //2个bin和address
			{
				CString str_Temp = _T("");
				str_Temp = str_ESP32_File.Mid(str_ESP32_File.ReverseFind('\\') + 1);

				if (str_Temp.Find(_T("_QUEC_ESP")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File1 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address1 = _T("0x00");
				}
				else if (str_Temp.Find(_T("_QUEC_WAV")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File2 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address2 = _T("0x180000");
				}
			}


			if (NULL != wcsstr(m_csOC, _T("QDM021")))  //3个bin和address
			{
				CString str_Temp = _T("");
				str_Temp = str_ESP32_File.Mid(str_ESP32_File.ReverseFind('\\') + 1);

				if (str_Temp.Find(_T("bootloader.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File1 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address1 = _T("0x1000");
				}
				else if (str_Temp.Find(_T("partition-table.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File2 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address2 = _T("0x8000");
				}
				else if (str_Temp.Find(_T("RH-RECD")) != -1)  //RH-RECD-03-00-00.bin
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File3 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address3 = _T("0x710000");
				}
			}

			if (_T("QDM054EARN-NA-AAAAA") == m_csOC || _T("QDM054EARN-EU-AAAAA") == m_csOC)  //4个bin和address
			{
				CString str_Temp = _T("");
				str_Temp = str_ESP32_File.Mid(str_ESP32_File.ReverseFind('\\') + 1);

				if (str_Temp.Find(_T("bootloader.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File1 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address1 = _T("0x1000");
				}
				else if (str_Temp.Find(_T("harald-upgrader.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File2 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address2 = _T("0x10000");
				}
				else if (str_Temp.Find(_T("partition-table.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File3 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address3 = _T("0x8000");
				}
				else if (str_Temp.Find(_T("ota_data_initial.bin")) != -1)
				{
					Mystruct_ESP32_FileAddress.str_ESP32_File4 = str_ESP32_File;
					Mystruct_ESP32_FileAddress.str_ESP32_Address4 = _T("0xd000");
				}
			}




		}
	} 
	else //<=1个bin
	{
		if (_T("QDM064EART-1G4-AAAAA") == m_csOC || _T("QDM064EART-G55-AAAAA") == m_csOC || _T("QDM065EABA-N06-AAAAA") == m_csOC || _T("QDM064EART-2G4-AAAAA") == m_csOC || _T("QDM064EART-2G4-BAAAA") == m_csOC)  //1个bin和address
		{
			Mystruct_ESP32_FileAddress.str_ESP32_File1 = str_ESP32_Temp_File_All;
			Mystruct_ESP32_FileAddress.str_ESP32_Address1 = _T("0x0");
		}
	}



	//判断是否文件为空
	if ( iESP32FileNums == 1 )
	{
		if (Mystruct_ESP32_FileAddress.str_ESP32_File1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1.Find(_T("0x"))==-1)
	    {
			this->m_csError_Code.Format(_T("Error, 1-Get ESP32 File Or Address fail!"));
			this->Show_Out(_T("Error, 1-Get ESP32 File Or Address fail!"));
			return false;
	    }	
	}
	else if (iESP32FileNums == 2)
	{
		if (Mystruct_ESP32_FileAddress.str_ESP32_File1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2.Find(_T("0x")) == -1
			)
		{
			this->m_csError_Code.Format(_T("Error, 2-Get ESP32 File Or Address fail!"));
			this->Show_Out(_T("Error, 2-Get ESP32 File Or Address fail!"));
			return false;
		}
	}
	else if (iESP32FileNums == 3)
	{
		if (Mystruct_ESP32_FileAddress.str_ESP32_File1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3.Find(_T("0x")) == -1
			)
		{
			this->m_csError_Code.Format(_T("Error, 3-Get ESP32 File Or Address fail!"));
			this->Show_Out(_T("Error, 3-Get ESP32 File Or Address fail!"));
			return false;
		}
	}
	else if (iESP32FileNums == 4)
	{
		if (Mystruct_ESP32_FileAddress.str_ESP32_File1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File4 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address4 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address4.Find(_T("0x")) == -1
			)
		{
			this->m_csError_Code.Format(_T("Error, 4-Get ESP32 File Or Address fail!"));
			this->Show_Out(_T("Error, 4-Get ESP32 File Or Address fail!"));
			return false;
		}
	}
	else if (iESP32FileNums == 5)
	{
		if (Mystruct_ESP32_FileAddress.str_ESP32_File1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address1.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address2.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address3.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File4 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address4 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address4.Find(_T("0x")) == -1
			|| Mystruct_ESP32_FileAddress.str_ESP32_File5 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address5 == _T("") || Mystruct_ESP32_FileAddress.str_ESP32_Address5.Find(_T("0x")) == -1
			)
		{
			this->m_csError_Code.Format(_T("Error, 5-Get ESP32 File Or Address fail!"));
			this->Show_Out(_T("Error, 5-Get ESP32 File Or Address fail!"));
			return false;
		}
	}
	else
	{
		this->m_csError_Code.Format(_T("Error, Get ESP32 File Or Address fail!"));
		this->Show_Out(_T("Error, Get ESP32 File Or Address fail!"));
		return false;
	}

	return true;
}


int CARM_OP_QCM::Erase_FW_ESP32_MCU()
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 120;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Erase ESP32_MCU ......"));
		this->Save_Trace_Log(_T("Erase ESP32_MCU file ......"));
		this->Show_Out(_T("Erase ESP32_MCU file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, Erase_ESP32_MCU, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);


		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		/*
		user@ubuntu:-/ Perforce / leven / depot9 / Embedded / espressif / esp32 / temp / QDM021 / esp - idf - 387367S esptool.py --port / dev / ttyUSBe erase_flash
		esptool.py v2.9 - dev
		Serial port / dev / ttyUSBe
		Connecting..
		Detecting chip type... ESP32
		Chip is ESP32 - DOWD - V3(revision 3)
		Features : WiFi, BT, Dual Core, 249MHz, VRef calibration in efuse, Coding Scheme None
		Crystal is 40MHz
		MAC : Θc : dc : 7e : C4 : 70 : 54
		Uploading stub...
		Running stub...
		Stub running..
		Erasing flash(this may take a while)...
		chip erase completed successfully in 52.5s
		Hard resetting via RTS pin...
		user@ubuntu:-/ Perforce / leven / depot9 / Embedded / espressif / esp32 / temp / QDM021 / esp - idf - 387367$
		*/

		//扫码下载要稍微等模块压下后再做此处的处理
		Sleep(5000);


		swprintf(wcpCmd, _T("cmd.exe %cc %s\\QDM021\\%d\\esptool-v3.2-win64\\esptool%d.exe -p COM%d  erase_flash"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port);

		this->Save_Trace_Log(wcpCmd);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, Erase_ESP32_MCU, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL2;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);



				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				//csData.MakeLower();

				csTotal_Info += csData;

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Erase_FW, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, Erase_FW, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//是否有“Connecting.. 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Connecting.."));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Connecting......."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Connecting......."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//Failed...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Failed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Erase_FW, Failed!"));
					this->Save_Trace_Log(_T("FAIL, Erase_FW, Failed!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//是否有“Detecting chip type... ESP32 开始”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("ESP32"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Detecting chip type... ESP32"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Detecting chip type... ESP32"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}


				//Erasing device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Erasing flash (this may take a while)"));
				//
				if (wcpPercent != NULL)
				{
					i_verified++;
					switch (i_verified)
					{
					case 1:
						dCurr_Percent = 0.3; break;
					case 2:
						dCurr_Percent = 0.6; break;
					case 3:
						dCurr_Percent = 0.9; break;
					default:
						dCurr_Percent = 0.1; break;
					}

					csTemp.Format(_T("Erasing flash (this may take a while);"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(dCurr_Percent);

					csTemp.Format(_T("Erasing flash (this may take a while);"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}





				//Erasing done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Chip erase completed successfully"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("erasing done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				//Hard resetting via RTS pin..
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Hard resetting via RTS pin"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Failed to connect to Espressif device
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("Failed to connect to Espressif device"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to connect to Espressif device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to connect to Espressif device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW_MCU, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Execute_DL_JTAG(CString str_JTAG_CMD_FolderName)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Download Fw file ......"));
		this->Save_Trace_Log(_T("Download Fw file ......"));
		this->Show_Out(_T("Download Fw file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\%s\\%d\\FlashPro-Dos.exe auto -fc%s\\%s\\%d\\config.ini"),
			'/', this->m_csCurr_Exe_Path, str_JTAG_CMD_FolderName, m_iClass_Idx, this->m_csCurr_Exe_Path, str_JTAG_CMD_FolderName, m_iClass_Idx);

		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				this->Show_Progress(0.5);

				//Reading Code File ...........................	 done
				//是否有“Reading Code File ...........................    done”关键词
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("reading code file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("Reading Code File"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("Reading Code File"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

				}

				//JTAG communication initialization....	 OK
				//是否有“jtag communication initialization....            JTAG communication initialization....	 OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("jtag communication initialization....	 ok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("connecting jtag ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("JTAG communication initialization....	 OK"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Open file or read error
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("open file or read error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("Open file or read error!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Open file or read error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Open file or read error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Autoprogram execution...
				//Autoprogram execution... Autoprogram execution...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T(" autoprogram execution"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("Autoprogram execution..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("Autoprogram execution..."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Erasing memory
				//Erasing done   Erasing memory ........................	 done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("erasing memory"));
				//
				if (wcpPercent != NULL && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("done"))))
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("erasing ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("Erasing memory ........................	 done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Program terminated
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("program terminated"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download Program terminated"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Program terminated!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Program terminated!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				//Flash programming ....................	 done
				//Flash programming ....................   done            Flash programming ....................	 done
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("flash programming ....................	 done"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("Flash programming ....................	 done"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					bSuccess_Flag = true;//pass
					break;//退出while
				}

				//Verifying check sum ...................	 OK
				//Verifying check sum ...................  OK               Verifying check sum ...................	 OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("verifying check sum ...................	 ok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Verifying check sum ...................	 OK"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("Verifying check sum ...................	 OK"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Finished. Bye.
				//Finished. Bye.
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("finished. bye."));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("Download Finished. Bye."));

					

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				
			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
				this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}


		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Modify_FileContent(CString str_TargetFile, CString str_NeedMidfyLocationMark, CString str_RepaceText)
{
	CStdioFile file;
	if (!file.Open(str_TargetFile, CFile::modeReadWrite))
	{
		CString Temp_Show = _T("");
		Temp_Show.Format(_T("Read FAIL: Unable to open %s!\r\n"), str_TargetFile);
		Save_Trace_Log(Temp_Show);
		this->m_iError_Code = DL_FW_FAIL3;
		this->m_csError_Code.Format(Temp_Show);
		return RTN_FAIL;
	}

	CString str_info = _T("");
	CString str_All = _T("");

	while (file.ReadString(str_info))
	{
		if (str_info.Find(str_NeedMidfyLocationMark) != -1)
		{
			str_info.Replace(str_info.Mid(str_info.Find(str_NeedMidfyLocationMark) + str_NeedMidfyLocationMark.GetLength()), str_RepaceText);
		}

		str_All = str_All + str_info + _T("\n");

	}
	file.Close();


	CStdioFile Cmd_File;

	if (Cmd_File.Open(str_TargetFile, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.WriteString(str_All);
		Sleep(1000);
	}
	else
	{
		CString Temp_Show = _T("");
		Temp_Show.Format(_T("Write FAIL: Unable to open %s!\r\n"), str_TargetFile);
		Save_Trace_Log(Temp_Show);
		this->m_iError_Code = DL_FW_FAIL3;
		this->m_csError_Code.Format(Temp_Show);
		return RTN_FAIL;
	}

	Cmd_File.Close();

	return RTN_SUCCESS;
}


int CARM_OP_QCM::Execute_DL_FLHubTool(CString str_FLHubTool_FolderName)
{
	this->Show_Status(_T("FLHubTool Download FW ......"));
	this->Save_Trace_Log(_T("FLHubTool Download FW ......"));
	this->Show_Out(_T("FLHubTool Download FW ..."));


	m_cla_GFC.Kill_Process(_T("cmd.exe"));


	CString csTemp = _T("");
	CString str_CMD = _T("");

	double dCurr_Percent = 0.0;
	CString str_LogFile = _T("");

	str_LogFile.Format(_T("%s\\%s\\%d\\FLHubTool_LOG.txt"), this->m_csCurr_Exe_Path, str_FLHubTool_FolderName, m_iClass_Idx);


	CFileFind f;
	if (f.FindFile(str_LogFile))
	{
		BOOL bDelResult = FALSE;
		bDelResult = DeleteFile(str_LogFile);
		if (bDelResult == FALSE)
		{
			this->Show_Status(_T("Del FLHubTool Log FAIL;"));
			this->Save_Trace_Log(_T("Del FLHubTool Log FAIL;"));
			this->Show_Out(_T("Del FLHubTool Log FAIL;"));
			this->m_iError_Code = DL_FW_FAIL4;
			return RTN_FAIL;
		}
	}


	str_CMD.Format(_T("cmd.exe /c %s\\%s\\%d\\FLHubTool.exe -DEV_0 -FIRMWARE_PC -UPDATE %s"),
		this->m_csCurr_Exe_Path, str_FLHubTool_FolderName, m_iClass_Idx, this->m_csScat_Cfg_File_Path);


	this->Save_Trace_Log(str_CMD);



	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
		this->Show_Status(_T("FLHubTool Download FW FAIL;"));
		this->Save_Trace_Log(_T("FLHubTool Download FW FAIL;"));
		this->Show_Out(_T("FLHubTool Download FW FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		str_CMD.ReleaseBuffer();
		return RTN_FAIL;
	}
	else
	{
		WaitForSingleObject(pi.hProcess, 100000); //空板第一次烧录时间很长，大概需要90秒 。 复测只要3-5秒 Daniel 20230331
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		str_CMD.ReleaseBuffer();
	}
	//Sleep(1500);



	m_cla_GFC.Kill_Process(_T("cmd.exe"));


	int iFail = 1;
	CStdioFile file;
	if (!file.Open(str_LogFile, CFile::modeRead))
	{
		this->Show_Status(_T("FAIL: Unable to open FLHubTool_LOG.txt!"));
		this->Save_Trace_Log(_T("FAIL: Unable to open FLHubTool_LOG.txt!"));
		this->Show_Out(_T("FAIL: Unable to open FLHubTool_LOG.txt!"));
		this->m_iError_Code = DL_FW_FAIL3;
		return RTN_FAIL;
	}
	CString str_info = _T("");

	while (file.ReadString(str_info))
	{
		this->Save_Trace_Log(str_info);

		str_info.MakeLower();

		if (str_info.Find(_T("update complete")) != -1)
		{
			iFail = 0;
			dCurr_Percent = 1.0;
			csTemp.Format(_T("Update Complete"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(1.0);
		}
	}
	file.Close();

	if (iFail == 0)
	{
		this->Show_Status(_T("FLHubTool Download FW OK;"));
		this->Save_Trace_Log(_T("FLHubTool Download FW OK;"));
		this->Show_Out(_T("FLHubTool Download FW OK;"));
		this->Show_Progress(1.0);

		return RTN_SUCCESS;
	}

	if (iFail == 1)
	{
		this->Show_Progress(1.0);
		this->Show_Status(_T("FLHubTool Download FW FAIL;"));
		this->Save_Trace_Log(_T("FLHubTool Download FW FAIL;"));
		this->Show_Out(_T("FLHubTool Download FW FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		return RTN_FAIL;
	}


	return RTN_FAIL;
}


int CARM_OP_QCM::DL_FW_MCU_All()
{
	//------------------------------
	try
	{
		//进度条置零
		this->Show_Progress(0.0);

		int iDL_Flag = RTN_FAIL;

		if (NULL != wcsstr(m_csOC, _T("QDM041"))) //20221114 Daniel
		{
			if (this->Execute_DL_Jlink(_T("QDM041")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM041_Jlink Fail"));
				this->Show_Out(_T("QDM041_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM041_Jlink Pass"));
				this->Show_Out(_T("QDM041_Jlink Pass"));
			}
		}

		else if (NULL != wcsstr(m_csOC, _T("QDC002"))
			|| (_T("QDC004EAXC-I01-AAAAA") == m_csOC)  
			|| (_T("QDC004EAXD-TI-AAAAA") == m_csOC)  //20230518 Daniel
			) //20221210 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink_Newest")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jlink Fail"));
				this->Show_Out(_T("Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jlink Pass"));
				this->Show_Out(_T("Flash_Jlink Pass"));
			}
		}

		else if (_T("QDM062EABL-D08-AAAAA") == m_csOC
			) //20230419 Daniel
		{

			if (this->Execute_DL_Jflash(_T("QDM027"), _T("QDM062_Jflashfile.jflash")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jflash Fail"));
				this->Show_Out(_T("Flash_Jflash Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jflash Pass"));
				this->Show_Out(_T("Flash_Jflash Pass"));
				Sleep(6000);
			}

			//if (this->Execute_DL_Jlink(_T("QDM538")) != RTN_SUCCESS)
			//{
			//	iDL_Flag = RTN_FAIL;
			//	Save_Trace_Log(_T("Flash_Jlink Fail"));
			//	this->Show_Out(_T("Flash_Jlink Fail"));
			//}
			//else
			//{
			//	iDL_Flag = RTN_SUCCESS;
			//	Save_Trace_Log(_T("Flash_Jlink Pass"));
			//	this->Show_Out(_T("Flash_Jlink Pass"));
			//}

		}

		else if (_T("QDM551EABL-QNA-AAAAA") == m_csOC
			) //20231128 Daniel
		{

			if (this->Execute_DL_Jflash(_T("QDM027"), _T("QDM551_Jflashfile.jflash")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jflash Fail"));
				this->Show_Out(_T("Flash_Jflash Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jflash Pass"));
				this->Show_Out(_T("Flash_Jflash Pass"));
				Sleep(6000);
			}
		}

		else if (_T("QDM078EAEN-IOT-AAAAA") == m_csOC
			) //20231128 Daniel
		{
			if (this->Execute_DL_Jflash(_T("QDM027"), _T("QDM078_Jflashfile.jflash")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jflash Fail"));
				this->Show_Out(_T("Flash_Jflash Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jflash Pass"));
				this->Show_Out(_T("Flash_Jflash Pass"));
				Sleep(6000);
			}
		}


		else if (NULL != wcsstr(m_csOC, _T("QDM027"))
			) //20221226 Daniel
		{
			if (this->Execute_DL_Jflash(_T("QDM027"), _T("Jflashfile.jflash")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Jflash Fail"));
				this->Show_Out(_T("Flash_Jflash Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Flash_Jflash Pass"));
				this->Show_Out(_T("Flash_Jflash Pass"));
				Sleep(6000);
			}
		}

		else if (_T("QDC519SASE-E53-A2SUB") == m_csOC) //20230312 Daniel 税控板烧录
		{
			CString str_JTAGConfigFile_Orig = _T("");
			CString str_JTAGConfigFile = _T("");
			str_JTAGConfigFile_Orig.Format(_T("%s\\QDC519\\%d\\Orig\\config.ini"), this->m_csCurr_Exe_Path, m_iClass_Idx);
			str_JTAGConfigFile.Format(_T("%s\\QDC519\\%d\\config.ini"), this->m_csCurr_Exe_Path, m_iClass_Idx);
			CopyFile(str_JTAGConfigFile_Orig, str_JTAGConfigFile, FALSE);

			CString str_MCU_FullPathName = m_csScat_Cfg_File_Path;
			str_MCU_FullPathName.Replace(_T(".hex.txt"), _T(".txt"));
			if (this->Modify_FileContent(str_JTAGConfigFile, _T("CodeFileName		"), str_MCU_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("Flash_Config Write Fail"));
				this->Show_Out(_T("Flash_Config Write Fail"));
			}
			else
			{
				if (this->Execute_DL_JTAG(_T("QDC519")) != RTN_SUCCESS)
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("Flash_JTAG Fail"));
					this->Show_Out(_T("Flash_JTAG Fail"));
				}
				else
				{
					iDL_Flag = RTN_SUCCESS;
					Save_Trace_Log(_T("Flash_JTAG Pass"));
					this->Show_Out(_T("Flash_JTAG Pass"));
				}
			}
		}

		else if (_T("QDC518GLSD-U60-AABAS") == m_csOC 
			|| _T("QDC518GLSD-U60-BABAS") == m_csOC
			|| _T("QDC523SPSW-U67-AAAAA") == m_csOC
			) //20230314 Daniel
		{
			if (this->Execute_DL_FLHubTool(_T("QDC518")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("FLHubTool Flash_FW Fail"));
				this->Show_Out(_T("FLHubTool Flash_FW Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("FLHubTool Flash_FW Pass"));
				this->Show_Out(_T("FLHubTool Flash_FW Pass"));
			}
		}

		else if (_T("QDM042AUBL-D01-AAAAA") == m_csOC
			) //20230504 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM042 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM042 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM042 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM042 Flash_Jlink Pass"));
			}
		}

		else if (_T("QDE016EAEF-F81-AAAAA") == m_csOC
			|| _T("QDE016EAEF-F81-BAAAA") == m_csOC
			) //20230510 Daniel
		{
			if (this->Execute_DL_CCSLOAD(_T("CCSLOAD"), m_csScat_Cfg_File_Path) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDE016 CCSLOAD Flash_MCU Fail"));
				this->Show_Out(_T("QDE016 CCSLOAD Flash_MCU Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDE016 CCSLOAD Flash_MCU Pass"));
				this->Show_Out(_T("QDE016 CCSLOAD Flash_MCU Pass"));
			}
		}

		else if (_T("QDM063EABA-N06-AAAAA") == m_csOC //
			|| _T("QDM063EABA-N06-AAASM") == m_csOC //20231102
			) //20230512 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM063 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM063 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM063 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM063 Flash_Jlink Pass"));
			}
		}

		else if (_T("QDM066EPBK-I03-AAAAA") == m_csOC
			) //20230627 Daniel
		{
			if (this->Execute_DL_Jlink(_T("Jlink")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM066 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM066 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM066 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM066 Flash_Jlink Pass"));
			}
		}

		else if (_T("QDM536CNEG-I05-AAAAA") == m_csOC
			|| _T("QDM536CNEG-I05-BBAAA") == m_csOC
			) //20230807 Daniel
		{
			if (this->Execute_DL_Jlink(_T("QDM536")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM536 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM536 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM536 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM536 Flash_Jlink Pass"));
			}
		}

		else if ((_T("QDC519SASE-E53-AAASM") == m_csOC)
			|| (_T("QDC519SASE-E53-BAASM") == m_csOC)
			|| (_T("QDC519SASE-E53-CAASM") == m_csOC)
			|| (_T("QDC519SASE-E53-DAASM") == m_csOC))
		{
			//UpdateRomSetting
			if (this->UpdateRomSetting() != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519 Flash Config txt or SunmiCrp Fail"));
				this->Show_Out(_T("QDC519 Flash Config txt or SunmiCrp Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519 Flash Config txt or SunmiCrp Pass"));
				this->Show_Out(_T("QDC519 Flash Config txt or SunmiCrp Pass"));
			}
		}

		else if ((_T("QDC519SASE-E53-AAAAA") == m_csOC)
			|| (_T("QDC519SASE-E53-BAAAA") == m_csOC)
			|| (_T("QDC519SASE-E53-CAAAA") == m_csOC)
			|| (_T("QDC519SASE-E53-DAAAA") == m_csOC))
		{
			if (this->GetSunmiDLResult() != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519 Flash Financial firmware Fail"));
				this->Show_Out(_T("QDC519 Flash Financial firmware Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519 Flash Financial firmware Pass"));
				this->Show_Out(_T("QDC519 Flash Financial firmware Pass"));
			}
		}

		else if ((_T("QDE017EABL-N07-AAAAA") == m_csOC))
		{
			CString  strBackData = _T("");

			if (this->Execute_DL_PICkit(_T("Mplab_PICKit"), _T("PK4"), _T("ATtiny202"), strBackData) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDE017 Mplab_PICKit Flash firmware Fail"));
				this->Show_Out(_T("QDE017 Mplab_PICKit Flash firmware Fail"));
			}
			else
			{
				Save_Trace_Log(_T("QDE017 Mplab_PICKit Flash firmware OK"));
				this->Show_Out(_T("QDE017 Mplab_PICKit Flash firmware OK"));

				CString str_LogName = _T("");
				str_LogName.Format(_T("%s_PCBA_DL_device_ltc_cloud.txt"), str_InputSN);

				if (strBackData.Find(_T("programming/verify complete")) != -1 && FileAppendStr(GetExeFilePath() + _T("\\QDE017\\") + str_LogName, _T("\"ATTINY_verify\":\"successful\"\r\n}\r\n")) == RTN_SUCCESS)
				{
					if (QDE017_PushBinFile() == RTN_SUCCESS) //DM口
					{
						Save_Trace_Log(_T("QDE017 Push Bin file Pass"));
						this->Show_Out(_T("QDE017 Push Bin file Pass"));

						if (Xmodem_transferfiles(_T("QDE017")) == RTN_SUCCESS)
						{
							Save_Trace_Log(_T("QDE017 Xmodem file Pass"));
							this->Show_Out(_T("QDE017 Xmodem file Pass"));

							if (ComPort_SendCmd(_T("Close USB ..."), this->m_iCom_Port_Auto_Sec, _T("!user func usbdis"), _T("OK")) == RTN_SUCCESS)
							{
								iDL_Flag = RTN_SUCCESS;
								this->Show_Status(_T("QDE017 Close USB Pass"));
								this->Show_Out(_T("QDE017 Close USB Pass"));
								this->Save_Trace_Log(_T("QDE017 Close USB Pass"));
							}
							else
							{
								iDL_Flag = RTN_FAIL;
								this->Show_Status(_T("QDE017 Close USB Fail"));
								this->Show_Out(_T("QDE017 Close USB Fail"));
								this->Save_Trace_Log(_T("QDE017 Close USB Fail"));
							}

						}
						else
						{
							iDL_Flag = RTN_FAIL;
							Save_Trace_Log(_T("QDE017 Xmodem file Fail"));
							this->Show_Out(_T("QDE017 Xmodem file Fail"));
						}
					}
					else
					{
						iDL_Flag = RTN_FAIL;
						Save_Trace_Log(_T("QDE017 Push Bin file Fail"));
						this->Show_Out(_T("QDE017 Push Bin file Fail"));
					}
				}
				else
				{
					iDL_Flag = RTN_FAIL;
				}
			}

		}

		else if (_T("QDM039NAST-E53-AAASM") == m_csOC
			|| (_T("QDM039SAST-NA-ASASM") == m_csOC)
			|| (0 == wcscmp(m_csOC, _T("QDM039SAST-NA-BDASM")))  //20231016 
			|| (0 == wcscmp(m_csOC, _T("QDM039SAST-NA-BSASM")))  //20231016
			) //20230728 Daniel
		{
			if (this->CheckPushBinVer(1) == RTN_SUCCESS)
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("Check Push File Ver Pass, No need to burn the file again;"));
				this->Show_Out(_T("Check Push File Ver Pass, No need to burn the file again;"));
			} 
			else
			{
				CString str_ReturnData = _T("");
				str_ReturnData = COM_Query_Result(_T("Entry Bootloader Mode"), m_iCom_Port, 115200, 3, _T("fw_update\r\n"));
				if (str_ReturnData != _T("") && str_ReturnData.Find(_T("C")) != -1)
				{
					Save_Trace_Log(_T("QDM039 Entry Bootloader Mode OK"));
					this->Show_Out(_T("QDM039 Entry Bootloader Mode OK"));

					if (this->COM_Modem_PushBin(_T("YModem Push File..."), m_iCom_Port, _T("115200"), _T("4")) != RTN_SUCCESS)
					{
						Save_Trace_Log(_T("QDM039 Push File Fail"));
						this->Show_Out(_T("QDM039 Push File Fail"));
					}
					else
					{
						Save_Trace_Log(_T("QDM039 Push File Pass"));
						this->Show_Out(_T("QDM039 Push File Pass"));

						if (this->CheckPushBinVer(0) != RTN_SUCCESS)
						{
							iDL_Flag = RTN_FAIL;
							Save_Trace_Log(_T("Check Push File Ver Fail"));
							this->Show_Out(_T("Check Push File Ver Fail"));
						}
						else
						{
							iDL_Flag = RTN_SUCCESS;
							Save_Trace_Log(_T("Check Push File Ver Pass"));
							this->Show_Out(_T("Check Push File Ver Pass"));
						}
					}
				}
				else
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("QDM039 Entry Bootloader Mode Fail"));
					this->Show_Out(_T("QDM039 Entry Bootloader Mode Fail"));
				}
			}
			

		}

		else if (_T("QDM547EPEM-I05-AAAAA") == m_csOC)
		{
			if (this->bk_loader_Image(m_csScat_Cfg_File_Path) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM547 Flash firmware Fail"));
				this->Show_Out(_T("QDM547 Flash firmware Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM547 Flash firmware Pass"));
				this->Show_Out(_T("QDM547 Flash firmware Pass"));
			}
		}

		else if (_T("QDM025NASP-E53-AAAAA") == m_csOC)
		{
			if (this->Run_QDM025_FastbootCMD() != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM025 Flash firmware Fail"));
				this->Show_Out(_T("QDM025 Flash firmware Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM025 Flash firmware Pass"));
				this->Show_Out(_T("QDM025 Flash firmware Pass"));
				//显示
				this->Show_Status(_T("Fastboot reboot 45s ......"));
				this->Save_Trace_Log(_T("Fastboot reboot 45s ......"));
				this->Show_Out(_T("Fastboot reboot 45s ..."));
				Sleep(45000);
			}
		}

		else if (_T("QDM523CNEM-N05-FMASM") == m_csOC)
		{
			if (this->FRDownload_Image(this->m_iCom_Port,  115200, m_csScat_Cfg_File_Path, _T("800X")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM523 FRDownload_Image Fail"));
				this->Show_Out(_T("QDM523 FRDownload_Image Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM523 FRDownload_Image Pass"));
				this->Show_Out(_T("QDM523 FRDownload_Image Pass"));
			}
		}

		else if (_T("QDM536CNEM-IOT-AAAASM") == m_csOC)
		{


			CString strBinfileFullPathName = _T("");
			TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("_BT_"), strBinfileFullPathName); //_T("_536iic_")

			if (strBinfileFullPathName == _T("") || strBinfileFullPathName == _T(" ") || strBinfileFullPathName.IsEmpty())
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM536 bt bin file not found"));
				this->Show_Out(_T("QDM536 bt bin file not found"));
			}
			else
			{
				if (this->FRDownload_Image(this->m_iCom_Port, 115200, strBinfileFullPathName, _T("801H")) != RTN_SUCCESS)
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("QDM536 FRDownload_Image Fail"));
					this->Show_Out(_T("QDM536 FRDownload_Image Fail"));
				}
				else
				{
					iDL_Flag = RTN_SUCCESS;
					Save_Trace_Log(_T("QDM536 FRDownload_Image Pass"));
					this->Show_Out(_T("QDM536 FRDownload_Image Pass"));
				}
			}


			if (RTN_SUCCESS == iDL_Flag)
			{
				if (SendComCmd(_T("Enter GD32 Burn Mode..."), m_iCom_Port_Auto_Sec, 115200, false, true,  _T("AT+QCANFDL=1"), _T("OK")) == RTN_SUCCESS)
				{
					if (this->Execute_DL_Jlink(_T("QDM536")) != RTN_SUCCESS)
					{
						iDL_Flag = RTN_FAIL;
						Save_Trace_Log(_T("QDM536 Flash_Jlink Fail"));
						this->Show_Out(_T("QDM536 Flash_Jlink Fail"));
					}
					else
					{
						iDL_Flag = RTN_SUCCESS;
						Save_Trace_Log(_T("QDM536 Flash_Jlink Pass"));
						this->Show_Out(_T("QDM536 Flash_Jlink Pass"));
					}
				}
				else
				{
					iDL_Flag = RTN_FAIL;
				}
			}



			/*
			this->Show_Status(_T("wait 8s ......"));
			this->Save_Trace_Log(_T("wait 8s ......"));
			this->Show_Out(_T("wait 8s ..."));
			Sleep(8000);

			if (this->Execute_DL_Jlink(_T("QDM536")) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM536 Flash_Jlink Fail"));
				this->Show_Out(_T("QDM536 Flash_Jlink Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM536 Flash_Jlink Pass"));
				this->Show_Out(_T("QDM536 Flash_Jlink Pass"));
			}


			if (RTN_SUCCESS == iDL_Flag)
			{
				AfxMessageBox(_T("请重新下压夹具后，请关闭此窗口"));
				CString strBinfileFullPathName = _T("");
				TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("_BT_"), strBinfileFullPathName); //_T("_536iic_")

				if (strBinfileFullPathName == _T("") || strBinfileFullPathName == _T(" ") || strBinfileFullPathName.IsEmpty())
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("QDM536 bt bin file not found"));
					this->Show_Out(_T("QDM536 bt bin file not found"));
				}
				else
				{
					if (this->FRDownload_Image(this->m_iCom_Port, 115200, strBinfileFullPathName, _T("801H")) != RTN_SUCCESS)
					{
						iDL_Flag = RTN_FAIL;
						Save_Trace_Log(_T("QDM536 FRDownload_Image Fail"));
						this->Show_Out(_T("QDM536 FRDownload_Image Fail"));
					}
					else
					{
						iDL_Flag = RTN_SUCCESS;
						Save_Trace_Log(_T("QDM536 FRDownload_Image Pass"));
						this->Show_Out(_T("QDM536 FRDownload_Image Pass"));
					}
				}
			}
			*/

		}

		else if (_T("QDM055EAEQ-N03-AAASM") == m_csOC)
		{
			if (this->QDM055_CustomerFlowTest() != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM055 CustomerFlowTest Fail"));
				this->Show_Out(_T("QDM055 CustomerFlowTest Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM055 CustomerFlowTest Pass"));
				this->Show_Out(_T("QDM055 CustomerFlowTest Pass"));
			}

		}

		else if (_T("QDM046EARN-BAS-AAASM") == m_csOC)
		{
			if (this->QDM046_CustomerFlowTest() != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 CustomerFlowTest Fail"));
				this->Show_Out(_T("QDM046 CustomerFlowTest Fail"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 CustomerFlowTest Pass"));
				this->Show_Out(_T("QDM046 CustomerFlowTest Pass"));
			}

		}


		else if (_T("QDE507SPAK-U61-BAAAA") == m_csOC ) //20231211 Daniel
			{
				if (this->Execute_DL_Jlink(_T("Jlink")) != RTN_SUCCESS)
				{
					iDL_Flag = RTN_FAIL;
					Save_Trace_Log(_T("QDE507 Flash_Jlink Fail"));
					this->Show_Out(_T("QDE507 Flash_Jlink Fail"));
				}
				else
				{
					iDL_Flag = RTN_SUCCESS;
					Save_Trace_Log(_T("QDE507 Flash_Jlink Pass"));
					this->Show_Out(_T("QDE507 Flash_Jlink Pass"));
				}
		}

		else
		{
			iDL_Flag = RTN_FAIL;
			Save_Trace_Log(_T("There is no matching product model;"));
			this->Show_Out(_T("There is no matching product model;"));
		}

		return iDL_Flag;

	}
	catch (...)
	{
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}


void CARM_OP_QCM::TraversFolderFile_ESP32(CString str_TargetPath, CString str_FileMark, CString & strFilePath)
{
	CFileFind finder;
	CString strWildcard(str_TargetPath);
	strWildcard += _T("//*.*");

	BOOL bWorking = finder.FindFile(strWildcard);

	int i = 0;
	while (bWorking)
	{
		//如果还有文件存在就执行下面的
		bWorking = finder.FindNextFile();
		if (finder.IsDots()) //如果是. 或者.. 就continue
		{
			bWorking = finder.FindNextFile();
			continue;
		}
		//一般文件及文件夹

		BOOL bisDir = finder.IsDirectory();
		if (bisDir)
		{ //是文件夹
			CString repath = finder.GetFilePath();
			TraversFolderFile_ESP32(repath, str_FileMark, strFilePath);
		}
		else
		{//是文件
			//do parse
			CString repath = finder.GetFilePath(); //eg return c:/myhtml/myfile.txt
			//CString repath = finder.GetFileName(); //eg return myfile.txt
			if (wcsstr(repath, str_FileMark) != NULL)
			{
				if (strFilePath.IsEmpty())
				{
					strFilePath = repath;
				}
				else
				{
					strFilePath = strFilePath + _T(";") + repath;
				}

			}
		}


	}//end while
	finder.Close();
	return;
}


int CARM_OP_QCM::Execute_DL_CCSLOAD(CString str_ToolFolderName, CString str_FW_FullPathName)
{
	
	this->Show_Status(_T("CCSLOAD Tool Download FW ......"));
	this->Save_Trace_Log(_T("CCSLOAD Tool Download FW ......"));
	this->Show_Out(_T("CCSLOAD Tool Download FW ..."));


	m_cla_GFC.Kill_Process(_T("ccsload.exe"));


	CString csTemp = _T("");
	CString str_CMD = _T("");

	double dCurr_Percent = 0.0;
	CString str_LogFile = _T("");

	str_LogFile.Format(_T("%s\\%s\\CCSLOAD_LOG.txt"), this->m_csCurr_Exe_Path, str_ToolFolderName);


	CFileFind f;
	if (f.FindFile(str_LogFile))
	{
		BOOL bDelResult = FALSE;
		bDelResult = DeleteFile(str_LogFile);
		if (bDelResult == FALSE)
		{
			this->Show_Status(_T("Del CCSLOAD Tool Log FAIL;"));
			this->Save_Trace_Log(_T("Del CCSLOAD Tool Log FAIL;"));
			this->Show_Out(_T("Del CCSLOAD Tool Log FAIL;"));
			this->m_iError_Code = DL_FW_FAIL4;
			return RTN_FAIL;
		}
	}




	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\%s\\CCSLOAD_RUN.bat"), this->m_csCurr_Exe_Path, str_ToolFolderName);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}
	
	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();

		Cmd_File.WriteString(_T("cd /d") + this->m_csCurr_Exe_Path + "\\" + str_ToolFolderName + _T("\r\n"));

		csData.Format(_T("ccsload.exe DEVICE=PIC18F46K22 AREAS=PDC WRITE=\"%s\" +RUN\r\n"), str_FW_FullPathName);
		Cmd_File.WriteString(csData);
		
		csData.Format(_T("echo %%ERRORLEVEL%% >%s\\%s\\CCSLOAD_LOG.txt\r\n"), this->m_csCurr_Exe_Path, str_ToolFolderName);
		Cmd_File.WriteString(csData);

		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return RTN_FAIL;
	}


	str_CMD.Format(_T("cmd.exe /c %s\\%s\\CCSLOAD_RUN.bat"), this->m_csCurr_Exe_Path, str_ToolFolderName);


	this->Save_Trace_Log(str_CMD);



	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
		this->Show_Status(_T("CCSLOAD Download FW FAIL;"));
		this->Save_Trace_Log(_T("CCSLOAD Download FW FAIL;"));
		this->Show_Out(_T("CCSLOAD Download FW FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		str_CMD.ReleaseBuffer();
		return RTN_FAIL;
	}
	else
	{
		WaitForSingleObject(pi.hProcess, 20000); //空板第一次烧录时间很长，大概需要90秒 。 复测只要3-5秒 Daniel 20230331
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		str_CMD.ReleaseBuffer();
	}




	m_cla_GFC.Kill_Process(_T("ccsload.exe"));


	int iFail = 1;
	CStdioFile file;
	if (!file.Open(str_LogFile, CFile::modeRead))
	{
		this->Show_Status(_T("FAIL: Unable to open CCSLOAD_RUN.txt!"));
		this->Save_Trace_Log(_T("FAIL: Unable to open CCSLOAD_RUN.txt!"));
		this->Show_Out(_T("FAIL: Unable to open CCSLOAD_RUN.txt!"));
		this->m_iError_Code = DL_FW_FAIL3;
		return RTN_FAIL;
	}
	CString str_info = _T("");

	while (file.ReadString(str_info))
	{
		this->Save_Trace_Log(str_info);

		str_info.MakeLower();

		if (str_info.Find(_T("0")) != -1)
		{
			iFail = 0;
			dCurr_Percent = 1.0;
			csTemp.Format(_T("Flash Complete"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(1.0);
		}
	}
	file.Close();

	if (iFail == 0)
	{
		this->Show_Status(_T("CCSLOAD Download FW OK;"));
		this->Save_Trace_Log(_T("CCSLOAD Download FW OK;"));
		this->Show_Out(_T("CCSLOAD Download FW OK;"));
		this->Show_Progress(1.0);

		return RTN_SUCCESS;
	}

	if (iFail == 1)
	{
		this->Show_Progress(1.0);
		this->m_csError_Code.Format(_T("CCSLOAD Download FW, FAIL!"));
		this->Show_Status(_T("CCSLOAD Download FW FAIL;"));
		this->Save_Trace_Log(_T("CCSLOAD Download FW FAIL;"));
		this->Show_Out(_T("CCSLOAD Download FW FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		return RTN_FAIL;
	}


	return RTN_FAIL;


}


int CARM_OP_QCM::Only_Run_Cmd_NoReturnData(CString str_Tool_FullPathName, CString str_Command)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;


	try
	{

		//显示
		Sleep(1000);
		this->Show_Status(_T("Wait 1s..."));
		this->Save_Trace_Log(_T("Wait 1s..."));
		this->Show_Out(_T("Wait 1s..."));

		CString str_Show = _T("");
		str_Show.Format(_T("Run Command: %s"), str_Command);

		this->Show_Status(str_Show);
		this->Save_Trace_Log(str_Show);
		this->Show_Out(str_Show);


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 5000);



		//------------------------------ 打包dos指令 ------------------------------



		swprintf(wcpCmd, _T("cmd.exe %cc %s %s"),
			'/', str_Tool_FullPathName, str_Command);



		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, Run Command, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		else
		{
			WaitForSingleObject(pi.hProcess, INFINITE);
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}

		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);


	}
	catch (...)
	{


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}



	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


CString CARM_OP_QCM::GetExeFilePath()
{
	TCHAR  exepath[MAX_PATH];
	CString  strdir, tmpdir;
	memset(exepath, 0, MAX_PATH);
	GetModuleFileName(NULL, exepath, MAX_PATH);
	tmpdir = exepath;
	strdir = tmpdir.Left(tmpdir.ReverseFind('\\'));
	return strdir;
}


int CARM_OP_QCM::Flash_SunmiCfg(CString str_ToolFullPathName, CString str_SunmiCfgFullPathName)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 60;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{

		//显示
		//Sleep(3000);
		//this->Show_Status(_T("Wait 3s..."));
		//this->Save_Trace_Log(_T("Wait 3s..."));
		//this->Show_Out(_T("Wait 3s..."));
		this->Show_Status(_T("QDC519 Flash Cfg file ......"));
		this->Save_Trace_Log(_T("QDC519 Flash Cfg file ......"));
		this->Show_Out(_T("QDC519 Flash Cfg file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 5000);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);



		//------------------------------ 打包dos指令 ------------------------------



		swprintf(wcpCmd, _T("cmd.exe %cc %s flash cfg \"%s\""),
			'/', str_ToolFullPathName, str_SunmiCfgFullPathName);



		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;
				Sleep(100);


				/*
				sending 'cfg' (0 KB)...

				OKAY [  0.011s]

				writing 'cfg'...

				OKAY [  0.005s]

				finished. total time: 0.016s
				*/


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("sending"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("sending cfg..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("sending cfg..."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("writing"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("writing cfg..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("writing cfg..."));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("okay"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("writing okay"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("writing okay"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}



				//找不到指定的路径...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到指定的路径"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg file, 系统找不到指定的路径!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 Flash Cfg file, 系统找不到指定的路径!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}



				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg file, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 Flash Cfg file, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg file, error!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 Flash Cfg file, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 Flash Cfg file, fail!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 Flash Cfg file, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}



				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("finished"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download finished"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}

			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, Flash Cfg file, Time out!"));
				this->Save_Trace_Log(_T("FAIL, Flash Cfg file, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);




	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}



	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Sunmi_Install_Crp(CString str_ToolFullPathName, CString str_SigCrpFile_FullPathName)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 60;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{

		//显示
		//Sleep(3000);
		//this->Show_Status(_T("Wait 3s..."));
		//this->Save_Trace_Log(_T("Wait 3s..."));
		//this->Show_Out(_T("Wait 3s..."));
		this->Show_Status(_T("QDC519 install crp file ......"));
		this->Save_Trace_Log(_T("QDC519 install crp file ......"));
		this->Show_Out(_T("QDC519 install crp file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QDC519 install crp, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 5000);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);



		//------------------------------ 打包dos指令 ------------------------------



		swprintf(wcpCmd, _T("cmd.exe %cc %s systool install crp \"%s\""),
			'/', str_ToolFullPathName, str_SigCrpFile_FullPathName);



		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, QDC519 install crp, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;
				Sleep(100);


				//86 KB/s (2862 bytes in 0.032s)
				//{"ret":0, "msg" : "OK"}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("\"ok\""));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("install crp ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("install crp ok"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					bSuccess_Flag = true;//pass
					break;//退出while
				}






				//找不到指定的路径...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到指定的路径"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 install crp file, 系统找不到指定的路径!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 install crp file, 系统找不到指定的路径!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}



				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 install crp file, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 install crp file, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 install crp file, error!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 install crp file, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, QDC519 install crp file, fail!"));
					this->Save_Trace_Log(_T("FAIL, QDC519 install crp file, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, install crp file, Time out!"));
				this->Save_Trace_Log(_T("FAIL, install crp file, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}



	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::UpdateRomSetting()
{
	int iDL_Flag = RTN_FAIL;

	CString str_SKUFile_FullPathName = _T("");


	m_cla_GFC.Kill_Process(_T("adb.exe"));
	m_cla_GFC.Kill_Process(_T("fastboot.exe"));
	m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
	m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));

	Only_Run_Cmd_NoReturnData(GetExeFilePath() + _T("\\QDC519\\sunmitool.exe"), _T("reboot bootloader"));
	this->Show_Status(_T("sunmitool Reboot bootloader 15s..."));
	this->Save_Trace_Log(_T("sunmitool Reboot bootloader 15s..."));
	this->Show_Out(_T("sunmitool 15s..."));
	Sleep(15000);

	m_cla_GFC.Kill_Process(_T("adb.exe"));
	m_cla_GFC.Kill_Process(_T("fastboot.exe"));
	m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
	m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));


	if (_T("QDC519SASE-E53-AAASM") == m_csOC)
	{
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("SKU01_X30R_"), str_SKUFile_FullPathName);
		if (str_SKUFile_FullPathName.IsEmpty() || str_SKUFile_FullPathName.Right(4) != _T(".txt"))
		{
			this->Show_Status(_T("QDC519SASE-E53-AAASM Cannot Find SKU01 txt file!"));
			this->Save_Trace_Log(_T("QDC519SASE-E53-AAASM Cannot Find SKU01 txt file!"));
			this->Show_Out(_T("QDC519SASE-E53-AAASM Cannot Find SKU01 txt file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Flash_SunmiCfg(GetExeFilePath() + _T("\\QDC519\\sunmiboot.exe"), str_SKUFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519SASE-E53-AAASM Flash Cfg Fail;"));
				this->Show_Out(_T("QDC519SASE-E53-AAASM Flash Cfg Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519SASE-E53-AAASM Flash Cfg Pass;"));
				this->Show_Out(_T("QDC519SASE-E53-AAASM Flash Cfg Pass;"));
			}
		}
	}
	else if (_T("QDC519SASE-E53-BAASM") == m_csOC)
	{
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("SKU02_X30R_"), str_SKUFile_FullPathName);
		if (str_SKUFile_FullPathName.IsEmpty() || str_SKUFile_FullPathName.Right(4) != _T(".txt"))
		{
			this->Show_Status(_T("QDC519SASE-E53-BAASM Cannot Find SKU02 txt file!"));
			this->Save_Trace_Log(_T("QDC519SASE-E53-BAASM Cannot Find SKU02 txt file!"));
			this->Show_Out(_T("QDC519SASE-E53-BAASM Cannot Find SKU02 txt file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Flash_SunmiCfg(GetExeFilePath() + _T("\\QDC519\\sunmiboot.exe"), str_SKUFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519SASE-E53-BAASM Flash Cfg Fail;"));
				this->Show_Out(_T("QDC519SASE-E53-BAASM Flash Cfg Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519SASE-E53-BAASM Flash Cfg Pass;"));
				this->Show_Out(_T("QDC519SASE-E53-BAASM Flash Cfg Pass;"));
			}
		}
	}
	else if (_T("QDC519SASE-E53-CAASM") == m_csOC)
	{
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("SKU03_X30R_"), str_SKUFile_FullPathName);
		if (str_SKUFile_FullPathName.IsEmpty() || str_SKUFile_FullPathName.Right(4) != _T(".txt"))
		{
			this->Show_Status(_T("QDC519SASE-E53-CAASM Cannot Find SKU03 txt file!"));
			this->Save_Trace_Log(_T("QDC519SASE-E53-CAASM Cannot Find SKU03 txt file!"));
			this->Show_Out(_T("QDC519SASE-E53-CAASM Cannot Find SKU03 txt file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Flash_SunmiCfg(GetExeFilePath() + _T("\\QDC519\\sunmiboot.exe"), str_SKUFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519SASE-E53-CAASM Flash Cfg Fail;"));
				this->Show_Out(_T("QDC519SASE-E53-CAASM Flash Cfg Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519SASE-E53-CAASM Flash Cfg Pass;"));
				this->Show_Out(_T("QDC519SASE-E53-CAASM Flash Cfg Pass;"));
			}
		}
	}
	else if (_T("QDC519SASE-E53-DAASM") == m_csOC)
	{
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("SKU04_X30R_"), str_SKUFile_FullPathName);
		if (str_SKUFile_FullPathName.IsEmpty() || str_SKUFile_FullPathName.Right(4) != _T(".txt"))
		{
			this->Show_Status(_T("QDC519SASE-E53-DAASM Cannot Find SKU04 txt file!"));
			this->Save_Trace_Log(_T("QDC519SASE-E53-DAASM Cannot Find SKU04 txt file!"));
			this->Show_Out(_T("QDC519SASE-E53-DAASM Cannot Find SKU04 txt file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Flash_SunmiCfg(GetExeFilePath() + _T("\\QDC519\\sunmiboot.exe"), str_SKUFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519SASE-E53-DAASM Flash Cfg Fail;"));
				this->Show_Out(_T("QDC519SASE-E53-DAASM Flash Cfg Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519SASE-E53-DAASM Flash Cfg Pass;"));
				this->Show_Out(_T("QDC519SASE-E53-DAASM Flash Cfg Pass;"));
			}
		}
	}

	//if (RTN_SUCCESS == iRtn)
	//{

	m_cla_GFC.Kill_Process(_T("adb.exe"));
	m_cla_GFC.Kill_Process(_T("fastboot.exe"));
	m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
	m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));


	Only_Run_Cmd_NoReturnData(GetExeFilePath() + _T("\\QDC519\\sunmiboot.exe"), _T("reboot"));
	this->Show_Status(_T("sunmiboot Reboot 50s..."));
	this->Save_Trace_Log(_T("sunmiboot Reboot 50s..."));
	this->Show_Out(_T("Reboot 50s..."));
	Sleep(50000);


	m_cla_GFC.Kill_Process(_T("adb.exe"));
	m_cla_GFC.Kill_Process(_T("fastboot.exe"));
	m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
	m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));

	//}



	if (RTN_SUCCESS == iDL_Flag)
	{
		CString str_SunmiCrpFile_FullPathName = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T(".crp"), str_SunmiCrpFile_FullPathName);
		if (str_SunmiCrpFile_FullPathName.IsEmpty() || str_SunmiCrpFile_FullPathName.Right(4) != _T(".crp"))
		{
			this->Show_Status(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			this->Save_Trace_Log(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			this->Show_Out(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Sunmi_Install_Crp(GetExeFilePath() + _T("\\QDC519\\sunmitool.exe"), str_SunmiCrpFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Fail;"));
				this->Show_Out(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Pass;"));
				this->Show_Out(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Pass;"));
			}
		}
	}


	if (RTN_SUCCESS == iDL_Flag)
	{
		m_cla_GFC.Kill_Process(_T("adb.exe"));
		m_cla_GFC.Kill_Process(_T("fastboot.exe"));
		m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
		m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));


		Only_Run_Cmd_NoReturnData(GetExeFilePath() + _T("\\QDC519\\sunmitool.exe"), _T("reboot"));
		this->Show_Status(_T("sunmitool Reboot..."));
		this->Save_Trace_Log(_T("sunmitool Reboot..."));
		this->Show_Out(_T("sunmitool Reboots..."));
		//Sleep(60000);



		m_cla_GFC.Kill_Process(_T("adb.exe"));
		m_cla_GFC.Kill_Process(_T("fastboot.exe"));
		m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
		m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));
	}

	/*
	if (RTN_SUCCESS == iDL_Flag)
	{
		CString str_SunmiCrpFile_FullPathName = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\')), _T("_sig.crp"), str_SunmiCrpFile_FullPathName);
		if (str_SunmiCrpFile_FullPathName.IsEmpty() || str_SunmiCrpFile_FullPathName.Right(4) != _T(".crp"))
		{
			this->Show_Status(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			this->Save_Trace_Log(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			this->Show_Out(_T("QDC519 ASM Cannot Find X30TR SunmiCrp .crp file!"));
			return RTN_FAIL;
		}
		else
		{
			if (Sunmi_Install_Crp(GetExeFilePath() + _T("\\QDC519\\sunmitool.exe"), str_SunmiCrpFile_FullPathName) != RTN_SUCCESS)
			{
				iDL_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Fail;"));
				this->Show_Out(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Fail;"));
			}
			else
			{
				iDL_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Pass;"));
				this->Show_Out(_T("QDC519 ASM Flash X30TR SunmiCrp .crp Pass;"));
			}
		}
	}


	if (RTN_SUCCESS == iDL_Flag)
	{
		m_cla_GFC.Kill_Process(_T("adb.exe"));
		m_cla_GFC.Kill_Process(_T("fastboot.exe"));
		m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
		m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));


		Only_Run_Cmd_NoReturnData(GetExeFilePath() + _T("\\QDC519\\sunmitool.exe"), _T("reboot"));
		this->Show_Status(_T("sunmitool Reboot..."));
		this->Save_Trace_Log(_T("sunmitool Reboot..."));
		this->Show_Out(_T("sunmitool Reboot..."));
		//Sleep(30000);


		m_cla_GFC.Kill_Process(_T("adb.exe"));
		m_cla_GFC.Kill_Process(_T("fastboot.exe"));
		m_cla_GFC.Kill_Process(_T("sunmitool.exe"));
		m_cla_GFC.Kill_Process(_T("sunmiboot.exe"));
	}
	*/

	return iDL_Flag;
}


bool CARM_OP_QCM::Call_QDC519_SunmiDownloader(CString str_key, CString str_boot, CString str_cfg, CString str_os)
{
	CString str_CMD = _T("");
	double dCurr_Percent = 0.0;
	wchar_t * wcpPercent = NULL;
	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	CString str_LogFile_1_Oring = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_1.txt");
	CString str_LogFile_1_Copy = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_1_Copy.txt");
	CString str_LogFile_2_Oring = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_2.txt");
	CString str_LogFile_2_Copy = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_2_Copy.txt");
	CString str_LogFile_3_Oring = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_3.txt");
	CString str_LogFile_3_Copy = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_3_Copy.txt");
	CString str_LogFile_4_Oring = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_4.txt");
	CString str_LogFile_4_Copy = m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\\Test_Result_4_Copy.txt");
	CString str_Port1 = _T("");
	CString str_Port2 = _T("");
	CString str_Port3 = _T("");
	CString str_Port4 = _T("");

	if (iQDC519_Port1 == 0)
	{
		str_Port1 = "";
	}
	else
	{
		str_Port1.Format(_T("%d"), iQDC519_Port1);
	}

	if (iQDC519_Port2 == 0)
	{
		str_Port2 = "";
	}
	else
	{
		str_Port2.Format(_T("%d"), iQDC519_Port2);
	}

	if (iQDC519_Port3 == 0)
	{
		str_Port3 = "";
	}
	else
	{
		str_Port3.Format(_T("%d"), iQDC519_Port3);
	}

	if (iQDC519_Port4 == 0)
	{
		str_Port4 = "";
	}
	else
	{
		str_Port4.Format(_T("%d"), iQDC519_Port4);
	}

	//QDC519 安全固件工具
	m_cla_GFC.Kill_Process(_T("dlcore.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));
	m_cla_GFC.Kill_Process(_T("SunmiDownloader.exe"));


	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\QDC519\\SunmiDownloader\\SunmiDownloader_Run.bat"), this->m_csCurr_Exe_Path);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();

		Cmd_File.WriteString(_T("cd /d") + this->m_csCurr_Exe_Path + _T("\\QDC519\\SunmiDownloader\r\n"));

		csData.Format(_T("SunmiDownloader.exe -CRKPUK %s -BOOT %s -CFG %s -OS %s -COM1 %s -COM2 %s -COM3 %s -COM4 %s -BAUD 1"),
			str_key, str_boot, str_cfg, str_os, str_Port1, str_Port2, str_Port3, str_Port4);
		Cmd_File.WriteString(csData);

		this->Save_Trace_Log(csData);

		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return RTN_FAIL;
	}

	str_CMD.Format(_T("cmd.exe %cc %s\\QDC519\\SunmiDownloader\\SunmiDownloader_Run.bat"),
		'/', this->m_csCurr_Exe_Path);

	this->Save_Trace_Log(str_CMD);


	CFileFind f;
	if (f.FindFile(str_LogFile_1_Oring))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_1_Oring);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_1_Oring txt fail!"));
			this->Show_Out(_T("Del LogFile_1_Oring txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_1_Oring txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_2_Oring))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_2_Oring);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_2_Oring txt fail!"));
			this->Show_Out(_T("Del LogFile_2_Oring txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_2_Oring txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_3_Oring))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_3_Oring);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_3_Oring txt fail!"));
			this->Show_Out(_T("Del LogFile_3_Oring txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_3_Oring txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_4_Oring))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_4_Oring);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_4_Oring txt fail!"));
			this->Show_Out(_T("Del LogFile_4_Oring txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_4_Oring txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_1_Copy))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_1_Copy);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_1_Copy txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_1_Copy txt fail!"));
			this->Show_Out(_T("Del LogFile_1_Copy txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_2_Copy))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_2_Copy);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_2_Copy txt fail!"));
			this->Show_Out(_T("Del LogFile_2_Copy txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_2_Copy txt fail!"));
			return false;
		}
	}

	if (f.FindFile(str_LogFile_3_Copy))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_3_Copy);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_3_Copy txt fail!"));
			this->Show_Out(_T("Del LogFile_3_Copy txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_3_Copy txt fail!"));

			return false;
		}
	}

	if (f.FindFile(str_LogFile_4_Copy))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_4_Copy);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_4_Copy txt fail!"));
			this->Show_Out(_T("Del LogFile_4_Copy txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_4_Copy txt fail!"));
			return false;
		}
	}



	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
		this->Show_Status(_T("CreateProcess SunmiDownloader fail!"));
		this->Show_Out(_T("CreateProcess SunmiDownloader fail!"));
		this->Save_Trace_Log(_T("CreateProcess SunmiDownloader fail!"));
		str_CMD.ReleaseBuffer();
		return false;
	}
	else
	{
		//挂起就行；
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		str_CMD.ReleaseBuffer();
	}

	return true;
}

int CARM_OP_QCM::GetSunmiDLResult()
{
	int iFail = 0;

	CFileFind f;
	CStdioFile file;

	CString str_LogFile_Oring = _T("");
	str_LogFile_Oring.Format(_T("%s\\QDC519\\SunmiDownloader\\Test_Result_%d.txt"), m_csCurr_Exe_Path, m_iClass_Idx);
	CString str_LogFile_Copy = _T("");
	str_LogFile_Copy.Format(_T("%s\\QDC519\\SunmiDownloader\\Test_Result_%d_Copy.txt"), m_csCurr_Exe_Path, m_iClass_Idx);

	if (f.FindFile(str_LogFile_Oring))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_Oring);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_Oring txt fail!"));
			this->Show_Out(_T("Del LogFile_Oring txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_Oring txt fail!"));
			this->m_csError_Code.Format(_T("Del LogFile_Oring txt fail!"));
			return RTN_FAIL;
		}
	}

	int iCountTimes = 1; 
	int iFinish = 0;
	CString csTemp = _T("");

	while (true)
	{
		Sleep(10000);

		CFileFind fRead;
		if (fRead.FindFile(str_LogFile_Oring))
		{
			CopyFile(str_LogFile_Oring, str_LogFile_Copy, FALSE);
			Sleep(50);

			CString str_show = _T("");
			str_show.Format(_T("==========The %d Time==========="), iCountTimes);
			this->Save_Trace_Log(str_show);

			if (!file.Open(str_LogFile_Copy, CFile::modeRead))
			{
				this->Show_Status(_T("FAIL: Unable to open LogFile_Copy.txt!"));
				this->Save_Trace_Log(_T("FAIL: Unable to open LogFile_Copy.txt!"));
				this->Show_Out(_T("FAIL: Unable to open LogFile_Copy.txt!"));
				this->m_csError_Code.Format(_T("FAIL: Unable to open LogFile_Copy.txt!"));
				this->m_iError_Code = DL_FW_FAIL3;
				return RTN_FAIL;
			}
			CString str_info = _T("");

			while (file.ReadString(str_info))
			{
				this->Save_Trace_Log(str_info);

				str_info.MakeLower();

				if (str_info.Find(_T("crk/puk already exist")) != -1)
				{
					csTemp.Format(_T("CRK/PUK already exist"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);
				}

				if (str_info.Find(_T("downloading...")) != -1)
				{
					csTemp.Format(_T("Downloading..."));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);
				}

				if (str_info.Find(_T("download successfully")) != -1)
				{
					csTemp.Format(_T("download successfully"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);
					file.Close();
					iFinish = 1;
					break;
				}

				//Transfer timeout
				if (str_info.Find(_T("timeout")) != -1)
				{
					iFail = 1;
					csTemp.Format(_T("Transfer timeout"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);
					file.Close();
					iFinish = 1;
					break;
				}

				if (str_info.Find(_T("error")) != -1)
				{
					iFail = 1;
					csTemp.Format(_T("Download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);
					file.Close();
					iFinish = 1;
					break;
				}

				if (str_info.Find(_T("fail")) != -1)
				{
					iFail = 1;
					csTemp.Format(_T("download failed"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);
					file.Close();
					iFinish = 1;
					break;
				}

			}

			file.Close();
		}
		
		if (iFinish == 1)
		{
			break;
		}


		if (iCountTimes > 9)
		{
			iFail = 1;
			this->Show_Status(_T("FAIL: Check DL Result Timeout!"));
			this->Save_Trace_Log(_T("FAIL: Check DL Result Timeout!"));
			this->Show_Out(_T("FAIL: Check DL Result Timeout!"));
			this->m_csError_Code.Format(_T("FAIL: Check DL Result Timeout"));
			this->m_iError_Code = DL_FW_FAIL3;
			break;
		}

		iCountTimes++;
	}


	
	

	if (f.FindFile(str_LogFile_Copy))
	{
		int DelBackValue = -1;
		DelBackValue = DeleteFile(str_LogFile_Copy);
		if (DelBackValue == 0)
		{
			this->Show_Status(_T("Del LogFile_Copy txt fail!"));
			this->Show_Out(_T("Del LogFile_Copy txt fail!"));
			this->Save_Trace_Log(_T("Del LogFile_Copy txt fail!"));
			this->m_csError_Code.Format(_T("FAIL: Del LogFile_Copy txt fail!"));
			return RTN_FAIL;
		}
	}

	if (iFail != 0)
	{
		this->m_iError_Code = DL_FW_FAIL4;
		return RTN_FAIL;
	}


	return RTN_SUCCESS;
}


int CARM_OP_QCM::Execute_DL_PICkit(CString str_PICkitFolderName, CString str_ToolShortName, CString str_DeviceName, CString & strBackData)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 100;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("PICkit Download Fw file ......"));
		this->Save_Trace_Log(_T("PICkit Download Fw file ......"));
		this->Show_Out(_T("PICkit Download Fw file ..."));

		m_cla_GFC.Kill_Process(_T("ipecmd.exe"));
		m_cla_GFC.Kill_Process(_T("cmd.exe"));

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		//ipecmd.exe –TPPK4 –PATtiny202 –M –F"*.hex"
		/*
		DFP Version Used : ATtiny_DFP,3.0.151,Microchip
		Choosing default interface updi
		*****************************************************

		Connecting to MPLAB PICkit 4
		Currently loaded versions:
		Application version...........02.00.60
		Boot version..................01.00.00
		PCB version...................6
		Script version................00.05.72
		Script build number...........2889965820
		Tool pack version ............2.0.1722
		Target voltage detected
		Target device ATtiny202 found.
		Device Revision Id  = 0x2 (C)
		Device Id = 0x23
		Calculating memory ranges for operation...
		Only config settings that have been explicitly declared in your code will be programmed.
		Erasing...
		The following memory area(s) will be programmed:
		program memory: start address = 0x0, end address = 0xff
		Programming/Verify complete
		Program Report
		2023-06-30, 18:49:37
		Device Type:ATtiny202
		Program Succeeded.
		Operation Succeeded
		*/
		TCHAR szBuffer[MAX_PATH] = { 0 };

		GetPrivateProfileString(_T("Environment"), _T("Mplab_ipe_Path"), _T("NULL"), szBuffer, MAX_PATH, _T(".\\Multi_Config.ini"));
		str_PICkitFolderName = szBuffer;
		if (str_PICkitFolderName == _T("NULL"))
		{
			str_PICkitFolderName = _T("C:\\Program Files\\Microchip\\MPLABX\\v6.10\\mplab_platform\\mplab_ipe");
		} 



		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;
		CString str_CMD = _T("");

		strCmd_file_name.Format(_T("%s\\QDE017\\mplab_ipe_run.bat"), this->m_csCurr_Exe_Path);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}

		CString str_QDE017_HexFile = _T("");
		TraversFolderFile(m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\') + 1), _T(".hex"), str_QDE017_HexFile);

		if (str_QDE017_HexFile == "")
		{
			this->m_csError_Code.Format(_T("FAIL, QDE017_HexFile, Not Find!"));
			this->Save_Trace_Log(_T("FAIL, QDE017_HexFile, Not Find!"));
			throw(2);
		}

		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			Cmd_File.WriteString(_T("cd /d") + str_PICkitFolderName + _T("\r\n"));

			csData.Format(_T("ipecmd.exe -TP%s -P%s -M -F\"%s\"\r\n"), str_ToolShortName, str_DeviceName, str_QDE017_HexFile);
			Cmd_File.WriteString(csData);

			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));
		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			return RTN_FAIL;
		}


		str_CMD.Format(_T("cmd.exe /c %s\\QDE017\\mplab_ipe_run.bat"), this->m_csCurr_Exe_Path);


		/*swprintf(wcpCmd, _T("cmd.exe %cc \"%s\\ipecmd.exe\" –TP%s –P%s –M –F\"%s\""),
			'/', str_PICkitFolderName, str_ToolShortName, str_DeviceName, m_csScat_Cfg_File_Path);*/


		 this->Save_Trace_Log(str_CMD);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			str_CMD.ReleaseBuffer();
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		str_CMD.ReleaseBuffer();
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;
				strBackData = csTotal_Info + _T("\r\n");


				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, fail!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed to open file"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("failed to open file!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to open file!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to open file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				//Total time needed    OK
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("total time needed"));
				//
				if ((wcpPercent != NULL) && (NULL != wcsstr(csTotal_Info.GetBuffer(), _T("ok"))))
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("download file ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("total time needed"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				//Script processing completed
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("program succeeded"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("script processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, DL_FW, Time out!"));
				this->Save_Trace_Log(_T("FAIL, DL_FW, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		m_cla_GFC.Kill_Process(_T("ipecmd.exe"));
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		//
		return RTN_FAIL;
	}

	m_cla_GFC.Kill_Process(_T("ipecmd.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::QDE017_PushBinFile()
{

	int bResult = RTN_FAIL;

	CString str_COMPort = _T("");
	str_COMPort.Format(_T("%d"), m_iCom_Port);
	bResult = Modify_FileContent(GetExeFilePath() + _T("\\QDE017\\QWinExplorer_v1.3\\config.xml"), _T("	<dmport>COM"), str_COMPort + _T("</dmport>"));

	if (bResult == RTN_SUCCESS)
	{
		//bResult = QWinExplorer_Run_Result(_T("QWinExplorer Del File..."), _T("QDE017\\QWinExplorer_v1.3"), _T("-d: /datatx/upgrade_nand/cust_app_update.bin"), _T("ok"), _T("ok"));
		Only_Run_Cmd_NoReturnData(this->m_csCurr_Exe_Path + _T("\\QDE017\\QWinExplorer_v1.3\\QWinExplorer.exe"), _T("-d: /datatx/upgrade_nand/cust_app_update.bin"));
	} 


	if (bResult == RTN_SUCCESS)
	{
		CString str_Command = _T("");
		str_Command.Format(_T("-f %s -p: /datatx/upgrade_nand"), m_str_QDE017_Binfile);
		bResult = QWinExplorer_Run_Result(_T("QWinExplorer Push File..."), _T("QDE017\\QWinExplorer_v1.3"), str_Command, _T("ok"), _T("ok"));
	}


	if (bResult == RTN_SUCCESS)
	{
		bResult = QWinExplorer_Run_Result(_T("QWinExplorer Reset_1..."), _T("QDE017\\QWinExplorer_v1.3"), _T("-s: l"), _T("success"), _T("success"));
		Sleep(10000);
	}

	if (bResult == RTN_SUCCESS)
	{
		bResult = QWinExplorer_Run_Result(_T("QWinExplorer Reset_2..."), _T("QDE017\\QWinExplorer_v1.3"), _T("-s: l"), _T("success"), _T("success"));
		Sleep(10000);
	}


	return bResult;
}


int CARM_OP_QCM::Xmodem_transferfiles(CString str_ToolFolderName)
{
	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("Open Port%d ......"), this->m_iCom_Port_Auto_Sec);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_Com_Port.m_iBaudRate = 115200;
		this->m_cla_Com_Port.m_iPort = this->m_iCom_Port_Auto_Sec;
		this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
		this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = 20;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return RTN_FAIL;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return RTN_FAIL;
			}
		}

		this->Show_Status(_T("Open xmodem..."));
		this->Show_Out(_T("Open xmodem..."));
		this->Save_Trace_Log(_T("Open xmodem..."));
		this->Show_Progress(0.2);

		//清空 COM BUFF
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = 20, iRec_Bits;
		wchar_t wcrData[1280];
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

			//发送
			this->m_cla_Com_Port.Write(_T("!upd exe 6 xmodem"));
			Sleep(1000);


			Sleep(100);
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 500);

			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			if (NULL != wcsstr(wcrData, _T("Waiting for Xmodem Start")))
			{
				Sleep(1000);
				this->Show_Status(_T("Send Open xmodem OK"));
				this->Show_Out(_T("Send Open xmodem OK"));
				this->Save_Trace_Log(_T("Send Open xmodem OK"));
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				break;
			}

			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				this->m_csError_Code.Format(_T("Send Open xmodem Timeout"));
				this->Show_Status(_T("Send Open xmodem Timeout"));
				this->Show_Out(_T("Send Open xmodem Timeout"));
				this->Save_Trace_Log(_T("Send Open xmodem Timeout"));
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				return RTN_FAIL;
			}
		} while (true);

	}
	catch (...)
	{
		//关闭串口
		this->Show_Progress(1.0);
		this->m_cla_Com_Port.Port_Close();
		return RTN_FAIL;
	}


	this->Show_Status(_T("xmodem tool push bin ......"));
	this->Save_Trace_Log(_T("xmodem tool push bin ......"));
	this->Show_Out(_T("xmodem tool push bin ..."));


	m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));

	CString strTemp;
	strTemp.Format(_T("COM%d"), m_iCom_Port_Auto_Sec);

	WritePrivateProfileString(_T("Config"), _T("COMPort"), strTemp, this->m_csCurr_Exe_Path + _T("\\") + str_ToolFolderName + _T("\\Xmodem.ini"));
	WritePrivateProfileString(_T("Config"), _T("BaudRate"), _T("115200"), this->m_csCurr_Exe_Path + _T("\\") + str_ToolFolderName + _T("\\Xmodem.ini"));
	WritePrivateProfileString(_T("Config"), _T("TransportProtocol"), _T("3"), this->m_csCurr_Exe_Path + _T("\\") + str_ToolFolderName + _T("\\Xmodem.ini"));

	/*TransportProtocol
	#####         0: ASCII
	#####         1: Binary
	#####         2: Xmodem
	#####         3: Xmodem-1K
	#####         4: Ymodem
	#####         5: Ymodem-1K
	*/


	this->Show_Progress(0.3);

	CString csTemp = _T("");
	CString str_CMD = _T("");

	double dCurr_Percent = 0.0;
	CString str_LogFile = _T("");

	str_LogFile.Format(_T("%s\\%s\\XmodemResult.txt"), this->m_csCurr_Exe_Path, str_ToolFolderName);


	CFileFind f;
	if (f.FindFile(str_LogFile))
	{
		BOOL bDelResult = FALSE;
		bDelResult = DeleteFile(str_LogFile);
		if (bDelResult == FALSE)
		{
			this->Show_Status(_T("Del XmodemResult Log FAIL;"));
			this->Save_Trace_Log(_T("Del XmodemResult Log FAIL;"));
			this->Show_Out(_T("Del XmodemResult Log FAIL;"));
			this->m_csError_Code.Format(_T("Del XmodemResult Log FAIL"));
			this->m_iError_Code = DL_FW_FAIL4;
			return RTN_FAIL;
		}
	}




	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\%s\\Xmodem_RUN.bat"), this->m_csCurr_Exe_Path, str_ToolFolderName);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
		::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

		::DeleteFile(strCmd_file_name);

		Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
		Cmd_File.SeekToEnd();

		Cmd_File.WriteString(_T("cd /d") + this->m_csCurr_Exe_Path + "\\" + str_ToolFolderName + _T("\r\nSerialDebug.exe\r\n"));

		Cmd_File.WriteString(csData);

		Cmd_File.Close();

		this->Show_Out(_T("CMD File Save OK"));
	}
	else
	{
		this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
		this->Show_Out(this->m_csError_Code);
		return RTN_FAIL;
	}


	str_CMD.Format(_T("cmd.exe /c %s\\%s\\Xmodem_RUN.bat"), this->m_csCurr_Exe_Path, str_ToolFolderName);


	this->Save_Trace_Log(str_CMD);



	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
		this->Show_Status(_T("Xmodem Download FW FAIL;"));
		this->Save_Trace_Log(_T("Xmodem Download FW FAIL;"));
		this->Show_Out(_T("Xmodem Download FW FAIL;"));
		this->m_csError_Code.Format(_T("Xmodem CreateProcess FAIL"));
		this->m_iError_Code = DL_FW_FAIL4;
		str_CMD.ReleaseBuffer();
		m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		return RTN_FAIL;
	}
	else
	{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		str_CMD.ReleaseBuffer();
	}

	this->Show_Progress(0.5);

	int icount = 0;
	while (1)
	{
		Sleep(1000);
		if (f.FindFile(str_LogFile))
		{
			break;
		}

		icount++;
		if (icount >20)
		{
			this->Show_Status(_T("Run Xmodem Timeout;"));
			this->Save_Trace_Log(_T("Run Xmodem Timeout;"));
			this->Show_Out(_T("Run Xmodem Timeout;"));
			this->m_iError_Code = DL_FW_FAIL4;
			this->Show_Progress(1.0);
			m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
			m_cla_GFC.Kill_Process(_T("cmd.exe"));
			return RTN_FAIL;
		}

	}


	m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));


	int iFail = 1;
	CStdioFile file;
	if (!file.Open(str_LogFile, CFile::modeRead))
	{
		this->Show_Status(_T("FAIL: Unable to open XmodemResult.txt!"));
		this->Save_Trace_Log(_T("FAIL: Unable to open XmodemResult.txt!"));
		this->Show_Out(_T("FAIL: Unable to open XmodemResult.txt!"));
		this->m_csError_Code.Format(_T("FAIL: Unable to open XmodemResult.txt"));
		this->m_iError_Code = DL_FW_FAIL3;
		return RTN_FAIL;
	}
	CString str_info = _T("");

	while (file.ReadString(str_info))
	{
		this->Save_Trace_Log(str_info);

		str_info.MakeLower();

		if (str_info.Find(_T("transmission termination")) != -1 || str_info.Find(_T("transmission timeout")) != -1)  
		{
			iFail = 1;
			dCurr_Percent = 1.0;
			csTemp.Format(_T("Flash FAIL"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(1.0);
		}

		if (str_info.Find(_T("transmission complete")) != -1 )
		{
			iFail = 0;
			dCurr_Percent = 1.0;
			csTemp.Format(_T("Flash OK"));
			this->Show_Status(csTemp);
			//显示进度条
			this->Show_Progress(1.0);
		}
	}
	file.Close();

	if (iFail == 0)
	{
		this->Show_Status(_T("xmodem tool push bin OK;"));
		this->Save_Trace_Log(_T("xmodem tool push bin OK;"));
		this->Show_Out(_T("xmodem tool push bin OK;"));
		this->Show_Progress(1.0);

		return RTN_SUCCESS;
	}

	if (iFail == 1)
	{
		this->Show_Progress(1.0);
		this->m_csError_Code.Format(_T("xmodem tool push bin, FAIL!"));
		this->Show_Status(_T("xmodem tool push bin FAIL;"));
		this->Save_Trace_Log(_T("xmodem tool push bin FAIL;"));
		this->Show_Out(_T("xmodem tool push bin FAIL;"));
		this->m_iError_Code = DL_FW_FAIL4;
		return RTN_FAIL;
	}


	return RTN_FAIL;
}

int CARM_OP_QCM::QWinExplorer_Run_Result(CString str_Action_Title, CString str_ToolPathName, CString str_Command, CString str_ReturnOK_Mark1, CString str_ReturnOK_Mark2)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 40;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(str_Action_Title);
		this->Save_Trace_Log(str_Action_Title);
		this->Show_Out(str_Action_Title);
		this->Show_Progress(0.0);

		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		swprintf(wcpCmd, _T("cmd.exe %cc %s\\%s\\QWinExplorer.exe %s"),
			'/', this->m_csCurr_Exe_Path, str_ToolPathName, str_Command);

		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 



		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				this->Show_Progress(0.5);




				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Command executed, error!"));
					this->Save_Trace_Log(_T("FAIL, Command executed, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Command executed, fail!"));
					this->Save_Trace_Log(_T("FAIL, Command executed, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), str_ReturnOK_Mark1.MakeLower());

				if (wcpPercent == NULL)
				{
					wcpPercent = wcsstr(csTotal_Info.GetBuffer(), str_ReturnOK_Mark2.MakeLower());
				}
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("Command executed successfully"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("Command executed successfully"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					this->Show_Status(str_Action_Title + _T("OK"));
					this->Save_Trace_Log(str_Action_Title + _T("OK"));
					this->Show_Out(str_Action_Title + _T("OK"));

					bSuccess_Flag = true;//pass
					break;//退出while
				}


				//cannot...
				//wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				////
				//if (wcpPercent != NULL)
				//{
				//	dCurr_Percent = 0.9;
				//	csTemp.Format(_T("Command executed fail"));
				//	this->Show_Status(csTemp);
				//	//显示进度条
				//	this->Show_Progress(0.9);

				//	this->m_csError_Code.Format(_T("FAIL, Command executed fail!"));
				//	this->Save_Trace_Log(_T("FAIL, Command executed fail!"));
				//	this->m_iError_Code = DL_FW_FAIL4;
				//	throw(4);

				//	bSuccess_Flag = false;//fail
				//	break;//退出while
				//}


				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, Command execute, Time out!"));
				this->Save_Trace_Log(_T("FAIL,  Command execute, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}


		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}

int CARM_OP_QCM::FileAppendStr(CString strFileFullPathName, CString str_AppendStr)
{
	CStdioFile m_cfLogFile;

	if (!m_cfLogFile.Open(strFileFullPathName, CFile::modeWrite | CFile::modeNoTruncate, NULL))
	{
		this->m_csError_Code.Format(_T("FAIL, Failed to open the PCBA_DL_device_ltc_cloud.txt file!"));
		this->Save_Trace_Log(_T("FAIL, Failed to open the PCBA_DL_device_ltc_cloud.txt file!"));
		return RTN_FAIL;
	}

	m_cfLogFile.SeekToEnd();
	m_cfLogFile.WriteString(str_AppendStr);
	Sleep(1000);
	m_cfLogFile.Close();

	return RTN_SUCCESS;
}


int CARM_OP_QCM::ComPort_SendCmd(CString str_Show, int iport, CString str_cmd, CString str_returnData)
{
	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("Open Port%d ......"), iport);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_Com_Port.m_iBaudRate = 115200;
		this->m_cla_Com_Port.m_iPort = iport;
		this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
		this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = 20;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return RTN_FAIL;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return RTN_FAIL;
			}
		}

		this->Show_Status(str_Show);
		this->Show_Out(str_Show);
		this->Save_Trace_Log(str_Show);
		this->Show_Progress(0.2);

		//清空 COM BUFF
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = 20, iRec_Bits;
		wchar_t wcrData[1280];
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

			//发送
			this->m_cla_Com_Port.Write(str_cmd);
			Sleep(1000);


			Sleep(100);
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 500);

			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			if (NULL != wcsstr(wcrData, str_returnData))
			{
				Sleep(1000);
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				return RTN_SUCCESS;
			}

			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				this->Show_Status(_T("Send Cmd Timeout"));
				this->Show_Out(_T("Send Cmd Timeout"));
				this->Save_Trace_Log(_T("Send Cmd Timeout"));
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				this->m_csError_Code.Format(_T("FAIL, Port Command execute, Time out!"));
				return RTN_FAIL;
			}
		} while (true);

	}
	catch (...)
	{
		//关闭串口
		this->Show_Progress(1.0);
		this->m_cla_Com_Port.Port_Close();
		this->m_csError_Code.Format(_T("FAIL, Port Command Execute Error!"));
		return RTN_FAIL;
	}

	return RTN_FAIL;
}


int CARM_OP_QCM::COM_Modem_PushBin(CString str_ShowLog, int iPort, CString str_BaudRate, CString str_TransportProtocol)
{

	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 50;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;


	try
	{
		//显示
		this->Show_Status(_T("Ymodem push file ......"));
		this->Save_Trace_Log(_T("Ymodem push file ......"));
		this->Show_Out(_T("Ymodem push file ..."));


		//------------------------------ 创建 pipe ------------------------------
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		CString str_CMD = _T("");
		str_CMD.Format(_T("cmd.exe /c %s\\QDM039\\ymodem_PushBin.py -c COM%d -f %s"), this->m_csCurr_Exe_Path, m_iCom_Port, m_csScat_Cfg_File_Path);



		this->Save_Trace_Log(str_CMD);

		//------------------------------ 创建 process ------------------------------
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			str_CMD.ReleaseBuffer();
			this->m_csError_Code.Format(_T("FAIL, Pushfile, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		str_CMD.ReleaseBuffer();
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------



		//------------------------------ 循环读取process的处理信息 ------------------------------
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;
			//
			ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			//


			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);

				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;



				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("push file error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, push file, error!"));
					this->Save_Trace_Log(_T("FAIL, push file, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//fail...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("push file fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, push file, fail!"));
					this->Save_Trace_Log(_T("FAIL, push file, fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}

				//Failed to open file
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("failed"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("push file fail!"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					this->m_csError_Code.Format(_T("FAIL, push file fail!"));
					this->Save_Trace_Log(_T("FAIL, push file fail!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("recv char is crc"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("recv char is crc"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("recv char is crc"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("send ymodem first package"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("send ymodem first package"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("send ymodem first package"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("send first package success"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("send first package success"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("send first package success"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("send file data"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("send file data"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("send file data"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("send last data"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("send last data"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("send last data"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("send last ok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("send last ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("push file processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}
				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("push file fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, push file!"));
					this->Save_Trace_Log(_T("FAIL, push file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("push file fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, push file!"));
					this->Save_Trace_Log(_T("FAIL, push file!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

			}

			//超时检测
			time(&t_End);
			//
			if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
			{
				this->m_csError_Code.Format(_T("FAIL, push file, Time out!"));
				this->Save_Trace_Log(_T("FAIL, push file, Time out!"));
				this->m_iError_Code = DL_FW_FAIL2;
				throw(4);
			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);

		return RTN_FAIL;
	}



	this->Show_Progress(1.0);
	return RTN_SUCCESS;




	/*
		this->Show_Status(str_ShowLog);
		this->Save_Trace_Log(str_ShowLog);
		this->Show_Out(str_ShowLog);


		m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
		m_cla_GFC.Kill_Process(_T("cmd.exe"));

		CString strTemp;
		strTemp.Format(_T("COM%d"), iPort);

		WritePrivateProfileString(_T("Config"), _T("COMPort"), strTemp, this->m_csCurr_Exe_Path + _T("\\ComTool\\Xmodem.ini"));
		WritePrivateProfileString(_T("Config"), _T("BaudRate"), str_BaudRate, this->m_csCurr_Exe_Path + _T("\\ComTool\\Xmodem.ini"));
		WritePrivateProfileString(_T("Config"), _T("TransportProtocol"), str_TransportProtocol, this->m_csCurr_Exe_Path + _T("\\ComTool\\Xmodem.ini"));
		WritePrivateProfileString(_T("Config"), _T("PathFile"), m_csScat_Cfg_File_Path, this->m_csCurr_Exe_Path + _T("\\ComTool\\Xmodem.ini"));

		/*TransportProtocol
		#####         0: ASCII
		#####         1: Binary
		#####         2: Xmodem
		#####         3: Xmodem-1K
		#####         4: Ymodem
		#####         5: Ymodem-1K
		*/

	/*
	this->Show_Progress(0.3);

	CString csTemp = _T("");
	CString str_CMD = _T("");

	double dCurr_Percent = 0.0;
	CString str_LogFile = _T("");

	str_LogFile.Format(_T("%s\\ComTool\\ComModemResult.txt"), this->m_csCurr_Exe_Path);


	CFileFind f;
	if (f.FindFile(str_LogFile))
	{
	BOOL bDelResult = FALSE;
	bDelResult = DeleteFile(str_LogFile);
	if (bDelResult == FALSE)
	{
	this->Show_Status(_T("Del ComModemResult Log FAIL;"));
	this->Save_Trace_Log(_T("Del ComModemResult Log FAIL;"));
	this->Show_Out(_T("Del ComModemResult Log FAIL;"));
	this->m_csError_Code.Format(_T("Del ComModemResult Log FAIL"));
	this->m_iError_Code = DL_FW_FAIL4;
	return RTN_FAIL;
	}
	}




	CStdioFile Cmd_File;
	CString   strCmd_file_name, csData;
	unsigned long ul_File_Size;

	strCmd_file_name.Format(_T("%s\\ComTool\\ComModem_RUN.bat"), this->m_csCurr_Exe_Path);

	if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
	{
	::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

	::DeleteFile(strCmd_file_name);

	Sleep(2000);
	}

	if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
	{
	Cmd_File.SeekToEnd();

	Cmd_File.WriteString(_T("cd /d") + this->m_csCurr_Exe_Path + _T("\\ComTool\r\nSerialDebug.exe\r\n"));

	Cmd_File.WriteString(csData);

	Cmd_File.Close();

	this->Show_Out(_T("CMD File Save OK"));
	}
	else
	{
	this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
	this->Show_Out(this->m_csError_Code);
	return RTN_FAIL;
	}


	str_CMD.Format(_T("cmd.exe /c %s\\ComTool\\ComModem_RUN.bat"), this->m_csCurr_Exe_Path);


	this->Save_Trace_Log(str_CMD);



	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
	{
	this->Show_Status(_T("ComModem CreateProcess FAIL;"));
	this->Save_Trace_Log(_T("ComModem CreateProcess FAIL;"));
	this->Show_Out(_T("ComModem CreateProcess FAIL;"));
	this->m_csError_Code.Format(_T("ComModem CreateProcess FAIL"));
	this->m_iError_Code = DL_FW_FAIL4;
	str_CMD.ReleaseBuffer();
	m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));
	return RTN_FAIL;
	}
	else
	{
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
	str_CMD.ReleaseBuffer();
	}

	this->Show_Progress(0.5);

	int icount = 0;
	while (1)
	{
	Sleep(1000);
	if (f.FindFile(str_LogFile))
	{
	break;
	}

	icount++;
	if (icount > 60)
	{
	this->Show_Status(_T("Run ComModem Timeout;"));
	this->Save_Trace_Log(_T("Run ComModem Timeout;"));
	this->Show_Out(_T("Run ComModem Timeout;"));
	this->m_csError_Code.Format(_T("Run ComModem Timeout"));
	this->m_iError_Code = DL_FW_FAIL4;
	this->Show_Progress(1.0);
	m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));
	return RTN_FAIL;
	}

	}


	m_cla_GFC.Kill_Process(_T("SerialDebug.exe"));
	m_cla_GFC.Kill_Process(_T("cmd.exe"));


	int iFail = 1;
	CStdioFile file;
	if (!file.Open(str_LogFile, CFile::modeRead))
	{
	this->Show_Status(_T("FAIL: Unable to open ComModemResult.txt!"));
	this->Save_Trace_Log(_T("FAIL: Unable to open ComModemResult.txt!"));
	this->Show_Out(_T("FAIL: Unable to open ComModemResult.txt!"));
	this->m_csError_Code.Format(_T("Unable to open ComModemResult.txt"));
	this->m_iError_Code = DL_FW_FAIL3;
	return RTN_FAIL;
	}
	CString str_info = _T("");

	while (file.ReadString(str_info))
	{
	this->Save_Trace_Log(str_info);

	str_info.MakeLower();

	if (str_info.Find(_T("transmission termination")) != -1 || str_info.Find(_T("transmission timeout")) != -1)
	{
	iFail = 1;
	dCurr_Percent = 1.0;
	csTemp.Format(_T("Flash FAIL"));
	this->Show_Status(csTemp);
	//显示进度条
	this->Show_Progress(1.0);
	}

	if (str_info.Find(_T("transmission complete")) != -1)
	{
	iFail = 0;
	dCurr_Percent = 1.0;
	csTemp.Format(_T("Flash OK"));
	this->Show_Status(csTemp);
	//显示进度条
	this->Show_Progress(1.0);
	}
	}
	file.Close();

	if (iFail == 0)
	{
	this->Show_Status(_T("ComModem tool push bin OK;"));
	this->Save_Trace_Log(_T("ComModem tool push bin OK;"));
	this->Show_Out(_T("ComModem tool push bin OK;"));
	this->Show_Progress(1.0);

	return RTN_SUCCESS;
	}

	if (iFail == 1)
	{
	this->Show_Progress(1.0);
	this->m_csError_Code.Format(_T("ComModem tool push bin, FAIL!"));
	this->Show_Status(_T("ComModem tool push bin FAIL;"));
	this->Save_Trace_Log(_T("ComModem tool push bin FAIL;"));
	this->Show_Out(_T("ComModem tool push bin FAIL;"));
	this->m_iError_Code = DL_FW_FAIL4;
	return RTN_FAIL;
	}


	return RTN_FAIL;
	*/
}


int CARM_OP_QCM::CheckPushBinVer(int iFirst)
{

	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("Open Port%d ......"), m_iCom_Port);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_Com_Port.m_iBaudRate = 9600;
		this->m_cla_Com_Port.m_iPort = m_iCom_Port;
		this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
		this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = 20;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return RTN_FAIL;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return RTN_FAIL;
			}
		}

		this->Show_Status(_T("Check Push bin Ver.."));
		this->Show_Out(_T("Check Push bin Ver.."));
		this->Save_Trace_Log(_T("Check Push bin Ver.."));
		this->Show_Progress(0.2);

		//清空 COM BUFF
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = 20, iRec_Bits;
		wchar_t wcrData[1280];
		CString str_RecvData = _T("");
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

			Sleep(100);
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			if (iFirst == 1)
			{
				this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 15000);
			} 
			else
			{
				this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 5000);
			}
			

			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			CString str_Temp = _T("");
			str_Temp = wcrData;
			str_RecvData = str_RecvData + str_Temp;
			str_RecvData.Replace(_T("\r"), _T(""));
			str_RecvData.Replace(_T("\n"), _T(""));
			str_RecvData.Replace(_T(" "), _T(""));

			if (str_RecvData.Replace(_T("1.05Y"), _T("1.05Y")) == 4)
			{
				Sleep(1000);
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				return RTN_SUCCESS;
			}

			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				this->Show_Status(_T("Check Push bin Ver Timeout"));
				this->Show_Out(_T("Check Push bin Ver Timeout"));
				this->Save_Trace_Log(_T("Check Push bin Ver Timeout"));
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				this->m_csError_Code.Format(_T("FAIL, Check Push bin Ver, Time out!"));
				return RTN_FAIL;
			}
		} while (true);

	}
	catch (...)
	{
		//关闭串口
		this->Show_Progress(1.0);
		this->m_cla_Com_Port.Port_Close();
		this->m_csError_Code.Format(_T("FAIL, Check Push bin Ver Error!"));
		return RTN_FAIL;
	}

	return RTN_FAIL;

}


CString CARM_OP_QCM::COM_Query_Result(CString str_ShowLog, int iport, int iBaudRate, int iDTSRTS_Mode, CString str_Cmd)
{
	CString csData = _T("");


	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("%s, Open Port%d ......"), str_ShowLog, m_iCom_Port);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_Com_Port.m_iBaudRate = iBaudRate;
		this->m_cla_Com_Port.m_iPort = iport;
		if (iDTSRTS_Mode == 0)
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		}
		else if (iDTSRTS_Mode == 1)
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
		}
		else if (iDTSRTS_Mode == 3)
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
		}
		else if (iDTSRTS_Mode == 4)
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		}
		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = 20;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return csData;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return csData;
			}
		}

		this->Show_Progress(0.2);

		//清空 COM BUFF
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = 20, iRec_Bits;
		wchar_t wcrData[1280];
		CString str_RecvData = _T("");
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();
			Sleep(100);

			//发送
			this->m_cla_Com_Port.Write(str_Cmd);
			Sleep(1000);
	
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 5000);

			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			csData = wcrData;

			this->m_cla_Com_Port.Port_Close();
			this->Show_Progress(1.0);
			return csData;


			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				this->Show_Status(_T("Com Cmd Timeout"));
				this->Show_Out(_T("Com Cmd Timeout"));
				this->Save_Trace_Log(_T("Com Cmd Timeout"));
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				this->m_csError_Code.Format(_T("FAIL, Com Cmd, Time out!"));
				return csData;
			}
		} while (true);

	}
	catch (...)
	{
		//关闭串口
		this->Show_Progress(1.0);
		this->m_cla_Com_Port.Port_Close();
		this->m_csError_Code.Format(_T("FAIL, Com Cmd Error!"));
	}

	return csData;
}


int CARM_OP_QCM::bk_loader_Image(CString str_FW_PathFullName)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 120;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach, str_ExeName;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;

	int P1(-1), P2(-1), Pos(0);


	try
	{
		//显示
		this->Show_Status(_T("bk_loader Download file ......"));
		this->Save_Trace_Log(_T("bk_loader Download file ......"));
		this->Show_Out(_T("bk_loaderDownload file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, bk_loader, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);


		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------

		//bk_loader1.exe download -p 30 -b 921600 -i F:\14_Firmware\BEKEN\FC41D\FC41DAAR03A02V05\FC41DAAR03A02.bin

		swprintf(wcpCmd, _T("cmd.exe %cc %s\\bk_loader\\%d\\bk_loader%d.exe download -p %d -b 921600 -i %s"),
			'/', this->m_csCurr_Exe_Path, m_iClass_Idx, this->m_iClass_Idx, this->m_iCom_Port, str_FW_PathFullName);



		this->Save_Trace_Log(wcpCmd);
		this->Show_Out(wcpCmd);

		str_ExeName.Format(_T("bk_loader%d.exe"), this->m_iClass_Idx);
		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(500);
		m_cla_GFC.Kill_Process(str_ExeName);


		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0, iTimeTemp = 0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;

			if (TRUE == ::PeekNamedPipe(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, 0, 0))
			{
				ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			}

			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csTemp = csData;

		
				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("start 64k erase"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("Start 64K Erase"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("Start 64K Erase"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("end 64k erase"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.4;
					csTemp.Format(_T("End 64K Erase"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.4);

					csTemp.Format(_T("End 64K Erase"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("begin writeflash"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("Begin WriteFlash"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("Begin WriteFlash"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("boot_reboot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("Boot_Reboot"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					csTemp.Format(_T("Boot_Reboot"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("flash ok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download ok"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("DL Processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}


				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, error!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to flash device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Failed to flash device!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Failed to flash device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_FW_MCU, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_FW_MCU, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}
			else
			{
				//------------------------------------------------
				time(&t_End);
				iTimeTemp = (int)difftime(t_End, t_Start);
				//
				if (iTimeTemp >= iTimeout)
				{
					//发个消息将bk_loader%d.exe文件杀掉
					bool bKill_Flag = false;
					bKill_Flag = m_cla_GFC.Kill_Process(str_ExeName);
					if (false == bKill_Flag)
					{
						csData.Format(_T("%s Del FAIL_1"), str_ExeName);
						this->Show_Out(csData);
					}
					else
					{
						csData.Format(_T("%s Del PASS_1"), str_ExeName);
						this->Show_Out(csData);
					}

					this->m_csError_Code.Format(_T("FAIL, DL_FW, Get Data Timeout"));
					this->Save_Trace_Log(_T("FAIL, DL_FW, Get Data Timeout!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

				}

			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//发个消息将bk_loader%d.exe文件杀掉
		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(500);
		m_cla_GFC.Kill_Process(str_ExeName);
		


		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	//发个消息将bk_loader%d.exe文件杀掉
	m_cla_GFC.Kill_Process(str_ExeName);
	Sleep(500);
	m_cla_GFC.Kill_Process(str_ExeName);


	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Run_QDM025_FastbootCMD()
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t * wcpCmd = NULL;
	wchar_t * wcpData = NULL;
	char * cpRead_Buff = NULL;
	wchar_t * wcpEach = NULL;
	wchar_t * wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 120;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach, str_ExeName;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;

	int P1(-1), P2(-1), Pos(0);


	try
	{
		this->Show_Status(_T("boot 45s ......"));
		this->Save_Trace_Log(_T("boot 45s ......"));
		this->Show_Out(_T("boot 45s ..."));
		Sleep(45000);
		//显示
		this->Show_Status(_T("Fastboot Download file ......"));
		this->Save_Trace_Log(_T("Fastboot Download file ......"));
		this->Show_Out(_T("Fastboot Download file ..."));


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, Fastboot Download, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);
		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("adb.exe"));
		m_cla_GFC.Kill_Process(_T("fastboot.exe"));

		
		CString str_CMD = _T("");
		str_CMD.Format(_T("cmd.exe %cc %s\\Fir\\QDM025_FastbootCMD.bat"),
			'/', this->m_csCurr_Exe_Path);

		this->Save_Trace_Log(str_CMD);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			str_CMD.ReleaseBuffer();
			this->m_csError_Code.Format(_T("FAIL, QDM025_FastbootCMD, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		str_CMD.ReleaseBuffer();
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0, iTimeTemp = 0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;

			if (TRUE == ::PeekNamedPipe(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, 0, 0))
			{
				ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			}

			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csTemp = csData;


				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));
				csData.Replace(_T(" "), _T(""));
				csData.Replace(_T("\'"), _T(""));
				csData.Replace(_T("'"), _T(""));
				csData.Replace(_T("..."), _T(""));


				csData.MakeLower();

				csTotal_Info += csData;
				
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Fastboot, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, Fastboot, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("writingbootokay["));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("Writing boot okay"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("Writing boot okay"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("writingsystemokay["));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.4;
					csTemp.Format(_T("writing system okay"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.4);

					csTemp.Format(_T("writing system okay"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("writingvendorokay["));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("writing vendor okay"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("writing vendor okay"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("rebootingfinished"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("rebooting okay"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("rebooting okay"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);

					bSuccess_Flag = true;//pass
					break;//退出while
				}

				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Fastboot, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, Fastboot, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Fastboot download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Fastboot, error!"));
					this->Save_Trace_Log(_T("FAIL, Fastboot, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Fastboot download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Fastboot, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, Fastboot, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("fail"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to Fastboot flash device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, Fastboot, Failed to flash device!"));
					this->Save_Trace_Log(_T("FAIL, Fastboot, Failed to flash device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, DL_Fastboot, Time out!"));
					this->Save_Trace_Log(_T("FAIL, DL_Fastboot, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}
	
		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);


		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::FRDownload_Image(int iComNum, int iBaud_Rate, CString str_FW_PathFullName, CString str_chip_type)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t* wcpCmd = NULL;
	wchar_t* wcpData = NULL;
	char* cpRead_Buff = NULL;
	wchar_t* wcpEach = NULL;
	wchar_t* wcpPercent = NULL;

	time_t t_Start, t_End;
	int iTimeout = 100;//没有数据吐出的时间超时
	int iTimeout_emptydata = 30;//没有数据吐出的时间超时
	unsigned long ulActual_Read;
	CString csTotal_Info, csData, csTemp, csEach, str_ExeName;
	int iTemp;
	bool bSuccess_Flag = false;
	double dCurr_Percent = 0.0;
	double dNew_Percent = 0.0;

	int P1(-1), P2(-1), Pos(0);


	try
	{
		//显示
		this->Show_Status(_T("FRDownload Wait Connect..."));
		this->Save_Trace_Log(_T("FRDownload Wait Connect..."));
		this->Show_Out(_T("FRDownload Wait Connect..."));

		str_ExeName.Format(_T("Quectel_FRDownload_%d.exe"), this->m_iClass_Idx);
		m_cla_GFC.Kill_Process(str_ExeName);
		Sleep(50);


		//------------------------------ 创建 pipe ------------------------------ 
		//Windows中使用较多的管道也是匿名管道，它通过API函数CreatePipe创建
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;//使用系统默认的安全描述符
		sa.bInheritHandle = TRUE;//一定要为TRUE，不然句柄不能被继承

		if (CreatePipe(&hRead_Pipe, &hWrite_Pipe, &sa, 0) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, FRDownload, Create pipe fail!"));
			this->m_iError_Code = DL_FW_FAIL1;
			throw(1);
		}
		//------------------------------ 


		//分配内存
		//this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, (this->m_csCurr_Exe_Path.GetLength() + this->m_csFW_File_Path.GetLength() + 256));

		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 4096);
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpData, 2048);


		this->m_cla_GFC.BUFF_CHAR_CALLOC(&cpRead_Buff, 2048);


		//------------------------------ 打包dos指令 ------------------------------

		//FRDownload.exe -c8 -b115200  -t800X -h1 -f"E:\1111\Debug\QDM523_CMD_FR8003A_01.001.01.001_V04.bin"


		swprintf(wcpCmd, _T("cmd.exe %cc %s\\FRDownload\\%d\\Quectel_FRDownload_%d.exe -c%d -b%d -t%s -h%d -f\"%s\""),
			'/', this->m_csCurr_Exe_Path, this->m_iClass_Idx, this->m_iClass_Idx, iComNum, iBaud_Rate, str_chip_type, this->m_iClass_Idx, str_FW_PathFullName);



		this->Save_Trace_Log(wcpCmd);
		this->Show_Out(wcpCmd);

		

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, FRDownload, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}
		//------------------------------ 
		//------------------------------ 循环读取process的处理信息 ------------------------------ 
		csTotal_Info.Format(_T(""));
		//开始计时
		time(&t_Start);

		int i_verified = 0, iTimeTemp = 0;
		//
		while (bSuccess_Flag == false)
		{
			//读pipe管道
			memset(cpRead_Buff, 0, 2048);
			ulActual_Read = 0;

			if (TRUE == ::PeekNamedPipe(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, 0, 0))
			{
				ReadFile(hRead_Pipe, cpRead_Buff, 1024, &ulActual_Read, NULL);
			}

			//
			//读到info数据了
			if (ulActual_Read > 0)
			{
				//字符转换
				memset(wcpData, 0, 2048);
				this->m_cla_GFC.MultiByte_To_WideChar(cpRead_Buff, wcpData, &iTemp);



				//处理数据
				csData.Format(_T("%s"), wcpData);

				this->Save_Trace_Log(csData);

				csTemp = csData;


				csData.Replace(_T('\r'), _T(' '));
				csData.Replace(_T('\n'), _T(' '));

				csData.MakeLower();

				csTotal_Info += csData;

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("系统找不到"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("系统找不到指定路径"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, FRDownload, cannot find dirction!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, cannot find dirction!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: bootok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.1;
					csTemp.Format(_T("status: BootOK"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.1);

					csTemp.Format(_T("status: BootOK"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: erase, percent: 0"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.2;
					csTemp.Format(_T("status: Erase, percent: 100"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.2);

					csTemp.Format(_T("status: Erase, percent: 100"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: erase, percent: 100"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.3;
					csTemp.Format(_T("status: Erase, percent: 100"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.3);

					csTemp.Format(_T("status: Erase, percent: 100"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 0"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.4;
					csTemp.Format(_T("status: Write, percent: 0"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.4);

					csTemp.Format(_T("status: Write, percent: 0"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 20"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.5;
					csTemp.Format(_T("status: Write, percent: 20"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.5);

					csTemp.Format(_T("status: Write, percent: 20"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 40"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.6;
					csTemp.Format(_T("status: Write, percent: 40"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.6);

					csTemp.Format(_T("status: Write, percent: 40"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 60"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.7;
					csTemp.Format(_T("status: Write, percent: 60"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.7);

					csTemp.Format(_T("status: Write, percent: 60"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 80"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.8;
					csTemp.Format(_T("status: Write, percent: 80"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.8);

					csTemp.Format(_T("status: Write, percent: 80"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("status: write, percent: 100"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("status: Write, percent: 100"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					csTemp.Format(_T("status: Write, percent: 100"));

					wcpPercent += csTemp.GetLength();

					csTotal_Info.Format(_T("%s"), wcpPercent);
				}


				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("frwritefile ok"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 1.0;
					csTemp.Format(_T("FrWriteFile OK"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(1.0);

					csTemp.Format(_T("DL Processing completed"));

					bSuccess_Flag = true;//pass
					break;//退出while

				}


				//cannot...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("cannot"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, FRDownload, cannot link!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, cannot link!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//error...
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("error"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download error"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, FRDownload, error!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, error!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				//Unknown command line option
				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("unknown"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("download fail"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, FRDownload, Unknown command line option!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, Unknown command line option!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}

				wcpPercent = wcsstr(csTotal_Info.GetBuffer(), _T("frwritefile ng"));
				//
				if (wcpPercent != NULL)
				{
					dCurr_Percent = 0.9;
					csTemp.Format(_T("Failed to flash device"));
					this->Show_Status(csTemp);
					//显示进度条
					this->Show_Progress(0.9);

					this->m_csError_Code.Format(_T("FAIL, FRDownload, Failed to flash device!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, Failed to flash device!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

					bSuccess_Flag = false;//fail
					break;//退出while

				}
				//超时检测
				time(&t_End);
				//
				if ((int)difftime(t_End, t_Start) >= iTimeout)//超时，报fail
				{
					this->m_csError_Code.Format(_T("FAIL, FRDownload, Time out!"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, Time out!"));
					this->m_iError_Code = DL_FW_FAIL2;
					throw(4);
				}
			}
			else
			{
				//------------------------------------------------
				time(&t_End);
				iTimeTemp = (int)difftime(t_End, t_Start);
				//
				if (iTimeTemp >= iTimeout_emptydata)
				{
					//发个消息将bk_loader%d.exe文件杀掉
					bool bKill_Flag = false;
					bKill_Flag = m_cla_GFC.Kill_Process(str_ExeName);
					if (false == bKill_Flag)
					{
						csData.Format(_T("%s Del FAIL_1"), str_ExeName);
						this->Show_Out(csData);
					}
					else
					{
						csData.Format(_T("%s Del PASS_1"), str_ExeName);
						this->Show_Out(csData);
					}

					this->m_csError_Code.Format(_T("FAIL, FRDownload, Get Data Timeout"));
					this->Save_Trace_Log(_T("FAIL, FRDownload, Get Data Timeout!"));
					this->m_iError_Code = DL_FW_FAIL4;
					throw(4);

				}

			}

		}//while(bSuccess_Flag == false
		//------------------------------


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

	}
	catch (...)
	{
		//显示失败信息
		this->Show_Status(this->m_csError_Code);

		m_cla_GFC.Kill_Process(str_ExeName);

		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpData);
		this->m_cla_GFC.BUFF_CHAR_FREE(&cpRead_Buff);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}
	m_cla_GFC.Kill_Process(str_ExeName);

	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::Only_Run_Cmd_NoReturnData_QDM548(CString str_Tool_FullPathName, CString str_Command)
{
	HANDLE hRead_Pipe = NULL;	//指向读端句柄的指针
	HANDLE hWrite_Pipe = NULL;	//指向写端句柄的指针
	SECURITY_ATTRIBUTES sa;//指向安全属性结构的指针
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	wchar_t* wcpCmd = NULL;


	try
	{

		//显示
		Sleep(1000);
		this->Show_Status(_T("Wait 1s..."));
		this->Save_Trace_Log(_T("Wait 1s..."));
		this->Show_Out(_T("Wait 1s..."));

		CString str_Show = _T("");
		str_Show.Format(_T("Run Command: %s"), str_Command);

		this->Show_Status(str_Show);
		this->Save_Trace_Log(str_Show);
		this->Show_Out(str_Show);


		//分配内存
		this->m_cla_GFC.BUFF_WCHAR_CALLOC(&wcpCmd, 5000);



		//------------------------------ 打包dos指令 ------------------------------



		swprintf(wcpCmd, _T("cmd.exe %cc %s\\%s"),
			'/', str_Tool_FullPathName, str_Command);



		this->Save_Trace_Log(wcpCmd);

		//------------------------------ 创建 process ------------------------------ 
		si.cb = sizeof(STARTUPINFO);
		GetStartupInfo(&si);//这个函数用来取得当前进程的StartupInfo,我们新建的进程基本根当前进程的StartupInfo差不多
		si.hStdError = hWrite_Pipe;//错误输出的句柄
		si.hStdOutput = hWrite_Pipe;//标准输出的句柄
		si.wShowWindow = SW_HIDE;//制定了新进程创建时窗口的现实状态，这个属性设 SW_HIDE 隐藏新建的DOS进程
		si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;//用来制定 STARTUPINFO里这一堆参数那个有效的
		//创建子进程
		if (CreateProcess(NULL, wcpCmd, NULL, NULL, TRUE, NULL, NULL, NULL, &si, &pi) == FALSE)
		{
			this->m_csError_Code.Format(_T("FAIL, Run Command, Create process fail!"));
			this->m_iError_Code = DL_FW_FAIL3;
			throw(2);
		}
		else
		{
			//Sleep(10000);
			WaitForSingleObject(pi.hProcess, 20000);
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}

		//把管道的写句柄先关闭，这样ReadFile函数就不会阻塞。
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);


	}
	catch (...)
	{


		//释放句柄的指针
		if (hRead_Pipe != NULL)
		{
			CloseHandle(hRead_Pipe);
			hRead_Pipe = NULL;
		}
		if (hWrite_Pipe != NULL)
		{
			CloseHandle(hWrite_Pipe);
			hWrite_Pipe = NULL;
		}

		//释放内存
		this->m_cla_GFC.BUFF_WCHAR_FREE(&wcpCmd);

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}



	this->Show_Progress(1.0);
	return RTN_SUCCESS;
}


int CARM_OP_QCM::SendComCmd(CString strTitel, int iPort, int iBaudRate, bool IsEnDTR, bool IsEnRTS, CString str_cmd, CString strExpected)
{

	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("Open Port%d ......"), iPort);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_Com_Port.m_iBaudRate = iBaudRate;
		this->m_cla_Com_Port.m_iPort = iPort;
		if (IsEnDTR)
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
		}
		else
		{
			this->m_cla_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
		}
		
		if (IsEnRTS)
		{
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
		}
		else
		{
			this->m_cla_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		}
		
		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = 20;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return RTN_FAIL;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return RTN_FAIL;
			}
		}

		this->Show_Status(strTitel);
		this->Show_Out(strTitel);
		this->Save_Trace_Log(strTitel);
		this->Show_Progress(0.2);

		//清空 COM BUFF
		this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = 20, iRec_Bits;
		wchar_t wcrData[1280];
		CString str_RecvData = _T("");
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_Com_Port.Empty_Com_And_Rx_Buff();

			//发送
			this->m_cla_Com_Port.Write(str_cmd);
			Sleep(1000);


			Sleep(100);
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			this->m_cla_Com_Port.Read(wcrData, &iRec_Bits, 500);



			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			CString str_Temp = _T("");
			str_Temp = wcrData;
			str_RecvData = str_RecvData + str_Temp;
			str_RecvData.Replace(_T("\r"), _T(""));
			str_RecvData.Replace(_T("\n"), _T(""));
			str_RecvData.Replace(_T(" "), _T(""));

			if (str_RecvData.Find(strExpected)!=-1)
			{
				Sleep(1000);
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				return RTN_SUCCESS;
			}

			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				CString temp = _T("");
				temp.Format(_T("%s Timeout"), strTitel);

				this->Show_Status(temp);
				this->Show_Out(temp);
				this->Save_Trace_Log(temp);
				this->m_cla_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				this->m_csError_Code.Format(temp);
				return RTN_FAIL;
			}
		} while (true);

	}
	catch (...)
	{
		//关闭串口
		CString temp = _T("");
		temp.Format(_T("%s Timeout"), strTitel);
		this->Show_Progress(1.0);
		this->m_cla_Com_Port.Port_Close();
		this->m_csError_Code.Format(temp);
		return RTN_FAIL;
	}

	return RTN_FAIL;

}

static string W2AString(wchar_t* str)
{
	string re = "";
	int num = WideCharToMultiByte(
		CP_UTF8,	// ASCII码转换方式
		0,     // 默认转换方式
		str,    //输入字节
		-1,     //字符串大小，-1就是找\0计算大小
		0,      // 输出地址
		0,      // 输出空间大小
		0,
		0
	);// 返回宽字节大小

	if (num <= 0)
		return re;

	char* data = new char[num + 1];// \0
	data[0] = 0;// 对空间进行初始化
	num = WideCharToMultiByte(
		CP_UTF8,	// ASCII码转换方式
		0,     // 默认转换方式
		str,    //输入字节
		-1,     //字符串大小，-1就是找\0计算大小
		data,   // 输出地址
		num,    // 输出空间大小
		0,
		0
	);
	if (num > 0)
		re = data;
	delete data;  // 一定要释放空间，否则内存泄漏
	return re;    // 在函数结束后，系统会自动清理re的栈空间
}


static char* dup_wchar_to_utf8(wchar_t* w)
{
	char* s = NULL;

	// 获取所需要的空间大小。 倒数第3个数为0，则返回所需窄字符个数
	int n = WideCharToMultiByte(CP_UTF8, 0, w, -1, 0, 0, 0, 0);

	s = new char[n];// 开辟空间。 
	memset(s, 0, n);// 初始化

	if (s)
		n = WideCharToMultiByte(CP_UTF8, 0, w, -1, s, n, 0, 0);// 将w内容，n个窄字符赋给s.返回字符个数
	char* re;
	if (n >= 0)
		re = s;
	//delete s;// 理论来说该释放的。但是注释之后，程序报错。还未找到答案
	return re;// re会自己清空
}



int CARM_OP_QCM::Check_SSH(CString str_Titel, CString str_sshCmd, CString str_sshHostname, CString str_sshUsername, CString str_sshPassword, CString& str_sshReturnData, bool bNeedReturnData)
{
	// TODO: 在此处添加实现代码.
	CString Result, ERR_INFO, err_result, target;
	string::size_type idx;
	CString strTemp = _T("");
	Result = _T("");
	int iLinkResult = 0;

	CString str_Command = str_sshCmd;
	CString str_Hostname = str_sshHostname;
	CString str_Username = str_sshUsername;
	CString str_Password = str_sshPassword;

	this->Show_Status(str_Titel);
	this->Show_Out(str_Titel);
	this->Save_Trace_Log(str_Titel);

	int Temp = 0;
	try
	{
		memset(this->command, 0, sizeof(this->command));
		memset(this->hostname, 0, sizeof(this->hostname));
		memset(this->username, 0, sizeof(this->username));
		memset(this->password, 0, sizeof(this->password));

		//Temp = str_Command.GetLength() * sizeof(TCHAR);
		//memcpy(this->command, CW2A(str_Command), Temp);

		Temp = str_Hostname.GetLength() * sizeof(TCHAR);
		memcpy(this->hostname, CW2A(str_Hostname), Temp);

		Temp = str_Password.GetLength() * sizeof(TCHAR);
		memcpy(this->password, CW2A(str_Password), Temp);

		Temp = str_Username.GetLength() * sizeof(TCHAR);
		memcpy(this->username, CW2A(str_Username), Temp);

		m_sshconfig.hostname = this->hostname;
		m_sshconfig.username = this->username;
		m_sshconfig.password = this->password;
		//m_sshconfig.commandline = this->command;


		//MFC Unicode下CString转const char*
		CStringA     stra(str_Command.GetBuffer(0));
		str_Command.ReleaseBuffer();
		string          st(stra.GetBuffer(0));
		const char* cs_cmd = st.c_str();

		m_sshconfig.commandline = cs_cmd;

		

		for (int i = 0; i < 5; i++)
		{
			if (/*this->m_sshconfig.password*/str_sshPassword == "")
			{
				if (m_ssh.SSH_Query_NO_password(this->m_sshconfig, &ERR_INFO, &Result, &err_result, 500) == false)
				{
					strTemp.Format(_T("Link_SSH_NO_Password_Fail_%d, %s"), i, ERR_INFO);
					this->Show_Status(strTemp);
					this->Show_Out(strTemp);
					this->Save_Trace_Log(strTemp);
					this->m_csError_Code = strTemp;
					this->m_iError_Code = DL_SSH_LINK_fail;
					iLinkResult = 0;
					Sleep(5000);
				}
				else
				{
					iLinkResult = 1;
					break;
				}
			}
			else
			{
				if (m_ssh.SSH_Query(this->m_sshconfig, &ERR_INFO, &Result, &err_result, 500) == false)
				{
					strTemp.Format(_T("Link_SSH_Password_Fail_%d, %s"), i, ERR_INFO);
					this->Show_Status(strTemp);
					this->Show_Out(strTemp);
					this->Save_Trace_Log(strTemp);
					this->m_csError_Code = strTemp;
					this->m_iError_Code = DL_SSH_LINK_fail;
					iLinkResult = 0;
					Sleep(5000);
				}
				else
				{
					iLinkResult = 1;
					break;
				}
			}

			if (i >= 5)
			{
				throw(0);
			}

		}


		//target = _T("HWaddr");
		//idx = Result.Find(target);
		//if (idx == string::npos)//不存在。
		//{
		//	throw(0);
		//}

		str_sshReturnData = Result;

		if (bNeedReturnData == true)
		{
			if (str_sshReturnData.IsEmpty())
			{
				strTemp = _T("SSH Cmd return data fail");
				this->Show_Status(strTemp);
				this->Show_Out(strTemp);
				this->Save_Trace_Log(strTemp);
				this->m_csError_Code = strTemp;
				this->m_iError_Code = DL_SSH_CmdReturnData_fail;
				throw(0);
			}
		}
		

	}
	catch (...)
	{
		iLinkResult = 0;
		strTemp.Format(_T("catch error Link_SSH_Fail, %s"), ERR_INFO);
		this->Show_Status(strTemp);
		this->Show_Out(strTemp);
		this->Save_Trace_Log(strTemp);
		this->m_csError_Code = strTemp;
		this->m_iError_Code = DL_SSH_LINK_fail;
		return RTN_FAIL;
	}

	if (iLinkResult == 0)
	{
		strTemp.Format(_T("Link_SSH_Fail, %s"), ERR_INFO);
		this->Show_Status(strTemp);
		this->Show_Out(strTemp);
		this->Save_Trace_Log(strTemp);
		this->m_csError_Code = strTemp;
		this->m_iError_Code = DL_SSH_LINK_fail;
		return RTN_FAIL;
	}


	strTemp = _T("Link_SSH_OK");
	this->Show_Status(strTemp);
	this->Show_Out(strTemp);
	this->Save_Trace_Log(strTemp);

	return RTN_SUCCESS;
}


int CARM_OP_QCM::QDM046_CustomerFlowTest()
{
	// TODO: 在此处添加实现代码.
	int iResult_Flag = RTN_FAIL;

	CString str_IMAGE = _T("emmc-ipq807x-single-manufacturing-base-2.32.0-1-mfg-alpha-4.0.3.img");
	CString str_BeforeUpdataMd5_HLOS = _T("");
	CString str_BeforeUpdataMd5_rootfs = _T("");

	CString str_SSH_Hostname = /*str_InputSN*/_T("192.168.200.150");
	CString str_SSH_Username = _T("root");
	CString str_SSH_Password = _T("");
	CString str_SSH_Command = _T("");


	CString str_RecvData = _T("");
	CString str_TestTitel = _T("");

	this->Show_Progress(0.0);

	//SN连接产品
	str_SSH_Command = _T("hostname");
	str_TestTitel = _T("ssh connect and check sn...");

	if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
	{
		iResult_Flag = RTN_FAIL;
	}
	else
	{
		CString temp = _T("");
		temp.Format(_T("SSH recv data: %s"), str_RecvData);
		this->Show_Status(temp);
		this->Show_Out(temp);
		this->Save_Trace_Log(temp);

		if (str_RecvData.Find(str_InputSN)!=-1)
		{
			iResult_Flag = RTN_SUCCESS;
			Save_Trace_Log(_T("QDM046 check sn pass."));
			this->Show_Out(_T("QDM046 check sn pass."));
			this->Show_Status(_T("QDM046 check sn pass."));
			this->Show_Progress(1.0);
		}
		else
		{
			iResult_Flag = RTN_FAIL;
			Save_Trace_Log(_T("QDM046 check sn fail."));
			this->Show_Out(_T("QDM046 check sn fail."));
			this->Show_Status(_T("QDM046 check sn fail."));
			this->m_csError_Code = _T("QDM046 check sn fail.");
			this->m_iError_Code = DL_SSH_CheckSN_fail;
		}
	}


	
	//EEPROM Verification
	/*
	* EEPROM CSUM: Valid (0x01ed7aed)
         EEPROM Vers: 3
              HW Rev: 4.0
               Model: VHC25
                 SKU: W000
             Country: C
              Serial: 000003005
           Eth Ports: 2
          DDR Option: 3
         EMMC Option: 1
   WiFi PA 5G Option: 2
   WiFi PA 2G Option: 2
	*/
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.1);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --base-eeprom");
		str_TestTitel = _T("Start EEPROM Verification...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			if ( str_RecvData.Find(_T("HW Rev: 4.0")) != -1 
				&& str_RecvData.Find(_T("Pass")) != -1 
				&& str_RecvData.Find(_T("Model: VHC25")) != -1
				&& str_RecvData.Find(_T("SKU: W000")) != -1
				&& str_RecvData.Find(_T("Country: C")) != -1
				&& str_RecvData.Find(_T("Serial: ") + str_InputSN.Right(9)) != -1
				&& str_RecvData.Find(_T("DDR Option: 3")) != -1
				&& str_RecvData.Find(_T("EMMC Option: 1")) != -1
				&& str_RecvData.Find(_T("WiFi PA 5G Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 2G Option: 2")) != -1
				)
			/*if (str_RecvData.Find(_T("HW Rev: 3.0")) != -1
				&& str_RecvData.Find(_T("Pass")) != -1
				&& str_RecvData.Find(_T("Model: VHC25")) != -1
				&& str_RecvData.Find(_T("SKU: W000")) != -1
				&& str_RecvData.Find(_T("Country: T")) != -1
				&& str_RecvData.Find(_T("Serial: ") + str_InputSN.Right(9)) != -1
				&& str_RecvData.Find(_T("DDR Option: 3")) != -1
				&& str_RecvData.Find(_T("EMMC Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 5G Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 2G Option: 2")) != -1
				)*/
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 EEPROM Verification Pass."));
				this->Show_Out(_T("QDM046 EEPROM Verification Pass."));
				this->Show_Status(_T("QDM046 EEPROM Verification Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 EEPROM Verification Fail."));
				this->Show_Out(_T("QDM046 EEPROM Verification Fail."));
				this->Show_Status(_T("QDM046 EEPROM Verification Fail."));
				this->m_csError_Code = _T("QDM046 EEPROM Verification Fail.");
				this->m_iError_Code = DL_SSH_EEPROMVerification_fail;
			}
		}
	}
	

	//Verify MAC Addresses
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.2);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --base-mac-addr");
		str_TestTitel = _T("Start Verify MAC Addresses...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			str_RecvData = str_RecvData.MakeUpper();
			str_DB_R3_Mac = str_DB_R3_Mac.MakeUpper();

			str_RecvData.Replace(_T(":"), _T(""));
			if (str_RecvData.Replace(_T("BASE MAC ADDR"), _T("BASE MAC ADDR")) == 9
				&& str_RecvData.Find(_T("PASS")) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000000"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000001"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000002"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000003"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000004"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000005"), 6)) != -1
				)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 Verify MAC Addresses Pass."));
				this->Show_Out(_T("QDM046 Verify MAC Addresses Pass."));
				this->Show_Status(_T("QDM046 Verify MAC Addresses Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Verify MAC Addresses Fail."));
				this->Show_Out(_T("QDM046 Verify MAC Addresses Fail."));
				this->Show_Status(_T("QDM046 Verify MAC Addresses Fail."));
				this->m_csError_Code = _T("QDM046 Verify MAC Addresses Fail.");
				this->m_iError_Code = DL_SSH_VerifyMAC_fail;
			}
		}
	}




	// Firmware Version Check
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.3);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --manufacturing-version");
		str_TestTitel = _T("Start Firmware Version Check...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			if (str_RecvData.Find(_T("Pass")) != -1
				&& str_RecvData.Find(_T("Version: 2.32.0-1.mfg.alpha.4.0.3")) != -1
				&& str_RecvData.Find(_T("Version: qsdk-ipq-spf11-1-cs-p1")) != -1
				&& str_RecvData.Find(_T("Version: Wed 25 Oct 15:20:20 UTC 2023")) != -1
				)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 Firmware Version Check Pass."));
				this->Show_Out(_T("QDM046 Firmware Version Check Pass."));
				this->Show_Status(_T("QDM046 Firmware Version Check Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Firmware Version Check Fail."));
				this->Show_Out(_T("QDM046 Firmware Version Check Fail."));
				this->Show_Status(_T("QDM046 Firmware Version Check Fail."));
				this->m_csError_Code = _T("QDM046 Firmware Version Check Fail.");
				this->m_iError_Code = DL_SSH_FirmwareVersionCheck_fail;
			}
		}
	}

\


	//升级前MD5 Check

	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.4);
		str_RecvData = _T("");
		str_SSH_Command = _T("md5sum /dev/disk/by-partlabel/0:HLOS");
		str_TestTitel = _T("Start MD5 Check before upgrade HLOS...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			str_BeforeUpdataMd5_HLOS = Get_Md5_String(str_RecvData);
	

			if (str_BeforeUpdataMd5_HLOS.IsEmpty() == FALSE && str_BeforeUpdataMd5_HLOS.GetLength() ==32)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 MD5 Check before upgrade (HLOS) Pass."));
				this->Show_Out(_T("QDM046 MD5 Check before upgrade (HLOS) Pass."));
				this->Show_Status(_T("QDM046 MD5 Check before upgrade (HLOS) Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 MD5 Check before upgrade (HLOS) Fail."));
				this->Show_Out(_T("QDM046 MD5 Check before upgrade (HLOS) Fail."));
				this->Show_Status(_T("QDM046 MD5 Check before upgrade (HLOS) Fail."));
				this->m_csError_Code = _T("QDM046 MD5 Check before upgrade (HLOS) Fail.");
				this->m_iError_Code = DL_SSH_CheckBeforeUpgrade_HLOS_fail;
			}
		}
	}

	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.5);
		str_RecvData = _T("");
		str_SSH_Command = _T("md5sum /dev/disk/by-partlabel/rootfs");
		str_TestTitel = _T("Start MD5 Check before upgrade rootfs...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			str_BeforeUpdataMd5_rootfs = Get_Md5_String(str_RecvData);


			if (str_BeforeUpdataMd5_rootfs.IsEmpty() == FALSE && str_BeforeUpdataMd5_rootfs.GetLength() == 32)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 MD5 Check before upgrade (rootfs) Pass."));
				this->Show_Out(_T("QDM046 MD5 Check before upgrade (rootfs) Pass."));
				this->Show_Status(_T("QDM046 MD5 Check before upgrade (rootfs) Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 MD5 Check before upgrade (rootfs) Fail."));
				this->Show_Out(_T("QDM046 MD5 Check before upgrade (rootfs) Fail."));
				this->Show_Status(_T("QDM046 MD5 Check before upgrade (rootfs) Fail."));
				this->m_csError_Code = _T("QDM046 MD5 Check before upgrade (rootfs) Fail.");
				this->m_iError_Code = DL_SSH_CheckBeforeUpgrade_rootfs_fail;
			}
		}
	}


	//Update from uSD Card
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.6);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/sbin/update-single-img.py /tmp/sdcard/") + str_IMAGE;
		Save_Trace_Log(str_SSH_Command);
		this->Show_Out(str_SSH_Command);
		this->Show_Status(str_SSH_Command);
		str_TestTitel = _T("Start Update from uSD Card...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			Sleep(1000);

			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			str_RecvData = str_RecvData.MakeLower();
			if (str_RecvData.Find(_T("fail")) == -1 
				&& str_RecvData.Find(_T("error")) == -1 
				&& str_RecvData.Find(_T("done")) != -1 
				&& str_RecvData.Find(_T("programming partitions")) != -1
				&& str_RecvData.Find(_T("bootconfig1")) != -1
				) //Programming partitions  //BOOTCONFIG1
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 Update from uSD Card Pass."));
				this->Show_Out(_T("QDM046 Update from uSD Card Pass."));
				this->Show_Status(_T("QDM046 Update from uSD Card Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Update from uSD Card Fail."));
				this->Show_Out(_T("QDM046 Update from uSD Card Fail."));
				this->Show_Status(_T("QDM046 Update from uSD Card Fail."));
				this->m_csError_Code = _T("QDM046 Update from uSD Card Fail.");
				this->m_iError_Code = DL_SSH_UpdateFromUSDCard_fail;
			}
		}
	}


	//Disable the Veea Manufacturing Test Mode

	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.7);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --base-test-mode-disable");
		str_TestTitel = _T("Start Base Test Mode Disable...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			str_RecvData = str_RecvData.MakeLower();
			if (str_RecvData.Find(_T("pass")) != -1)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 Base Test Mode Disable Pass."));
				this->Show_Out(_T("QDM046 Base Test Mode Disable Pass."));
				this->Show_Status(_T("QDM046 Base Test Mode Disable Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Base Test Mode Disable Fail."));
				this->Show_Out(_T("QDM046 Base Test Mode Disable Fail."));
				this->Show_Status(_T("QDM046 Base Test Mode Disable Fail."));
				this->m_csError_Code = _T("QDM046 Base Test Mode Disable Fail.");
				this->m_iError_Code = DL_SSH_BaseTestModeDisable_fail;
			}
		}
	}



	//升级后不能重启，MD5 Check，确认MD5值是否变化
	
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.8);
		str_RecvData = _T("");
		str_SSH_Command = _T("md5sum /dev/disk/by-partlabel/0:HLOS");
		str_TestTitel = _T("Start MD5 Check after upgrade HLOS...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			CString str_AfterUpdataMd5_HLOS = Get_Md5_String(str_RecvData);

			if (str_AfterUpdataMd5_HLOS.IsEmpty()==FALSE && str_AfterUpdataMd5_HLOS.GetLength() == 32  && str_AfterUpdataMd5_HLOS != str_BeforeUpdataMd5_HLOS)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 MD5 Check after upgrade (HLOS) Pass."));
				this->Show_Out(_T("QDM046 MD5 Check after upgrade (HLOS) Pass."));
				this->Show_Status(_T("QDM046 MD5 Check after upgrade (HLOS) Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 MD5 Check after upgrade (HLOS) Fail."));
				this->Show_Out(_T("QDM046 MD5 Check after upgrade (HLOS) Fail."));
				this->Show_Status(_T("QDM046 MD5 Check after upgrade (HLOS) Fail."));
				this->m_csError_Code = _T("QDM046 MD5 Check after upgrade (HLOS) Fail.");
				this->m_iError_Code = DL_SSH_CheckAfterUpgrade_HLOS_fail;
			}
		}
	}

	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.9);
		str_RecvData = _T("");
		str_SSH_Command = _T("md5sum /dev/disk/by-partlabel/rootfs");
		str_TestTitel = _T("Start MD5 Check after upgrade rootfs...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			CString str_AfterUpdataMd5_rootfs = Get_Md5_String(str_RecvData);

			if (str_AfterUpdataMd5_rootfs.IsEmpty() == FALSE && str_AfterUpdataMd5_rootfs.GetLength() == 32 && str_AfterUpdataMd5_rootfs != str_BeforeUpdataMd5_rootfs)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 MD5 Check after upgrade (rootfs) Pass."));
				this->Show_Out(_T("QDM046 MD5 Check after upgrade (rootfs) Pass."));
				this->Show_Status(_T("QDM046 MD5 Check after upgrade (rootfs) Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 MD5 Check after upgrade (rootfs) Fail."));
				this->Show_Out(_T("QDM046 MD5 Check after upgrade (rootfs) Fail."));
				this->Show_Status(_T("QDM046 MD5 Check after upgrade (rootfs) Fail."));
				this->m_csError_Code = _T("QDM046 MD5 Check after upgrade (rootfs) Fail.");
				this->m_iError_Code = DL_SSH_CheckAfterUpgrade_rootfs_fail;
			}
		}
	}
	

	//分区check
	/*
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.0);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/sbin/verify-unit.py");  // /usr/local/sbin/verify-unit.py
		str_TestTitel = _T("Start Check Partition...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			this->Show_Progress(0.5);
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			str_RecvData.Replace(_T(" "), _T(""));
			str_RecvData.Replace(_T("\r"), _T(""));
			str_RecvData.Replace(_T("\n"), _T(""));

			if (str_RecvData.Find(_T("verify-unit:NoCMSInfoFound"))!=-1)
			{
				int iCount = -1;
				iCount = str_RecvData.Find(_T("verify-unit:NoCMSInfoFound"));

				if (str_RecvData.Find(_T("Noverify-unit:"), iCount) != -1 
					&& str_RecvData.Replace(_T("Noverify-unit:"), _T("Noverify-unit:")) == 1
					&& str_RecvData.Replace(_T("Yes"), _T("Yes")) == 17
					)
				{
					this->Show_Progress(1.0);
					iResult_Flag = RTN_SUCCESS;
					Save_Trace_Log(_T("QDM046 Check Partition Pass."));
					this->Show_Out(_T("QDM046 Check Partition Pass."));
					this->Show_Status(_T("QDM046 Check Partition Pass."));
				}
				else
				{
					iResult_Flag = RTN_FAIL;
					Save_Trace_Log(_T("QDM046 Check Partition Fail."));
					this->Show_Out(_T("QDM046 Check Partition Fail."));
					this->Show_Status(_T("QDM046 Check Partition Fail."));
					this->m_csError_Code = _T("QDM046 Check Partition Fail.");
					this->m_iError_Code = DL_SSH_CheckPartition_fail;
				}
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Check Partition Fail."));
				this->Show_Out(_T("QDM046 Check Partition Fail."));
				this->Show_Status(_T("QDM046 Check Partition Fail."));
				this->m_csError_Code = _T("QDM046 Check Partition Fail.");
				this->m_iError_Code = DL_SSH_CheckPartition_fail;
			}

			
		}
	}
	*/

	
	//EEPROM Verification
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.9);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --base-eeprom");
		str_TestTitel = _T("Start EEPROM Verification...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			if (str_RecvData.Find(_T("HW Rev: 4.0")) != -1
				&& str_RecvData.Find(_T("Pass")) != -1
				&& str_RecvData.Find(_T("Model: VHC25")) != -1
				&& str_RecvData.Find(_T("SKU: W000")) != -1
				&& str_RecvData.Find(_T("Country: C")) != -1
				&& str_RecvData.Find(_T("Serial: ") + str_InputSN.Right(9)) != -1
				&& str_RecvData.Find(_T("DDR Option: 3")) != -1
				&& str_RecvData.Find(_T("EMMC Option: 1")) != -1
				&& str_RecvData.Find(_T("WiFi PA 5G Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 2G Option: 2")) != -1
				)
			/*if (str_RecvData.Find(_T("HW Rev: 3.0")) != -1
				&& str_RecvData.Find(_T("Pass")) != -1
				&& str_RecvData.Find(_T("Model: VHC25")) != -1
				&& str_RecvData.Find(_T("SKU: W000")) != -1
				&& str_RecvData.Find(_T("Country: T")) != -1
				&& str_RecvData.Find(_T("Serial: ") + str_InputSN.Right(9)) != -1
				&& str_RecvData.Find(_T("DDR Option: 3")) != -1
				&& str_RecvData.Find(_T("EMMC Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 5G Option: 2")) != -1
				&& str_RecvData.Find(_T("WiFi PA 2G Option: 2")) != -1
				)*/
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 EEPROM Verification Pass."));
				this->Show_Out(_T("QDM046 EEPROM Verification Pass."));
				this->Show_Status(_T("QDM046 EEPROM Verification Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 EEPROM Verification Fail."));
				this->Show_Out(_T("QDM046 EEPROM Verification Fail."));
				this->Show_Status(_T("QDM046 EEPROM Verification Fail."));
				this->m_csError_Code = _T("QDM046 EEPROM Verification Fail.");
				this->m_iError_Code = DL_SSH_EEPROMVerification_fail;
			}
		}
	}
	

	//Verify MAC Addresses
	/*
	Base MAC Address Max Exec Time: 5.0 Secs 

Base MAC Addr: 00:76:3d:01:27:80
Base MAC Addr: 00:76:3d:01:27:81
Base MAC Addr: 00:76:3d:01:27:82
Base MAC Addr: 00:76:3d:01:27:83
Base MAC Addr: 00:76:3d:01:27:84
Base MAC Addr: 00:76:3d:01:27:85

Base MAC Address Exec Time: 32.31 mSec(s)
Base MAC Address Status: [32mPass[0m
	*/
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.9);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/stax-test.py --base-mac-addr");
		str_TestTitel = _T("Start Verify MAC Addresses...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);

			str_RecvData = str_RecvData.MakeUpper();
			str_DB_R3_Mac = str_DB_R3_Mac.MakeUpper();

			str_RecvData.Replace(_T(":"), _T(""));
			if (str_RecvData.Replace(_T("BASE MAC ADDR"), _T("BASE MAC ADDR")) == 9
				&& str_RecvData.Find(_T("PASS")) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000000"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000001"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000002"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000003"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000004"), 6)) != -1
				&& str_RecvData.Find(CStringHexSum(str_DB_R3_Mac, _T("000000000005"), 6)) != -1
				)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 Verify MAC Addresses Pass."));
				this->Show_Out(_T("QDM046 Verify MAC Addresses Pass."));
				this->Show_Status(_T("QDM046 Verify MAC Addresses Pass."));
			}
			else
			{
				iResult_Flag = RTN_FAIL;
				Save_Trace_Log(_T("QDM046 Verify MAC Addresses Fail."));
				this->Show_Out(_T("QDM046 Verify MAC Addresses Fail."));
				this->Show_Status(_T("QDM046 Verify MAC Addresses Fail."));
				this->m_csError_Code = _T("QDM046 Verify MAC Addresses Fail.");
				this->m_iError_Code = DL_SSH_VerifyMAC_fail;
			}
		}
	}

	
	//reset
	if (RTN_SUCCESS == iResult_Flag)
	{
		this->Show_Progress(0.9);
		str_RecvData = _T("");
		str_SSH_Command = _T("/usr/local/bin/hardware_reset.sh");
		str_TestTitel = _T("Start hardware_reset...");

		if (Check_SSH(str_TestTitel, str_SSH_Command, str_SSH_Hostname, str_SSH_Username, str_SSH_Password, str_RecvData, false) != RTN_SUCCESS)
		{
			iResult_Flag = RTN_FAIL;
		}
		else
		{
		
			CString temp = _T("");
			temp.Format(_T("SSH recv data: %s"), str_RecvData);
			this->Show_Status(temp);
			this->Show_Out(temp);
			this->Save_Trace_Log(temp);


			str_RecvData = str_RecvData.MakeLower();

			if (str_RecvData.Find(_T("error")) == -1 
				&& str_RecvData.Find(_T("fail")) == -1
				)
			{
				iResult_Flag = RTN_SUCCESS;
				Save_Trace_Log(_T("QDM046 hardware_reset Pass."));
				this->Show_Out(_T("QDM046 hardware_reset Pass."));
				this->Show_Status(_T("QDM046 hardware_reset Pass."));
			}
			else
			{
				Save_Trace_Log(_T("QDM046 hardware_reset Fail."));
				this->Show_Out(_T("QDM046 hardware_reset Fail."));
				this->Show_Status(_T("QDM046 hardware_reset Fail."));
				this->m_csError_Code = _T("QDM046 hardware_reset Fail.");
				this->m_iError_Code = DL_SSH_EEPROMVerification_fail;
			}
		}
	}
	



	this->Show_Progress(1.0);
	return iResult_Flag;
}


int CARM_OP_QCM::Check_SSH_NOReturnData(CString str_Titel, CString str_sshCmd, CString str_sshHostname, CString str_sshUsername, CString str_sshPassword)
{
	// TODO: 在此处添加实现代码.
	CString Result, ERR_INFO, err_result, target;
	string::size_type idx;
	CString strTemp = _T("");
	Result = _T("");
	int iLinkResult = 0;

	CString str_Command = str_sshCmd;
	CString str_Hostname = str_sshHostname;
	CString str_Username = str_sshUsername;
	CString str_Password = str_sshPassword;

	this->Show_Status(str_Titel);
	this->Show_Out(str_Titel);
	this->Save_Trace_Log(str_Titel);

	int Temp = 0;
	try
	{
		memset(this->command, 0, sizeof(this->command));
		memset(this->hostname, 0, sizeof(this->hostname));
		memset(this->username, 0, sizeof(this->username));
		memset(this->password, 0, sizeof(this->password));

		Temp = str_Command.GetLength() * sizeof(TCHAR);
		memcpy(this->command, CW2A(str_Command), Temp);

		Temp = str_Hostname.GetLength() * sizeof(TCHAR);
		memcpy(this->hostname, CW2A(str_Hostname), Temp);

		Temp = str_Password.GetLength() * sizeof(TCHAR);
		memcpy(this->password, CW2A(str_Password), Temp);

		Temp = str_Username.GetLength() * sizeof(TCHAR);
		memcpy(this->username, CW2A(str_Username), Temp);

		m_sshconfig.hostname = this->hostname;
		m_sshconfig.username = this->username;
		m_sshconfig.password = this->password;
		m_sshconfig.commandline = this->command;



		for (int i = 0; i < 5; i++)
		{
			if (/*this->m_sshconfig.password*/str_sshPassword == "")
			{
				if (m_ssh.SSH_Send_Command_No_password(this->m_sshconfig, &ERR_INFO) == false)
				{
					strTemp.Format(_T("Link_SSH_NO_Password_Fail_%d"), i);
					this->Show_Status(strTemp);
					this->Show_Out(strTemp);
					this->Save_Trace_Log(strTemp);
					this->m_csError_Code = strTemp;
					this->m_iError_Code = DL_SSH_LINK_fail;
					iLinkResult = 0;
					Sleep(5000);
				}
				else
				{
					iLinkResult = 1;
					break;
				}
			}
			else
			{
				if (m_ssh.SSH_Send_Command(this->m_sshconfig, &ERR_INFO) == false)
				{
					strTemp.Format(_T("Link_SSH_Password_Fail_%d"), i);
					this->Show_Status(strTemp);
					this->Show_Out(strTemp);
					this->Save_Trace_Log(strTemp);
					this->m_csError_Code = strTemp;
					this->m_iError_Code = DL_SSH_LINK_fail;
					iLinkResult = 0;
					Sleep(5000);
				}
				else
				{
					iLinkResult = 1;
					break;
				}
			}

			if (i >= 5)
			{
				throw(0);
			}

		}


		//target = _T("HWaddr");
		//idx = Result.Find(target);
		//if (idx == string::npos)//不存在。
		//{
		//	throw(0);
		//}

		

	}
	catch (...)
	{
		iLinkResult = 0;
		strTemp = _T("catch error, Link_SSH_Fail");
		this->Show_Status(strTemp);
		this->Show_Out(strTemp);
		this->Save_Trace_Log(strTemp);
		this->m_csError_Code = strTemp;
		this->m_iError_Code = DL_SSH_LINK_fail;
		return RTN_FAIL;
	}

	if (iLinkResult == 0)
	{
		strTemp = _T("Link_SSH_Fail");
		this->Show_Status(strTemp);
		this->Show_Out(strTemp);
		this->Save_Trace_Log(strTemp);
		this->m_csError_Code = strTemp;
		this->m_iError_Code = DL_SSH_LINK_fail;
		return RTN_FAIL;
	}


	strTemp = _T("Link_SSH_OK");
	this->Show_Status(strTemp);
	this->Show_Out(strTemp);
	this->Save_Trace_Log(strTemp);

	return RTN_SUCCESS;
}


CString CARM_OP_QCM::Get_Md5_String(CString str)
{
	// TODO: 在此处添加实现代码.
	CString str_Md5 = _T("");
	std::regex pattern("[0-9A-Za-z]{32}"); // 匹配由数字和字母组成的32位字符串
	CT2A convertedStr(str);
	std::string inputStr(convertedStr);
	//std::string inputStr = (LPCTSTR)str;
	std::smatch match;
	std::string::const_iterator searchStart(inputStr.cbegin());

	while (std::regex_search(searchStart, inputStr.cend(), match, pattern))
	{
		std::string str = match[0];
		CString cstr(str.c_str());
		str_Md5 = (LPCTSTR)cstr;
		//searchStart = match[0].second; // 更新搜索开始位置
		break;
	}

	CString temp = _T("");
	temp.Format(_T("Md5: %s"), str_Md5);
	Save_Trace_Log(temp);
	this->Show_Out(temp);
	this->Show_Status(temp);

	return str_Md5;
}


CString CARM_OP_QCM::CStringHexSum(CString strHex1, CString strHex2, int iByteNum)
{
	/*
	参数解释：
	strHex1：被加数，CString型十六进制数，例“EEEE”…
	strHex2：加数， CString型十六进制数，例“00EE”…
	int iByteNum:字节数 ，一般为相加字符串长度的1/2.
	*/
	BYTE* bstrHex1;
	bstrHex1 = new BYTE[iByteNum];
	BYTE* bstrHex2;
	bstrHex2 = new BYTE[iByteNum];

	BYTE btemp1, btemp2;
	CString strtemp1, strtemp2;
	int iStart = 0;

	//将CString型字符串转字节数组
	for (int i = 0; i < iByteNum; i++)
	{
		strtemp1 = strHex1.Mid(iStart, 2);              //将字符串分字节分割
		strtemp2 = strHex2.Mid(iStart, 2);
		btemp1 = (BYTE)_tcstoul(strtemp1, NULL, 16);   //转换函数，将一个字节的十六进制数转成BYTE
		btemp2 = (BYTE)_tcstoul(strtemp2, NULL, 16);
		bstrHex1[i] = btemp1;
		bstrHex2[i] = btemp2;
		iStart = iStart + 2;
	}


	//十六进制数相加
	for (int j = iByteNum - 1; j >= 0; j--)
	{
		if (j != (iByteNum - 1) && (int)((int)bstrHex1[j + 1] + (int)bstrHex2[j + 1]) > 255)
		{
			bstrHex1[j] = bstrHex1[j] + bstrHex2[j] + 1;    //如果有进位则加1
		}
		else
			bstrHex1[j] = bstrHex1[j] + bstrHex2[j];
	}
	CString strResult, strtemp;

	for (int k = 0; k < iByteNum; k++) {
		strtemp.Format(L"%02X", bstrHex1[k]);     //将BYTE型数据转回字符串
		strResult = strResult + strtemp;                 //将结果拼接
	}
	return strResult;                            //返回结果
}


int CARM_OP_QCM::QDM055_CustomerFlowTest()
{
	int iResult_Flag = RTN_FAIL;


	iResult_Flag = QDM055_QCX_Flashtool(_T("DVT"));


	if (RTN_SUCCESS == iResult_Flag)
	{
		Sleep(20000);
		iResult_Flag = Write_Check_Lock_SerialNumber();
	}


	if (RTN_SUCCESS == iResult_Flag)
	{
		iResult_Flag = QCX_Aware_Service_Provisioning(_T("DEMO"));
	}

	

	//if (RTN_SUCCESS == iResult_Flag)
	//{
	//	AfxMessageBox(_T("请抬起夹具然后下压，确保出AT口，再进行测试"));
	//	iResult_Flag = QCX_216_ShutDown();
	//}


	this->Show_Progress(1.0);
	return iResult_Flag;
}


int CARM_OP_QCM::QCX_216_ShutDown()
{
	Sleep(3000);

	CString str_ATCMD = _T("AT$QCPOWD=1");

	if (RunComCmd(_T("QCX_216_Shutdown ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = QCX_Shutdown_Fail;
		return RTN_FAIL;
	}

	Sleep(3000);
	str_ATCMD = _T("AT+CGSN=0");

	if (RunComCmd(_T("Read SN ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, m_DB_Barcode, 5) == true)
	{
		this->m_iError_Code = QCX_CheckShutdown_Fail;
		return RTN_FAIL;
	}

	this->Show_Status(_T("QCX_216 Check Shutdown OK;"));
	this->Show_Out(_T("QCX_216 Check Shutdown OK;"));
	this->Save_Trace_Log(_T("QCX_216 Check Shutdown OK;"));


	return RTN_SUCCESS;
}

int CARM_OP_QCM::QDM055_QCX_Flashtool(CString str_Dev_Type)
{
	CString csTemp = _T("");
	bool bextract = false;
	bool bprobe = false;
	bool berase = false;
	bool bburn = false;
	bool breset = false;

	try
	{
		//显示
		this->Show_Status(_T("QCX_Flashtool..."));
		this->Save_Trace_Log(_T("QCX_Flashtool..."));
		this->Show_Out(_T("QCX_Flashtool..."));


		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("python.exe"));
		m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));
		Sleep(50);


	
		//------------------------------ 打包dos指令 ------------------------------

		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;
		CString str_CMD = _T("");

		strCmd_file_name.Format(_T("%s\\QDM055\\Flashtool_run.bat"), this->m_csCurr_Exe_Path);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}

		CString str_build_NumberPath = m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\'));
		CString str_QCX_FlashtoolPath = str_build_NumberPath + _T("\\Factory Scripts\\Factory\\QCX216\\QCX_FW_Loader");
		CString str_QCX_FlashtoolBatFullNamePath = _T("");

		TraversFolderFile(str_QCX_FlashtoolPath, _T("QCX_Flashtool.bat"), str_QCX_FlashtoolBatFullNamePath);

		if (str_QCX_FlashtoolBatFullNamePath == _T(""))
		{
			this->m_csError_Code.Format(_T("FAIL, QCX_FlashtoolBat Not Found!"));
			this->Show_Status(m_csError_Code);
			this->Save_Trace_Log(m_csError_Code);
			this->Show_Out(m_csError_Code);
			this->m_iError_Code = QCX_FlashtoolBat_Not_Found;
			throw(1);
		}

		CString str_QCX_Flashtool_Bat_Path = str_QCX_FlashtoolBatFullNamePath.Left(str_QCX_FlashtoolBatFullNamePath.ReverseFind('\\'));
		
		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			Cmd_File.WriteString(_T("cd /d \"") + str_QCX_Flashtool_Bat_Path + _T("\"\r\n"));

			csData.Format(_T("QCX_Flashtool.bat --loadflash -bno \"%s\" -bpath \"%s\" -dev_type %s\r\n"), this->m_csMCU_Name, str_build_NumberPath, str_Dev_Type);
			Cmd_File.WriteString(csData);

			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));
		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			return RTN_FAIL;
		}


		str_CMD.Format(_T("cmd.exe /c %s\\QDM055\\Flashtool_run.bat"), this->m_csCurr_Exe_Path);




		this->Save_Trace_Log(str_CMD);
		this->Show_Out(str_CMD);


		CString strTemp;
		strTemp.Format(_T("%d"), m_iCom_Port);

		WritePrivateProfileString(_T("DL_COM"), _T("Com_Num"), strTemp, this->m_csCurr_Exe_Path + _T("\\QDM055\\config.ini"));

		CopyFile(this->m_csCurr_Exe_Path + _T("\\QDM055\\config.ini"), str_QCX_Flashtool_Bat_Path + _T("\\config.ini"), FALSE);


		CFileFind f;
		if (f.FindFile(str_QCX_Flashtool_Bat_Path + _T("\\burn.log")))
		{
			int DelBackValue = -1;
			DelBackValue = DeleteFile(str_QCX_Flashtool_Bat_Path + _T("\\burn.log"));
			if (DelBackValue == 0)
			{
				this->Show_Status(_T("Del burn.log txt fail!"));
				this->Show_Out(_T("Del burn.log txt fail!"));
				this->Save_Trace_Log(_T("Del burn.log txt fail!"));
				this->m_iError_Code = Del_QCX_FlashtoolBat_Log_Fail;
				this->m_csError_Code = _T("Del burn.log txt fail!");
				throw(2);
			}
		}

		if (f.FindFile(str_QCX_Flashtool_Bat_Path + _T("\\erase.log")))
		{
			int DelBackValue = -1;
			DelBackValue = DeleteFile(str_QCX_Flashtool_Bat_Path + _T("\\erase.log"));
			if (DelBackValue == 0)
			{
				this->Show_Status(_T("Del erase.log txt fail!"));
				this->Show_Out(_T("Del erase.log txt fail!"));
				this->Save_Trace_Log(_T("Del erase.log txt fail!"));
				this->m_iError_Code = Del_QCX_FlashtoolBat_Log_Fail;
				this->m_csError_Code = _T("Del erase.log txt fail!");
				throw(2);
			}
		}

		if (f.FindFile(str_QCX_Flashtool_Bat_Path + _T("\\extract.log")))
		{
			int DelBackValue = -1;
			DelBackValue = DeleteFile(str_QCX_Flashtool_Bat_Path + _T("\\extract.log"));
			if (DelBackValue == 0)
			{
				this->Show_Status(_T("Del extract.log txt fail!"));
				this->Show_Out(_T("Del extract.log txt fail!"));
				this->Save_Trace_Log(_T("Del extract.log txt fail!"));
				this->m_iError_Code = Del_QCX_FlashtoolBat_Log_Fail;
				this->m_csError_Code = _T("Del extract.log txt fail!");
				throw(2);
			}
		}

		if (f.FindFile(str_QCX_Flashtool_Bat_Path + _T("\\probe.log")))
		{
			int DelBackValue = -1;
			DelBackValue = DeleteFile(str_QCX_Flashtool_Bat_Path + _T("\\probe.log"));
			if (DelBackValue == 0)
			{
				this->Show_Status(_T("Del probe.log txt fail!"));
				this->Show_Out(_T("Del probe.log txt fail!"));
				this->Save_Trace_Log(_T("Del probe.log txt fail!"));
				this->m_iError_Code = Del_QCX_FlashtoolBat_Log_Fail;
				this->m_csError_Code = _T("Del probe.log txt fail!");
				throw(2);
			}
		}

	/*	if (f.FindFile(str_QCX_Flashtool_Bat_Path + _T("\\reset.log")))
		{
			int DelBackValue = -1;
			DelBackValue = DeleteFile(str_QCX_Flashtool_Bat_Path + _T("\\reset.logg"));
			if (DelBackValue == 0)
			{
				this->Show_Status(_T("Del reset.log txt fail!"));
				this->Show_Out(_T("Del reset.log txt fail!"));
				this->Save_Trace_Log(_T("Del reset.log txt fail!"));
				this->m_iError_Code = Del_QCX_FlashtoolBat_Log_Fail;
				this->m_csError_Code = _T("Del reset.log txt fail!");
				throw(2);
			}
		}*/





		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("python.exe"));
		m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));

		PROCESS_INFORMATION pi;
		STARTUPINFO si;
		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.wShowWindow = SW_HIDE;
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
		if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
		{
			this->Show_Status(_T("Can not create QCX_Flashtool thread;"));
			this->Save_Trace_Log(_T("Can not create QCX_Flashtool thread;"));
			this->Show_Out(_T("Can not create QCX_Flashtool thread;"));
			this->m_iError_Code = DL_FW_FAIL4;
			this->m_csError_Code = _T("Can not create QCX_Flashtool thread;");
			return RTN_FAIL;
		}
		else
		{
			WaitForSingleObject(pi.hProcess, 80000);
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
		Sleep(1000);


		//读取log

		CStdioFile file;
		if (!file.Open(str_QCX_Flashtool_Bat_Path + _T("\\extract.log"), CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to open extract.log!");
			Save_Trace_Log(_T("FAIL: Unable to open extract.log!\r\n"));
			this->m_iError_Code = Open_QCX_FlashtoolBat_Log_Fail;
			throw(3);
		}
		else
		{
			this->Show_Status(_T("============extract.log============"));
			this->Save_Trace_Log(_T("============extract.log============"));
			this->Show_Out(_T("============extract.log============"));
		}

		CString str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("pkgextract finish")) != -1)
			{
				csTemp.Format(_T("Extract Pkg Complete"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.2);
				bextract = true;

			}
		}
		file.Close();

		if (!bextract)
		{
			csTemp.Format(_T("Extract Pkg Fail"));
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
			this->m_csError_Code = _T("Extract Pkg Fail");
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			//显示进度条
			this->Show_Progress(0.2);
		}


		//probe.log
		if (!file.Open(str_QCX_Flashtool_Bat_Path + _T("\\probe.log"), CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to open probe.log!");
			Save_Trace_Log(_T("FAIL: Unable to open probe.log!\r\n"));
			this->m_iError_Code = Open_QCX_FlashtoolBat_Log_Fail;
			throw(4);
		}
		else
		{
			this->Show_Status(_T("============probe.log============"));
			this->Save_Trace_Log(_T("============probe.log============"));
			this->Show_Out(_T("============probe.log============"));
		}

		str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("burn ok")) != -1)
			{
				csTemp.Format(_T("probe Burn OK!"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.4);
			    bprobe = true;
				
			}
		}
		file.Close();

		if (!bprobe)
		{
			csTemp.Format(_T("probe Burn Fail"));
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
			this->m_csError_Code = _T("probe Burn Fail");
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			//显示进度条
			this->Show_Progress(0.4);
		}


		//erase.log
		if (!file.Open(str_QCX_Flashtool_Bat_Path + _T("\\erase.log"), CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to open erase.log!");
			Save_Trace_Log(_T("FAIL: Unable to open erase.log!\r\n"));
			this->m_iError_Code = Open_QCX_FlashtoolBat_Log_Fail;
			throw(5);
		}
		else
		{
			this->Show_Status(_T("============erase.log============"));
			this->Save_Trace_Log(_T("============erase.log============"));
			this->Show_Out(_T("============erase.log============"));
		}

		str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("erase ok")) != -1)
			{
				csTemp.Format(_T("Erase OK!"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.6);
				berase = true;

			}
		}
		file.Close();

		if (!berase)
		{
			csTemp.Format(_T("Erase Fail"));
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
			this->m_csError_Code = _T("Erase Fail");
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			//显示进度条
			this->Show_Progress(0.6);
		}


		//burn.log
		if (!file.Open(str_QCX_Flashtool_Bat_Path + _T("\\burn.log"), CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to open burn.log!");
			Save_Trace_Log(_T("FAIL: Unable to open burn.log!\r\n"));
			this->m_iError_Code = Open_QCX_FlashtoolBat_Log_Fail;
			throw(7);
		}
		else
		{
			this->Show_Status(_T("============burn.log============"));
			this->Save_Trace_Log(_T("============burn.log============"));
			this->Show_Out(_T("============burn.log============"));
		}

		str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("burnbatch ok")) != -1)
			{
				csTemp.Format(_T("Burnbatch OK!"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.8);
				bburn = true;

			}
		}
		file.Close();

		if (!bburn)
		{
			csTemp.Format(_T("Burnbatch Fail"));
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
			this->m_csError_Code = _T("Burnbatch Fail");
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			//显示进度条
			this->Show_Progress(0.8);
		}


		//reset.log
		if (!file.Open(str_QCX_Flashtool_Bat_Path + _T("\\reset.log"), CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to reset burn.log!");
			Save_Trace_Log(_T("FAIL: Unable to open reset.log!\r\n"));
			this->m_iError_Code = Open_QCX_FlashtoolBat_Log_Fail;
			throw(8);
		}
		else
		{
			this->Show_Status(_T("============reset.log============"));
			this->Save_Trace_Log(_T("============reset.log============"));
			this->Show_Out(_T("============reset.log============"));
		}

		str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("processend")) != -1)
			{
				csTemp.Format(_T("reset ProcessEnd!"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(1.0);
				breset = true;
			}
		}
		file.Close();

		if (!breset)
		{
			csTemp.Format(_T("reset Fail"));
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
			this->m_csError_Code = _T("reset Fail");
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			//显示进度条
			this->Show_Progress(1.0);
		}


		if (bextract && bprobe && berase && bburn && breset)
		{
			csTemp = _T("QCX_Flashtool Burn OK");
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
		}
		else
		{
			csTemp = _T("QCX_Flashtool Burn Fail");
			this->Show_Status(csTemp);
			this->Show_Out(csTemp);
			this->Save_Trace_Log(csTemp);
			this->m_csError_Code = csTemp;
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			return RTN_FAIL;
		}



	}
	catch (...)
	{
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("python.exe"));
		m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));

		//csTemp = _T("catch QCX_Flashtool Burn Fail");
		//this->Show_Status(csTemp);
		//this->Show_Out(csTemp);
		//this->Save_Trace_Log(csTemp);
		//this->m_csError_Code = csTemp;
		this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
		return RTN_FAIL;

		this->Show_Progress(1.0);
		//
		return RTN_FAIL;
	}

	m_cla_GFC.Kill_Process(_T("cmd.exe"));
	m_cla_GFC.Kill_Process(_T("python.exe"));
	m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));


	this->Show_Progress(1.0);
	return RTN_SUCCESS;

}


int CARM_OP_QCM::Write_Check_Lock_SerialNumber()
{
	// TODO: 在此处添加实现代码.
	CString str_ATCMD = _T("");
	str_ATCMD.Format(_T("AT$QCCGSN=\"SN\",\"%s\""), m_DB_Barcode);

	if (RunComCmd(_T("Write SN ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = Write_SerialNumber_Fail;
		return RTN_FAIL;
	}


	str_ATCMD.Format(_T("AT$QCCGSN=\"IMEI\",\"%s\""), m_DB_IMEI);

	if (RunComCmd(_T("Write IMEI ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = Write_SerialNumber_Fail;
		return RTN_FAIL;
	}


	str_ATCMD = _T("AT+CGSN=0");

	if (RunComCmd(_T("Check SN ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, m_DB_Barcode, 5) == false)
	{
		this->m_iError_Code = Check_SerialNumber_Fail;
		return RTN_FAIL;
	}


	str_ATCMD = _T("AT+CGSN=1");

	if (RunComCmd(_T("Check IMEI ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, m_DB_IMEI, 5) == false)
	{
		this->m_iError_Code = Check_SerialNumber_Fail;
		return RTN_FAIL;
	}


	//Lock
	str_ATCMD = _T("AT$QCCGSNLOCK=\"SN\"");

	if (RunComCmd(_T("Lock SN ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = Check_SerialNumber_Fail;
		return RTN_FAIL;
	}

	str_ATCMD = _T("AT$QCCGSNLOCK=\"IMEI\"");

	if (RunComCmd(_T("Lock IMEI ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = Check_SerialNumber_Fail;
		return RTN_FAIL;
	}


	str_ATCMD = _T("AT$QCPCFG=\"faultaction\",4");

	if (RunComCmd(_T("Set Auto Reset ..."), m_iCom_Port_Auto_Sec, 115200, false, true, str_ATCMD, _T("OK"), 5) == false)
	{
		this->m_iError_Code = QCX_SetAutoReset_Fail;
		return RTN_FAIL;
	}

	return RTN_SUCCESS;
}


bool CARM_OP_QCM::RunComCmd(CString strTitel, int iPort, int iBaudRate, bool IsEnDTR, bool IsEnRTS, CString str_cmd, CString strExpected, int iTimeout)
{
	try
	{
		//----------------------- 打开串口----------------------- 
		this->m_cla_AT_Com_Port.Port_Close();
		Sleep(1000);
		CString str_csData = _T("");
		str_csData.Format(_T("Open Port%d ......"), iPort);
		this->Show_Status(str_csData);
		this->Show_Out(str_csData);
		this->Save_Trace_Log(str_csData);

		//以界面波特率打开串口
		//同步串口
		this->m_cla_AT_Com_Port.m_iBaudRate = iBaudRate;
		this->m_cla_AT_Com_Port.m_iPort = iPort;
		if (IsEnDTR)
		{
			this->m_cla_AT_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_ENABLE;
		}
		else
		{
			this->m_cla_AT_Com_Port.m_dwDTR_CTRL = DTR_CONTROL_DISABLE;
		}

		if (IsEnRTS)
		{
			this->m_cla_AT_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_ENABLE;
		}
		else
		{
			this->m_cla_AT_Com_Port.m_dwRTS_CTRL = RTS_CONTROL_DISABLE;
		}

		this->Show_Progress(0.1);

		//打开串口
		if (this->m_cla_AT_Com_Port.Port_Open(500) == false)
		{
			time_t start, finish;
			int iTimeOut = iTimeout;//打开端口改为循环查找打开的方式
			try
			{
				//
				time(&start);
				do
				{
					Sleep(200);
					if (true == this->m_cla_AT_Com_Port.Port_Open(500))
					{
						this->Show_Status(_T("Open Port Pass"));
						this->Show_Out(_T("Open Port Pass"));
						this->Save_Trace_Log(_T("Open Port Pass"));
						this->Show_Progress(0.2);
						break;
					}

					time(&finish);

					if ((int)difftime(finish, start) >= iTimeOut)
					{
						this->Show_Status(_T("Open Port Timeout"));
						this->Show_Out(_T("Open Port Timeout"));
						this->Save_Trace_Log(_T("Open Port Timeout"));
						this->m_csError_Code.Format(_T("Open Port Timeout"));
						this->Show_Progress(1.0);
						return false;
					}
				} while (true);
			}
			catch (...)
			{
				str_csData.Format(_T("%s"), this->m_cla_AT_Com_Port.m_csError_Info);
				this->Show_Status(str_csData);
				m_csError_Code = str_csData;
				this->Show_Out(str_csData);
				this->Save_Trace_Log(str_csData);
				this->Show_Progress(1.0);
				return false;
			}
		}

		this->Show_Status(strTitel);
		this->Show_Out(strTitel);
		this->Save_Trace_Log(strTitel);
		this->Show_Progress(0.2);



		//清空 COM BUFF
		this->m_cla_AT_Com_Port.Empty_Com_And_Rx_Buff();

		time_t start, finish;
		int iTimeOut = iTimeout, iRec_Bits;
		wchar_t wcrData[1280];
		CString str_RecvData = _T("");
		//
		time(&start);
		//
		do
		{
			//清空 COM BUFF
			this->m_cla_AT_Com_Port.Empty_Com_And_Rx_Buff();

			//发送
			this->m_cla_AT_Com_Port.Write(str_cmd);
			this->Show_Out(str_cmd);
			this->Save_Trace_Log(str_cmd);
			this->Show_Status(str_cmd);
			Sleep(700);


			Sleep(100);
			//
			memset(wcrData, 0, sizeof(wcrData));
			Sleep(200);
			//读取
			this->m_cla_AT_Com_Port.Read(wcrData, &iRec_Bits, 500);



			this->Show_Status(wcrData);
			this->Show_Out(wcrData);
			this->Save_Trace_Log(wcrData);

			CString str_Temp = _T("");
			str_Temp = wcrData;
			str_RecvData = str_RecvData + str_Temp;
			str_RecvData.Replace(_T("\r"), _T(""));
			str_RecvData.Replace(_T("\n"), _T(""));
			str_RecvData.Replace(_T(" "), _T(""));

			if (str_RecvData.Find(strExpected) != -1)
			{
				Sleep(1000);
				this->m_cla_AT_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				return true;
			}

			time(&finish);
			//
			if ((int)difftime(finish, start) >= iTimeOut)
			{
				CString temp = _T("");
				temp.Format(_T("%s Timeout"), strTitel);

				this->Show_Status(temp);
				this->Show_Out(temp);
				this->Save_Trace_Log(temp);
				this->m_cla_AT_Com_Port.Port_Close();
				this->Show_Progress(1.0);
				this->m_csError_Code.Format(temp);
				return false;
			}
		} while (true);


	}
	catch (...)
	{
		//关闭串口
		CString temp = _T("");
		temp.Format(_T("%s catch error, %s"), strTitel, this->m_cla_AT_Com_Port.m_csError_Info);
		this->Show_Progress(1.0);
		this->m_cla_AT_Com_Port.Port_Close();
		this->m_csError_Code.Format(temp);
		return false;
	}

	this->Show_Progress(1.0);
	this->m_cla_AT_Com_Port.Port_Close();
	return true;

}


int CARM_OP_QCM::QCX_Aware_Service_Provisioning(CString str_Environment)
{
	// TODO: 在此处添加实现代码.

	CString str_Aware_Configs_Folder = _T("");  //待定		
	CString str_Environment_String = str_Environment;
	CString str_Registration_CSV_File = this->m_csCurr_Exe_Path + _T("\\QDM055\\") + m_csMCU_Name2 + _T(".csv");


	CString str_build_NumberPath = m_csScat_Cfg_File_Path.Left(m_csScat_Cfg_File_Path.ReverseFind('\\'));
	CString str_QCX_Aware_Service_ProvisioningPath = str_build_NumberPath + _T("\\Factory Scripts\\Factory\\QCX216\\QCX_Aware_Service_Provisioning");
	CString str_QCX_Aware_Service_ProvisioningBat_FullNamePath = _T("");

	TraversFolderFile(str_QCX_Aware_Service_ProvisioningPath, _T("QCX_Aware_Service_Provisioning_factory.bat"), str_QCX_Aware_Service_ProvisioningBat_FullNamePath);

	if (str_QCX_Aware_Service_ProvisioningBat_FullNamePath == _T(""))
	{
		this->m_csError_Code.Format(_T("FAIL, QCX_Aware_Service_ProvisioningBat Not Found!"));
		this->Show_Status(m_csError_Code);
		this->Save_Trace_Log(m_csError_Code);
		this->Show_Out(m_csError_Code);
		this->m_iError_Code = QCX_Aware_Service_ProvisioningBat_Not_Found;
		return RTN_FAIL;
	}

	CString str_QCX_Aware_Service_ProvisioningBat_Path = str_QCX_Aware_Service_ProvisioningBat_FullNamePath.Left(str_QCX_Aware_Service_ProvisioningBat_FullNamePath.ReverseFind('\\'));

	str_Aware_Configs_Folder = str_build_NumberPath + _T("\\Aware_Configs");
	CString str_ProvisioningCsvLog_NameFullPath = str_QCX_Aware_Service_ProvisioningBat_Path + _T("\\Docs\\ProvisioningCsvLog.csv");
	CString strCom = _T("");
	strCom.Format(_T("COM%d"), m_iCom_Port_Auto_Sec);

	if (QCX_Aware_Service_Provisioning_RunScript(str_QCX_Aware_Service_ProvisioningBat_Path, str_Aware_Configs_Folder, str_Registration_CSV_File, str_Environment_String, str_ProvisioningCsvLog_NameFullPath, strCom) == false)
	{
		this->m_iError_Code = QCX_Aware_Service_Provisioning_Fail;
		return RTN_FAIL;
	}


	return RTN_SUCCESS;
}


bool CARM_OP_QCM::QCX_Aware_Service_Provisioning_RunScript(CString str_ScriptFullPath, CString Aware_Configs_Folder, CString Registration_CSV_File, CString Environment_String, CString str_ProvisioningCsvLog_NameFullPath, CString strCom)
{
		/*
			QCX_Aware_Service_Provisioning_factory.bat -t QCX216 -f "path of the 
			Aware_Configs folder" -s "path with file name of Registration CSV file" --env 
			environment_string -pf "path with provision file name with .csv extension" -p 
			COMName_OR_portNumber 
			Here, each of the command line option is described below 
			o    -t QCX216: The '-t' for the device type. Just use -tQCX216 as it is. 
			o    -f "path": The '-f' the full path of the 'Aware_Configs' folder in the release should be 
			given. 
			o    -s "path: The "-s" option is for the CSV file path. The script will check for the device 
			info using Serial number of the device. 
			o    --env environment_string: This is mandatory parameter and any one of the string 
			below mentioned should be given based on the environment you are working.  
			▪     E2E: For End to End environment 
			▪     INT: For INT environment 
			▪     DEV: For development environment 
			▪     PROD: For Production environment 
			▪     PERF: For performance environment 
			▪     DEMO: For Demo environment 
			o    -pf "path with provision file name with .csv extension": This is the path and file 
			name to generate the provision file. 
			o    -p COMName_OR_portNumber: The port number of the device or type the COM 
			name 

	*/


	
	CString csTemp = _T("");
	bool bPass1 = false;
	bool bPass2 = false;
	bool bPass3 = false;

	try
	{
		bool bDelRet = DeleteDirectory(str_ScriptFullPath + _T("\\logs"));
		if (bDelRet == false)
		{
			this->Show_Status(_T("Delete Provisioning LogFile Dir Fail"));
			this->Save_Trace_Log(_T("Delete Provisioning LogFile Dir Fail"));
			this->Show_Out(_T("Delete Provisioning LogFile Dir Fail"));
			this->m_csError_Code.Format(_T("Delete Provisioning LogFile Dir Fail"));

			throw(1);
		}
		else
		{
			this->Show_Status(_T("Delete Provisioning LogFile Dir Pass"));
			this->Save_Trace_Log(_T("Delete Provisioning LogFile Dir Pass"));
			this->Show_Out(_T("Delete Provisioning LogFile Dir Pass"));
		}

		//显示
		this->Show_Status(_T("QCX_Aware_Service_Provisioning ......"));
		this->Save_Trace_Log(_T("QCX_Aware_Service_Provisioning ......"));
		this->Show_Out(_T("QCX_Aware_Service_Provisioning ..."));


		CStdioFile Cmd_File;
		CString   strCmd_file_name, csData;
		unsigned long ul_File_Size;
		CString str_CMD = _T("");

		strCmd_file_name.Format(_T("%s\\QDM055\\QCX_Aware_Service_Provisioning.bat"), this->m_csCurr_Exe_Path);

		if (this->Get_File_Size(strCmd_file_name, &ul_File_Size) == true)
		{
			::SetFileAttributes(strCmd_file_name, FILE_ATTRIBUTE_NORMAL);

			::DeleteFile(strCmd_file_name);

			Sleep(2000);
		}



		if (Cmd_File.Open(strCmd_file_name, CFile::modeCreate | CFile::modeReadWrite | CFile::modeNoTruncate | CFile::typeText) != NULL)
		{
			Cmd_File.SeekToEnd();

			Cmd_File.WriteString(_T("cd /d") + str_ScriptFullPath + _T("\r\n"));

			csData.Format(_T("QCX_Aware_Service_Provisioning_factory.bat -t QCX216 -f \"%s\" -s \"%s\" --env %s -pf \"%s\" -p %s\r\n"), Aware_Configs_Folder, Registration_CSV_File, Environment_String, str_ProvisioningCsvLog_NameFullPath, strCom);
			Cmd_File.WriteString(csData);

			Cmd_File.Close();

			this->Show_Out(_T("CMD File Save OK"));
		}
		else
		{
			this->m_csError_Code.Format(_T("CMD File(%s) Open Fail!"), strCmd_file_name);
			this->Show_Out(this->m_csError_Code);
			this->m_iError_Code = QCX_Aware_Service_Provisioning_Fail;
			return false;
		}


		str_CMD.Format(_T("cmd.exe /c %s"), strCmd_file_name);

		this->Save_Trace_Log(str_CMD);

		//------------------------------ 创建 process ------------------------------ 
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("python.exe"));
		m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));

		PROCESS_INFORMATION pi;
		STARTUPINFO si;
		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.wShowWindow = SW_HIDE;
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
		if (!CreateProcess(NULL, str_CMD.GetBuffer(), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi))
		{
			this->Show_Status(_T("Can not create QCX_Aware_Service_Provisioning thread;"));
			this->Save_Trace_Log(_T("Can not create QCX_Aware_Service_Provisioning thread;"));
			this->Show_Out(_T("Can not create QCX_Aware_Service_Provisioning thread;"));
			this->m_iError_Code = QCX_Aware_Service_Provisioning_Fail;
			this->m_csError_Code = _T("Can not create QCX_Aware_Service_Provisioning thread;");
			return false;
		}
		else
		{
			WaitForSingleObject(pi.hProcess, 80000);
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
		}
		Sleep(1000);


		//------------------------------ Log处理
		CString str_Provisioning_Log_FullNamePath = _T("");
		TraversFolderFile(str_ScriptFullPath + _T("\\logs"), _T("log.txt"), str_Provisioning_Log_FullNamePath);

		if (str_Provisioning_Log_FullNamePath == _T(""))
		{
			this->Show_Status(_T("QCX_Aware_Service_Provisioning_TxtLogNotFound"));
			this->Save_Trace_Log(_T("QCX_Aware_Service_Provisioning_TxtLogNotFound"));
			this->Show_Out(_T("QCX_Aware_Service_Provisioning_TxtLogNotFound"));
			this->m_iError_Code = QCX_Aware_Service_Provisioning_TxtLogNotFound;
			this->m_csError_Code = _T("QCX_Aware_Service_Provisioning_TxtLogNotFound");
			throw(1);
		}

		CStdioFile file;
		if (!file.Open(str_Provisioning_Log_FullNamePath, CFile::modeRead))
		{
			this->m_csError_Code = _T("FAIL: Unable to open Provisioning_TxtLog!");
			Save_Trace_Log(_T("FAIL: Unable to open Provisioning_TxtLog!\r\n"));
			this->m_iError_Code = QCX_Aware_Service_Provisioning_TxtLogOpenFail;
			throw(3);
		}
		else
		{
			this->Show_Status(_T("============QCX_Aware_Service_Provisioning_TxtLog============"));
			this->Save_Trace_Log(_T("============QCX_Aware_Service_Provisioning_TxtLog============"));
			this->Show_Out(_T("============QCX_Aware_Service_Provisioning_TxtLog============"));
		}

		CString str_info = _T("");

		while (file.ReadString(str_info))
		{
			this->Save_Trace_Log(str_info);

			str_info.MakeLower();

			if (str_info.Find(_T("\"a.c.conf\" configured succesfully")) != -1)
			{
				csTemp.Format(_T("\"a.c.conf\" configured succesfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.1);
			}

			if (str_info.Find(_T("\"a.j.conf\" configured succesfully")) != -1)
			{
				csTemp.Format(_T("\"a.j.conf\" configured succesfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.2);
			}

			if (str_info.Find(_T("\"a.r.p.conf\" configured succesfully")) != -1)
			{
				csTemp.Format(_T("\"a.r.p.conf\" configured succesfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.3);
			}

			if (str_info.Find(_T("\"a.th.conf\" configured succesfully")) != -1)
			{
				csTemp.Format(_T("\"a.th.conf\" configured succesfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.4);
			}

			if (str_info.Find(_T("\"a2f.run\" configured succesfully")) != -1)
			{
				csTemp.Format(_T("\"a2f.run\" configured succesfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.5);
			}

			if (str_info.Find(_T("uploading root ca file success")) != -1)
			{
				csTemp.Format(_T("uploading root ca file success"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				bPass1 = true;
				//显示进度条
				this->Show_Progress(0.6);
			}


			if (str_info.Find(_T("provision csv file saved")) != -1)
			{
				csTemp.Format(_T("provision csv file saved"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				//显示进度条
				this->Show_Progress(0.7);
			}


			if (str_info.Find(_T("pc time is set success")) != -1)
			{
				csTemp.Format(_T("pc time is set success"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				bPass2 = true;
				//显示进度条
				this->Show_Progress(0.8);
			}

			if (str_info.Find(_T("configurations done successfully")) != -1)
			{
				csTemp.Format(_T("configurations done successfully"));
				this->Show_Status(csTemp);
				this->Save_Trace_Log(csTemp);
				this->Show_Out(csTemp);
				bPass3 = true;
				//显示进度条
				this->Show_Progress(0.9);
			}

		}
		file.Close();




		if (bPass1 && bPass2 && bPass3)
		{
			csTemp = _T("QCX_Aware_Service_Provisioning OK");
			this->Show_Status(csTemp);
			this->Save_Trace_Log(csTemp);
			this->Show_Out(csTemp);
		}
		else
		{
			csTemp = _T("QCX_Aware_Service_Provisioning Fail");
			this->Show_Status(csTemp);
			this->Show_Out(csTemp);
			this->Save_Trace_Log(csTemp);
			this->m_csError_Code = csTemp;
			this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;
			return false;
		}




	}
	catch (...)
	{
		//显示失败信息
		csTemp = _T("catch QCX_Aware_Service_Provisioning Fail");
		this->m_csError_Code = csTemp;
		this->m_iError_Code = Burn_QCX_FlashtoolBat_Fail;

		this->Show_Progress(1.0);
		m_cla_GFC.Kill_Process(_T("cmd.exe"));
		m_cla_GFC.Kill_Process(_T("python.exe"));
		m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));
		//
		return false;
	}

	m_cla_GFC.Kill_Process(_T("cmd.exe"));
	m_cla_GFC.Kill_Process(_T("python.exe"));
	m_cla_GFC.Kill_Process(_T("FlashToolCLI.exe"));

	this->Show_Progress(1.0);
	return true;

}


bool CARM_OP_QCM::DeleteDirectory(CString DirName)
{
	if (DirName.IsEmpty())
	{
		return false;
	}

	//首先删除文件及子文件夹     
	CFileFind   ff;
	BOOL   bFound = ff.FindFile(DirName + L"\\*", 0);
	while (bFound)
	{
		bFound = ff.FindNextFile();
		if (ff.GetFileName() == "." || ff.GetFileName() == "..")
			continue;
		//去掉文件(夹)只读等属性     
		SetFileAttributes(ff.GetFilePath(), FILE_ATTRIBUTE_NORMAL);
		if (ff.IsDirectory())
		{
			//递归删除子文件夹     
			DeleteDirectory(ff.GetFilePath());
			RemoveDirectory(ff.GetFilePath());
		}
		else
		{
			//删除文件     
			DeleteFile(ff.GetFilePath());
		}
	}
	ff.Close();

	//   然后删除该文件夹     
	//RemoveDirectory(strDir); 
	return true;
}


